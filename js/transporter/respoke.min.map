{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///respoke.min.js","webpack:///webpack/bootstrap 6c0b87596ac27ac556d9","webpack:///./index.js","webpack:///./respoke/respoke.js","webpack:///./respoke/event.js","webpack:///./respoke/client.js","webpack:///./respoke/presentable.js","webpack:///./respoke/connection.js","webpack:///./respoke/endpoint.js","webpack:///./respoke/textMessage.js","webpack:///./respoke/signalingMessage.js","webpack:///./respoke/group.js","webpack:///./respoke/signalingChannel.js","webpack:///./respoke/directConnection.js","webpack:///./respoke/peerConnection.js","webpack:///./respoke/callState.js","webpack:///./respoke/call.js","webpack:///./respoke/localMedia.js","webpack:///./respoke/remoteMedia.js","webpack:///./respoke/deps/adapter.js","webpack:///./~/loglevel/lib/loglevel.js","webpack:///./~/q/q.js","webpack:///./~/socket.io-client/dist/socket.io.js","webpack:///./~/statechart/lib/statechart.js","webpack:///(webpack)/buildin/module.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","log","setLevel","Q","longStackSupport","stackJumpLimit","longStackJumpLimit","stopUnhandledRejectionTracking","respoke","buildNumber","streams","instances","version","EventEmitter","Client","Presentable","Connection","Endpoint","TextMessage","SignalingMessage","Group","SignalingChannel","DirectConnection","PeerConnection","CallState","Call","LocalMedia","RemoteMedia","window","skipBugsnag","airbrake","document","createElement","first","getElementsByTagName","parentNode","insertBefore","src","setAttribute","onload","onerror","message","file","line","match","Airbrake","push","error","fileName","lineNumber","connect","params","client","getClient","undefined","debug","Error","stack","createClient","instanceId","once","func","called","apply","arguments","makeGUID","r","chars","split","uuid","Array","rnd","i","Math","random","join","handlePromise","promise","onSuccess","onError","returnUndef","done","Class","that","className","Object","keys","forEach","name","hasUserMedia","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","Function","hasRTCPeerConnection","RTCPeerConnection","webkitRTCPeerConnection","mozRTCPeerConnection","hasWebsocket","WebSocket","webkitWebSocket","MozWebSocket","clone","source","JSON","parse","stringify","isEqual","a","b","aKeys","hasOwnProperty","splice","length","sdpHasAudio","sdp","indexOf","sdpHasVideo","sdpHasDataChannel","constraintsHasAudio","constraints","audio","constraintsHasVideo","video","listenerBuilder","listener","evt","eventType","e","eventList","isInternal","string","toString","listen","invalidEventType","invalidListener","fn","isNotAlreadyAdded","map","warn","ignore","fire","count","toRemove","target","setTimeout","hasListeners","every","saveParameters","key","clientSettings","developmentMode","enableCallDebugReport","reconnect","actuallyConnect","deferred","defer","token","appId","endpointId","signalingChannel","open","then","authenticate","presence","setPresence","onCall","onDirectConnection","onJoin","onLeave","onMessage","onConnect","onDisconnect","calls","hangup","signal","onReconnect","info","resolve","err","reject","addCall","removeCall","checkEndpointForRemoval","all","groups","group","getMembers","connectionsByGroup","absent","connectionList","conn","endpoints","ept","index","connectTries","superClass","location","hostname","port","baseURL","resolveEndpointPresence","retVal","disconnect","verifyConnected","leaveGroups","leave","fin","close","sendPresence","getCall","methods","did","web","sip","fromType","one","remoteEndpoint","create","number","uri","caller","toType","setOnline","setOffline","sendMessage","endpoint","getEndpoint","skipPresence","startCall","startAudioCall","optional","mandatory","startVideoCall","startPhoneCall","recipient","signalOffer","signalParams","signalType","sendSDP","signalAnswer","signalConnected","connectionId","sendConnected","signalModify","sendModify","signalCandidate","sendCandidate","signalHangup","sendHangup","signalReport","report","sendReport","startSIPCall","isConnected","joinGroup","groupList","getGroup","addGroup","addMember","connection","getConnection","newGroup","removeMember","endpt","getGroups","grp","skipCreate","registerPresence","endpointList","onPresence","endpointsToSearch","connections","getEndpoints","resolvePresence","getPresence","startDirectConnection","directConnection","sessionId","needDirectConnection","offerOptions","OfferToReceiveAudio","presenceList","idList","options","sort","indexA","indexB","rawMessage","header","from","fromConnection","timestamp","body","channel","to","toConnection","requestConnectionReply","fromEndpoint","required","attr","allowed","validateConnection","validateMembership","isJoined","leaveGroup","skipEvent","publish","getGroupMembers","list","now","performance","io","bind","Date","getTime","PendingRequests","contents","counter","add","obj","remove","reset","isConnecting","socket","connecting","doOpen","path","httpMethod","parameters","tokenId","response","code","appToken","result","firstUpper","str","toUpperCase","slice","type","reconnectTimeout","maxReconnectTimeout","wsCall","handleResponse","statusCode","request","tries","isPending","start","sendWebsocketRequest","durationMillis","pendingRequests","failWebsocketRequest","status","errors","logRequest","method","bodyLength","paramaters","encodeURI","bodySizeLimit","toLowerCase","objectId","replace","emit","url","data","headers","App-Token","paramString","makeParamString","xhr","setRequestHeader","send","onreadystatechange","limit","unit","readyState","getResponseHeader","strings","value","presenceRegistered","XMLHttpRequest","routingMethods","handlerQueue",400,401,403,404,409,429,500,"connected","isSendingReport","fcall","getToken","newToken","callParams","ttl","removeAllListeners","show","toRun","saveDeferred","ep","sendACK","sendSignal","signalId","ackedSignalType","webrtcDetectedType","candidate","iceCandidates","jsapiObject","ic","debugData","action","routeSignal","doOffer","doConnected","doModify","doAnswer","doIceCandidates","doBye","doUnknown","addHandler","on","handler","onPubSub","groupMessage","generateConnectHandler","category","res","pieces","protocol","host","connectParams","connect timeout","force new connection","sync disconnect on unload","secure","query","knownSignals","pendingRequest","getTurnCredentials","creds","uris","cred","createIceServer","username","password","listenDataChannel","dataChannel","onDataChannelError","onmessage","onDataChannelMessage","onopen","onDataChannelOpen","onOpen","onClose","onStart","pc","stats","createDataChannel","binaryType","getStats","onStats","MediaStats","accept","state","answer","skipRemove","removeDirectConnection","isActive","object","signalCandidateOrig","candidatesSent","initOffer","createOffer","saveOfferAndSend","MediaStatsParser","peerConnection","interval","stopStats","onIceCandidate","oCan","forceTurn","disableTurn","sentSDP","processedRemoteSDP","candidateSendingQueue","onNegotiationNeeded","processQueues","candidateReceivingQueue","addRemoteCandidate","processingQueue","oSession","sdpsSent","outgoingMedia","setSDP","incomingMedia","setLocalDescription","sessionDescription","saveAnswerAndSend","callerconnection","listenOffer","listenAnswer","sdpsReceived","lastSDPString","hasAudio","hasVideo","hasDataChannel","calleeconnection","setRemoteDescription","RTCSessionDescription","dispatch","newErr","callStoppedReason","listenConnected","listenModify","defModify","isState","toSendHangup","previewLocalMedia","pcOptions","DtlsSrtpKeyAgreement","RtpDataChannels","callStarted","callStopped","callerendpoint","calleeendpoint","candidatesReceived","userAgent","os","platform","processOffer","oOffer","createAnswer","init","servers","onicecandidate","onnegotiationneeded","onaddstream","stream","onremovestream","ondatachannel","getRemoteStreams","prototype","getLocalStreams","addStream","sentSignal","iceConnectionState","startModify","addIceCandidate","RTCIceCandidate","Statechart","assert","condition","rejectModify","modifyTimer","clear","clearReceiveAnswerTimer","receiveAnswerTimer","needToObtainMedia","receiveOnly","needToApproveDirectConnection","automaticDirectConnectionCaller","createTimer","time","timer","clearTimeout","allTimers","fsm","answerTimer","connectionTimer","oldRole","answerTimeout","receiveAnswerTimeout","connectionTimeout","modifyTimeout","nontransitionEvents","hasLocalMediaApproval","hasLocalMedia","receivedBye","isAnswered","receivedSDP","sendOnly","rejectEvent","guard","hasMedia","hangupReason","reason","hangupEvent","signalBye","stateParams","initialState","receiveLocalMedia","states","idle","exit","initiate","negotiatingContainer","modify","preparing","entry","isModifying","receiveOffer","approve","gettingMedia","approvingDeviceAccess","approvingContent","offeringContainer","sentOffer","offering","receiveRemoteMedia","receiveAnswer","connectingContainer","modifyingContainer","modifying","connectedContainer","receive","terminatedContainer","terminated","run","debugOff","args","getState","currentState","oldState","newState","modifyingStates","defMedia","actuallyAddDirectConnection","onLocalMedia","onHangup","onAllow","onAnswer","onApprove","onMute","onRequestingMedia","element","videoLocalElement","setConstraints","videoRemoteElement","onRemoteStreamRemoved","onRemoteStreamAdded","setStream","doAddVideo","skipModify","onModifyAccept","dc","onModifyReject","listenHangup","callId","muted","videoIsMuted","audioIsMuted","getLocalElement","getRemoteElement","addVideo","isFulfilled","addAudio","getDirectConnection","addDirectConnection","closeDirectConnection","doHangup","stop","toggleVideo","unmuteVideo","muteVideo","toggleAudio","unmuteAudio","muteAudio","local","remote","iceServers","getStream","theConstraints","s","removeStream","toRemoveIndex","checkAndCreateElement","autoplay","console","appendChild","onReceiveUserMedia","theStream","allowTimer","getAudioTracks","getVideoTracks","aStream","numPc","documentOwner","ownerDocument","attachMediaStream","requestMedia","useFakeMedia","fake","onUserMediaError","isVideoMuted","track","enabled","isAudioMuted","play","AdapterJS","VERSION","WebRTCPlugin","pluginInfo","prefix","plugName","pluginId","portalLink","downloadLink","companyName","pageId","plugin","setLogLevel","defineWebRTCInterface","isPluginInstalled","pluginInjectionInterval","injectPlugin","PLUGIN_STATES","NONE","INITIALIZING","INJECTING","INJECTED","READY","pluginState","PLUGIN_LOG_LEVELS","ERROR","WARNING","INFO","VERBOSE","SENSITIVE","WaitForPluginReady","callWhenPluginReady","pluginNeededButNotInstalledCb","__TemWebRTCReady0","documentReadyInterval","setInterval","clearInterval","_iceConnectionStates","starting","checking","completed","disconnected","failed","closed","_iceConnectionFiredStates","isDefined","parseWebrtcDetectedBrowser","hasMatch","checkMatch","test","exec","webrtcDetectedBrowser","webrtcDetectedVersion","parseInt","InstallTrigger","documentMode","HTMLElement","opera","chrome","appName","appVersion","maybeFixConfiguration","pcConfig","urls","addEvent","elem","evnt","addEventListener","attachEvent","webrtcDetectedDCSupport","checkMediaDataChannelSettings","peerBrowserAgent","peerBrowserVersion","callback","beOfferer","isLocalFirefox","isLocalFirefoxInterop","isPeerFirefox","MozDontOfferDataChannel","prop","checkIceConnectionState","peerId","createIceServers","reattachMediaStream","pcConstraints","mozRTCSessionDescription","mozRTCIceCandidate","MediaStreamTrack","getSources","successCb","infos","kind","label","facing","iceServer","url_parts","turn_url_parts","credential","mozSrcObject","TypeError","MediaStream","checkIfOpera","srcObject","URL","createObjectURL","dir","exception","trace","timeEnd","groupCollapsed","groupEnd","isIE","checkPluginReadyState","logLevel","frag","createDocumentFragment","innerHTML","getAllCams","firstChild","getElementById","width","height","comName","installedCb","notInstalledCb","ActiveXObject","pluginArray","plugins","variable","hasCredentials","ConstructSessionDescription","GetSources","successCallback","failureCallback","enableSoundTracks","nodeName","elementId","isWebRTCPlugin","children","setStreamId","temp","classHTML","rectObject","getBoundingClientRect","removeChild","newElement","onplaying","onclick","_TemOnClick","arg","srcElement","getStreamWithId","sdpMid","ConstructIceCandidate","sdpMLineIndex","pluginNeededButNotInstalledCbPriv","hidePluginInstallPrompt","popupString","renderNotificationBar","text","buttonText","buttonLink","w","style","position","top","left","right","backgroundColor","border","borderBottom","zIndex","webkitTransition","transition","contentWindow","contentDocument","write","preventDefault","event","cancelBubble","webkitTransform","transform","undefinedType","definition","realMethod","methodName","noop","boundToConsole","clearMethods","ii","logMethods","self","cookiesAvailable","cookie","setLevelInCookie","levelNum","levelName","levels","loadLevelFromCookie","cookieLevel","cookieMatch","cookieRegex","WARN","TRACE","DEBUG","SILENT","level","enableAll","disableAll","bootstrap","uncurryThis","f","isObject","isStopIteration","object_toString","QReturnValue","makeStackTraceLong","hasStacks","STACK_JUMP_SEPARATOR","stacks","unshift","concatedStacks","filterStackString","stackString","lines","desiredLines","isInternalFrame","isNodeFrame","stackLine","getFileNameAndLineNumber","attempt1","Number","attempt2","attempt3","fileNameAndLineNumber","qFileName","qStartingLine","qEndingLine","captureLine","firstLine","deprecate","alternative","Promise","isPromiseAlike","coerce","fulfill","become","newPromise","resolvedPromise","array_reduce","messages","nextTick","promiseDispatch","progressListeners","object_create","op","operands","array_slice","valueOf","nearerValue","nearer","isPromise","inspect","substring","notify","progress","progressListener","resolver","race","answerPs","len","descriptor","fallback","inspected","when","fulfilled","rejected","progressed","isRejected","resetUnhandledRejections","unhandledReasons","unhandledRejections","trackUnhandledRejections","trackRejection","untrackRejection","at","array_indexOf","rejection","get","set","rhs","delete","post","thisp","object_keys","master","isDef","spread","async","makeGenerator","continuer","verb","StopIteration","generator","errback","spawn","_return","promised","promises","countDown","snapshot","allResolved","array_map","allSettled","nodeify","nodeback","flush","head","next","task","domain","enter","isNodeJS","flushing","tail","requestTick","process","setImmediate","MessageChannel","port1","requestPortTick","port2","postMessage","reduce","basis","collect","Type","object_hasOwnProperty","ReturnValue","env","Q_DEBUG","makeNodeResolver","passByCopy","x","y","makePromise","_fulfilled","_rejected","newException","_progressed","newValue","threw","tap","thenResolve","thenReject","getUnhandledReasons","array","del","mapply","mcall","invoke","fapply","fbind","concat","regardless","fail","onUnhandledError","timeout","ms","timeoutId","delay","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","transports","j","sockets","details","uuri","util","parseUri","uniqueUri","merge","Socket","of","re","parts","base","addition","chunkQuery","components","part","qs","kv","l","pageLoaded","load","capture","xdomain","XDomainRequest","ua","hasCORS","webkit","importScripts","additional","deep","lastseen","seen","depth","mixin","ctor","ctor2","inherit","isArray","intersect","arr","arr2","ret","longest","shortest","o","toArray","enu","withCredentials","iDevice","$events","addListener","removeListener","pos","listeners","parent","nativeJSON","n","date","d","isFinite","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","quote","escapable","lastIndex","meta","charCodeAt","holder","k","v","partial","mind","gap","rep","String","indent","cx","\b","\t","\n","\f","\r","\"","\\","replacer","space","reviver","walk","eval","SyntaxError","parser","packets","reasons","advice","encodePacket","packet","ack","adv","ev","ackId","encoded","encodePayload","decoded","regexp","decodePacket","opts","decodePayload","charAt","substr","Transport","sessid","heartbeats","onData","clearCloseTimeout","reconnecting","setCloseTimeout","msgs","onPacket","setHeartbeatTimeout","onHeartbeat","isOpen","closeTimeout","clearTimeouts","reopenTimeout","prepareUrl","scheme","resource","ready","try multiple transports","reconnection delay","reconnection limit","Infinity","reopen delay","max reconnection attempts","auto connect","flash policy port","manualFlush","namespaces","buffer","doBuffer","isXDomain","disconnectSync","empty","SocketNamespace","nsp","$emit","handshake","complete","insertAt","script","responseText","getTransport","override","transport","check","xdomainCheck","sessionid","sid","heartbeat","connectTimeoutTimer","remaining","heartbeatTimeout","origTransports","heartbeatTimeoutTimer","setBuffer","flushBuffer","payload","wasConnected","wasConnecting","reconnectionAttempts","reconnectionTimer","maybeReconnect","reconnectionDelay","redoTransports","tryMultiple","maxAttempts","flags","json","Flag","ackPackets","acks","namespace","lastArg","WS","websocket","onclose","Flashsocket","flashsocket","__addTask","__tasks","WEB_SOCKET_SWF_LOCATION","loadFlashPolicyFile","__initialize","swfobject","getFlashPlayerVersion","major","WEB_SOCKET_DISABLE_AUTO_INITIALIZATION","J","Z","C","aa","X","U","Y","K","O","D","h","T","V","H","q","GetVariable","ab","M","pv","callee","ag","af","callbackFn","success","ae","F","swfVersion","wk","expressInstall","A","ai","getAttribute","styleclass","align","ah","ac","ad","P","ref","z","SetVariable","win","mac","E","B","g","R","title","ie","flashvars","display","u","replaceChild","childNodes","nodeType","cloneNode","movie","outerHTML","N","I","G","styleSheets","addRule","createTextNode","visibility","L","encodeURIComponent","S","W","t","parseFloat","description","mimeTypes","enabledPlugin","w3","detachEvent","documentElement","doScroll","registerObject","getObjectById","embedSWF","aj","al","am","ak","an","switchOffAutoHideShow","minor","release","hasFlashPlayerVersion","createSWF","showExpressInstall","removeSWF","createCSS","addDomLoadEvent","addLoadEvent","getQueryParamValue","search","hash","expressInstallCallback","protocols","proxyHost","proxyPort","__id","__nextId","__instances","CONNECTING","bufferedAmount","__events","__flash","CLOSED","CLOSING","removeEventListener","events","dispatchEvent","__handleEvent","flashEvent","jsEvent","__createSimpleEvent","decodeURIComponent","__createMessageEvent","createEvent","Event","initEvent","bubbles","cancelable","MessageEvent","initMessageEvent","OPEN","loadManualPolicyFile","__swfLocation","container","__isFlashLite","hasPriority","swliveconnect","allowScriptAccess","__onFlashInitialized","setCallerUrl","href","setDebug","WEB_SOCKET_DEBUG","__onFlashEvent","receiveEvents","webSocketId","__log","__error","mimeType","filename","XHR","sendBuffer","stateChange","posting","sendXHR","req","contentType","usesXDomReq","socketProtocol","isXProtocol","HTMLFile","htmlfile","doc","parentWindow","iframeC","iframe","destroy","_","CollectGarbage","XHRPolling","retryCounter","abort","JSONPPolling","msg","indicator","initIframe","form","iframeId","area","submit","QState","QEvent","assertion","opt","construct","myState","mySource","Initial","newInitialState","handled","TOP","flatten","anEventOrNull","trigger","equals","superstate","stateOrName","_topState","statesTable","_flatten","selectState","stateName","anEvent","act","handleUnhandledEvent","aStateName","aStateOrName","enterVia","pop","lca","entryLength","idx","QEventEmpty","QEventEntry","QEventExit","QEventInit","webpackPolyfill","paths"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"respoke\"] = factory();\n\telse\n\t\troot[\"respoke\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"respoke\"] = factory();\n\telse\n\t\troot[\"respoke\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/*global Bugsnag: true*/\n\t/*jshint bitwise: false*/\n\t\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tlog.setLevel('warn');\n\t\n\tvar Q = __webpack_require__(19);\n\tQ.longStackSupport = true;\n\tQ.stackJumpLimit = 5;\n\tQ.longStackJumpLimit = 20;\n\tQ.stopUnhandledRejectionTracking();\n\t\n\t__webpack_require__(17);\n\t\n\t/**\n\t * `respoke` is a global static class.\n\t *\n\t *\n\t * Include the [latest version](https://cdn.respoke.io/respoke.min.js) or\n\t * [choose a previous release](http://cdn.respoke.io/list.html).\n\t *\n\t * Or use `npm install --save respoke`.\n\t *\n\t * Interact with Respoke primarily via [`respoke.Client`](respoke.Client.html):\n\t *\n\t *      var client = respoke.createClient();\n\t *\n\t *\n\t * **Development mode without brokered auth**\n\t *\n\t *      var client = respoke.createClient({\n\t *          appId: \"XXXXXXX-my-app-id-XXXXXX\",\n\t *          developmentMode: true,\n\t *          endpointId: \"billy\"\n\t *      });\n\t *\n\t *      client.listen('connect', function () {\n\t *          console.log('connected to respoke!');\n\t *      });\n\t *\n\t *      client.listen('error', function (err) {\n\t *          console.error('Connection to Respoke failed.', err);\n\t *      });\n\t *\n\t *      client.connect();\n\t *\n\t *\n\t * **Production mode with brokered auth**\n\t *\n\t *      var client = respoke.createClient();\n\t *\n\t *      client.listen('connect', function () {\n\t *          console.log('connected to respoke!');\n\t *      });\n\t *\n\t *      client.listen('error', function (err) {\n\t *          console.error('Connection to Respoke failed.', err);\n\t *      });\n\t *\n\t *      // Respoke auth token obtained by your server.\n\t *      // This is how you control who can connect to Respoke app.\n\t *      // See API docs for POST [base]/tokens\n\t *      var tokenId = \"XXXX-XXXX-brokered-auth-token-XXXXX\";\n\t *\n\t *      // connect to respoke with the token\n\t *      client.connect({\n\t *          token: tokenId\n\t *      });\n\t *\n\t *      // fetch a new token from your server if it expires\n\t *      client.listen('disconnect', function (evt) {\n\t *          // fetch another token from your server.\n\t *          var newTokenId = \"XXXX-XXXX-brokered-auth-token2-XXXXX\";\n\t *          client.connect({\n\t *              token: newTokenId\n\t *          });\n\t *      });\n\t *\n\t *\n\t *\n\t * ### Event listeners vs callback handlers\n\t *\n\t * There are two ways to attach listeners. It is highly recommended that you choose one pattern\n\t * and stick to it throughout your app.\n\t *\n\t * For every `event-name`, there is a corresponding callback `onEventName`.\n\t *\n\t * **With a listener**\n\t *\n\t *      var client = respoke.createClient();\n\t *      client.listen('connect', function () { });\n\t *\n\t * **or with a callback**\n\t *\n\t *      var client = respoke.createClient({\n\t *          // other options go here\n\t *\n\t *          onConnect: function () { }\n\t *      });\n\t *\n\t *\n\t * @namespace respoke\n\t * @class respoke\n\t * @global\n\t * @link https://cdn.respoke.io/respoke.min.js\n\t */\n\tvar respoke = module.exports = {\n\t    buildNumber: 'NO BUILD NUMBER',\n\t    streams: [],\n\t    instances: {}\n\t};\n\t\n\t/**\n\t * `\"v0.0.0\"`\n\t *\n\t * The respoke.min.js version.\n\t *\n\t * Past versions can be found at [cdn.respoke.io/list.html](http://cdn.respoke.io/list.html)\n\t * @type {string}\n\t */\n\trespoke.version = respoke.buildNumber + \"\";\n\t\n\trespoke.EventEmitter = __webpack_require__(2);\n\trespoke.Client = __webpack_require__(3);\n\trespoke.Presentable = __webpack_require__(4);\n\trespoke.Connection = __webpack_require__(5);\n\trespoke.Endpoint = __webpack_require__(6);\n\trespoke.TextMessage = __webpack_require__(7);\n\trespoke.SignalingMessage = __webpack_require__(8);\n\trespoke.Group = __webpack_require__(9);\n\trespoke.SignalingChannel = __webpack_require__(10);\n\trespoke.DirectConnection = __webpack_require__(11);\n\trespoke.PeerConnection = __webpack_require__(12);\n\trespoke.CallState = __webpack_require__(13);\n\trespoke.Call = __webpack_require__(14);\n\trespoke.LocalMedia = __webpack_require__(15);\n\trespoke.RemoteMedia = __webpack_require__(16);\n\trespoke.log = log;\n\trespoke.Q = Q;\n\t\n\tif (!window.skipBugsnag) {\n\t    // Use airbrake.\n\t    var airbrake = document.createElement('script');\n\t    var first = document.getElementsByTagName('script')[0];\n\t    first.parentNode.insertBefore(airbrake, first);\n\t\n\t    airbrake.src = \"https://ssljscdn.airbrake.io/0.3/airbrake.min.js\";\n\t    airbrake.setAttribute('data-airbrake-project-id', '98133');\n\t    airbrake.setAttribute('data-airbrake-project-key', 'cd3e085acc5e554658ebcdabd112a6f4');\n\t    airbrake.setAttribute('data-airbrake-project-environment-name', 'production');\n\t\n\t    airbrake.onload = function () {\n\t        window.onerror = function (message, file, line) {\n\t            //Only send errors from the respoke.js file to Airbrake\n\t            if (file.match(/respoke/)) {\n\t                Airbrake.push({error: {message: message, fileName: file, lineNumber: line}});\n\t            }\n\t        };\n\t    };\n\t}\n\t\n\t/**\n\t * This is one of two possible entry points for interating with the library.\n\t *\n\t * This method creates a new Client object\n\t * which represents your user's connection to your Respoke app.\n\t *\n\t * This method **automatically calls client.connect(params)** after the client is created.\n\t *\n\t * @static\n\t * @memberof respoke\n\t * @param {object} params Parameters to the respoke.Client constructor.\n\t * @param {string} [params.appId]\n\t * @param {string} [params.baseURL]\n\t * @param {string} [params.token]\n\t * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n\t * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t * operation and will limit the services you will be able to use.\n\t * @param {boolean} [params.reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n\t * when a disconnect occurs.\n\t * @param {function} [params.onSuccess] - Success handler for this invocation of this method only.\n\t * @param {function} [params.onError] - Error handler for this invocation of this method only.\n\t * @param {function} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t * @param {function} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n\t * @param {function} [params.onMessage] - Callback for when any message is received from anywhere on the system.\n\t * @param {function} [params.onDisconnect] - Callback for Client disconnect.\n\t * @param {function} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n\t * @param {function} [params.onCall] - Callback for when this client's user receives a call.\n\t * @param {function} [params.onDirectConnection] - Callback for when this client's user receives a request for a\n\t * direct connection.\n\t * @param {boolean} [params.enableCallDebugReport=true] - Optional flag defaulting to true which allows sending\n\t * debugging information.\n\t * @returns {respoke.Client}\n\t */\n\trespoke.connect = function (params) {\n\t    var client = respoke.Client(params);\n\t    client.connect(params);\n\t    return client;\n\t};\n\t\n\t/**\n\t * Getter for the respoke client.\n\t *\n\t * You can have more than one active client, so this method provides a way to retrieve a specific instance.\n\t *\n\t * @static\n\t * @memberof respoke\n\t * @param {number} id The Client ID.\n\t * @returns {respoke.Client}\n\t */\n\trespoke.getClient = function (id) {\n\t    if (id === undefined) {\n\t        log.debug(\"Can't call getClient with no client ID.\", new Error().stack);\n\t    }\n\t    if (!respoke.instances[id]) {\n\t        log.debug(\"No client instance with id\", id);\n\t    }\n\t    return respoke.instances[id];\n\t};\n\t\n\t/**\n\t * This is one of two possible entry points for interating with the library.\n\t *\n\t * This method creates a new Client object which represents your user's connection to your Respoke app.\n\t *\n\t * It **does NOT automatically call the client.connect() method** after the client is created.\n\t *\n\t * The `params` argument is the same as `respoke.connect(params)`.\n\t *\n\t * @static\n\t * @memberof respoke\n\t * @param {object} params Parameters to respoke.Client - same as respoke.connect()\n\t * @returns {respoke.Client}\n\t */\n\trespoke.createClient = function (params) {\n\t    var client;\n\t    params = params || {};\n\t    if (params.instanceId) {\n\t        client = respoke.getClient(params.instanceId);\n\t        if (client) {\n\t            return client;\n\t        }\n\t    }\n\t    return respoke.Client(params);\n\t};\n\t\n\t/**\n\t * Build a closure from a listener that will ensure the listener can only be called once.\n\t * @static\n\t * @private\n\t * @memberof respoke\n\t * @param {function} func\n\t * @return {function}\n\t */\n\trespoke.once = function (func) {\n\t    return (function () {\n\t        var called = false;\n\t        return function () {\n\t            if (called === false) {\n\t                func.apply(null, arguments);\n\t                called = true;\n\t            }\n\t        };\n\t    })();\n\t};\n\t\n\t/**\n\t * @static\n\t * @private\n\t * @memberof respoke\n\t * @returns {number}\n\t */\n\trespoke.makeGUID = function () {\n\t    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\t    var uuid = new Array(36);\n\t    var rnd = 0;\n\t    var r;\n\t    for (var i = 0; i < 36; i += 1) {\n\t        if (i === 8 || i === 13 ||  i === 18 || i === 23) {\n\t            uuid[i] = '-';\n\t        } else if (i === 14) {\n\t            uuid[i] = '4';\n\t        } else {\n\t            if (rnd <= 0x02) {\n\t                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\n\t            }\n\t            r = rnd & 0xf;\n\t            rnd = rnd >> 4;\n\t            uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n\t        }\n\t    }\n\t    return uuid.join('');\n\t};\n\t\n\t/**\n\t * This method is used internally to attach handlers to promises that are returned by many methods in the library.\n\t * It's not recommended that this method be used by developers and apps.\n\t * @private\n\t * @static\n\t * @memberof respoke\n\t * @param {Promise} promise\n\t * @param {function} onSuccess\n\t * @param {function} onError\n\t * @returns {Promise|undefined}\n\t */\n\trespoke.handlePromise = function (promise, onSuccess, onError) {\n\t    var returnUndef = false;\n\t    if (onSuccess || onError) {\n\t        returnUndef = true;\n\t    }\n\t\n\t    onSuccess = typeof onSuccess === 'function' ? onSuccess : function () {};\n\t    onError = typeof onError === 'function' ? onError : function () {};\n\t    promise.done(onSuccess, onError);\n\t    return (returnUndef ? undefined : promise);\n\t};\n\t\n\t/**\n\t * Empty base class. Use params.that (if exists) for the base object, but delete it from the instance.  Copy all\n\t * params that were passed in onto the base object. Add the class name.\n\t * @class respoke.Class\n\t * @classdesc Empty base class.\n\t * @constructor\n\t * @private\n\t */\n\trespoke.Class = function (params) {\n\t    params = params || {};\n\t    var that = params.that || {};\n\t    var client = params.client;\n\t\n\t    that.className = 'respoke.Class';\n\t    delete params.that;\n\t    delete that.client;\n\t\n\t    Object.keys(params).forEach(function copyParam(name) {\n\t        that[name] = params[name];\n\t    });\n\t\n\t    return that;\n\t}; // end of respoke.Class\n\t\n\t/**\n\t * Does the browser support `UserMedia`?\n\t * @static\n\t * @memberof respoke\n\t * @returns {boolean}\n\t */\n\trespoke.hasUserMedia = function () {\n\t    return (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) instanceof Function;\n\t};\n\t\n\t/**\n\t * Does the browser support `RTCPeerConnection`?\n\t * @static\n\t * @memberof respoke\n\t * @returns {boolean}\n\t */\n\trespoke.hasRTCPeerConnection = function () {\n\t    return (window.RTCPeerConnection || window.webkitRTCPeerConnection ||\n\t            window.mozRTCPeerConnection) instanceof Function;\n\t};\n\t\n\t/**\n\t * Does the browser support `WebSocket`?\n\t * @static\n\t * @memberof respoke\n\t * @returns {boolean}\n\t */\n\trespoke.hasWebsocket = function () {\n\t    return (window.WebSocket || window.webkitWebSocket || window.MozWebSocket) instanceof Function;\n\t};\n\t\n\t/**\n\t * Clone an object.\n\t * @static\n\t * @memberof respoke\n\t * @param {Object} source - The object to clone\n\t * @returns {Object}\n\t */\n\trespoke.clone = function (source) {\n\t    if (source) {\n\t        return JSON.parse(JSON.stringify(source));\n\t    }\n\t    return source;\n\t};\n\t\n\t/**\n\t * Compares two objects for equality\n\t * @static\n\t * @memberof respoke\n\t * @param {Object} a\n\t * @param {Object} b\n\t * @returns {boolean}\n\t */\n\trespoke.isEqual = function (a, b) {\n\t    var aKeys;\n\t\n\t    //check if arrays\n\t    if (a.hasOwnProperty('length') && b.hasOwnProperty('length') && a.splice && b.splice) {\n\t        if (a.length !== b.length) {\n\t            //short circuit if arrays are different length\n\t            return false;\n\t        }\n\t\n\t        for (var i = 0; i < a.length; i += 1) {\n\t            if (!respoke.isEqual(a[i], b[i])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    if (typeof a === 'object' && typeof b === 'object') {\n\t        aKeys = Object.keys(a);\n\t        for (var i = 0; i < aKeys.length; i += 1) {\n\t            if (!respoke.isEqual(a[aKeys[i]], b[aKeys[i]])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    return a === b;\n\t};\n\t\n\t/*\n\t * Does the sdp indicate an audio stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {RTCSessionDescription}\n\t * @returns {boolean}\n\t */\n\trespoke.sdpHasAudio = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasAudio called with no parameters.\");\n\t    }\n\t    return sdp.indexOf('m=audio') !== -1;\n\t};\n\t\n\t/**\n\t * Does the sdp indicate a video stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {RTCSessionDescription}\n\t * @returns {boolean}\n\t */\n\trespoke.sdpHasVideo = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasVideo called with no parameters.\");\n\t    }\n\t    return sdp.indexOf('m=video') !== -1;\n\t};\n\t\n\t/**\n\t * Does the sdp indicate a data channel?\n\t * @static\n\t * @memberof respoke\n\t * @params {RTCSessionDescription}\n\t * @returns {boolean}\n\t */\n\trespoke.sdpHasDataChannel = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasDataChannel called with no parameters.\");\n\t    }\n\t    return sdp.indexOf('m=application') !== -1;\n\t};\n\t\n\t/**\n\t * Does the sdp indicate an audio stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {MediaConstraints}\n\t * @returns {boolean}\n\t */\n\trespoke.constraintsHasAudio = function (constraints) {\n\t    if (!constraints) {\n\t        throw new Error(\"respoke.constraintsHasAudio called with no parameters.\");\n\t    }\n\t    return (constraints.audio === true);\n\t};\n\t\n\t/**\n\t * Does the constraints indicate a video stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {MediaConstraints}\n\t * @returns {boolean}\n\t */\n\trespoke.constraintsHasVideo = function (constraints) {\n\t    if (!constraints) {\n\t        throw new Error(\"respoke.constraintsHasVideo called with no parameters.\");\n\t    }\n\t    return (constraints.video === true || typeof constraints.video === 'object');\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar respoke = __webpack_require__(1);\n\tvar log = __webpack_require__(18);\n\t\n\t/**\n\t * A generic class for emitting and listening to events.\n\t *\n\t * @class respoke.EventEmitter\n\t * @inherits respoke.Class\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} params.instanceId\n\t * @returns {respoke.EventEmitter}\n\t */\n\tvar EventEmitter = module.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = respoke.Class(params);\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.EventEmitter\n\t     * @name className\n\t     * @type {string}\n\t     * @private\n\t     */\n\t    that.className = 'respoke.EventEmitter';\n\t\n\t    /**\n\t     * @memberof! respoke.EventEmitter\n\t     * @name eventList\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var eventList = {};\n\t\n\t    /**\n\t     * Add a listener that will only be called once to an object.  This method adds the given listener to the given\n\t     * event in the case that the same\n\t     * listener is not already registered to this event and the listener is a function.  The third argument 'isInternal'\n\t     * is used only internally by the library to indicate that this listener is a library-used listener and should not\n\t     * count when we are trying to determine if an event has listeners placed by the developer.\n\t     *\n\t     *     client.once('connect', function (evt) {\n\t     *         console.log(\"This is the first time we connected.\");\n\t     *     });\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.listen\n\t     * @param {string} eventType - A developer-specified string identifying the event.\n\t     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is fire.\n\t     * @param {boolean} [isInternal] - A flag to indicate this listener was added by the library. This parameter should\n\t     * not be used by developers who are using the library, only by developers who are working on the library itself.\n\t     */\n\t    that.once = function (eventType, listener, isInternal) {\n\t        var string = listener.toString();\n\t        listener = respoke.once(listener);\n\t        listener.toString = function () { return string; }\n\t        listener.once = true;\n\t        that.listen(eventType, listener, isInternal);\n\t    };\n\t\n\t    /**\n\t     * Add a `listener` function to an object.\n\t     * \n\t     * This method adds the `listener` to the event `eventName`.\n\t     * \n\t     * If an identical listener already registered to this event, it will **not** be added.\n\t     * \n\t     * ##### Example of adding an event listener.\n\t     *\n\t     *     client.listen('connect', function (evt) {\n\t     *         console.log(\"We've connected!\", evt);\n\t     *     });\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.listen\n\t     * @param {string} eventType - The name of the event.\n\t     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is\n\t     * fired.\n\t     * @arg {boolean} isInternal - Internal use only. A flag to indicate this listener was \n\t     * added by the library. This parameter should not be used by developers who are using\n\t     * the library, only by developers who are working on the library itself.\n\t     */\n\t    that.listen = function (eventType, listener, isInternal) {\n\t        if (listener === undefined) {\n\t            return;\n\t        }\n\t        var invalidEventType = typeof eventType !== 'string' || !eventType;\n\t        var invalidListener = typeof listener !== 'function';\n\t        if (invalidEventType || invalidListener) {\n\t            log.error(\"Invalid request to add event listener to\", eventType, listener);\n\t            return;\n\t        }\n\t\n\t        eventList[eventType] = eventList[eventType] || [];\n\t        listener.isInternal = !!isInternal; // boolify\n\t\n\t        var toString = function (fn) {\n\t            return fn.toString();\n\t        };\n\t        var isNotAlreadyAdded = eventList[eventType].map(toString).indexOf(listener.toString()) === -1;\n\t\n\t        if (isNotAlreadyAdded) {\n\t            eventList[eventType].push(listener);\n\t        } else {\n\t            log.warn(\"Not adding duplicate listener to\", eventType, listener);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Remove a listener from an object. If no eventType is specified, all eventTypes will be\n\t     * cleared. If an eventType is specified but no listener is specified, all listeners will be\n\t     * removed from the specified eventType.  If a listener is also specified, only that listener\n\t     * will be removed.\n\t     *\n\t     *     client.ignore('connect', connectHandler);\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.ignore\n\t     * @param {string} [eventType] - An optional developer-specified string identifying the event.\n\t     * @param {function} [listener] - An optional function to remove from the specified event.\n\t     */\n\t    that.ignore = function (eventType, listener) {\n\t        // Remove all events from this object\n\t        if (eventType === undefined) {\n\t            eventList = {};\n\t            return;\n\t        }\n\t\n\t        // Remove all listeners from this event.\n\t        if (listener === undefined || !eventList[eventType]) {\n\t            eventList[eventType] = [];\n\t            return;\n\t        }\n\t\n\t        // Remove only one listener from this event.\n\t        for (var i = eventList[eventType].length - 1; i >= 0; i -= 1) {\n\t            if (listener === eventList[eventType][i]) {\n\t                eventList[eventType].splice(i, 1);\n\t                return;\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Trigger an event on an object. All listeners for the specified eventType will be called.\n\t     * Listeners will be bound to the object ('this' will refer to the object), and additional\n\t     * arguments to fire() will be passed into each listener.\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.fire\n\t     * @param {string} eventType - A developer-specified string identifying the event to fire.\n\t     * @param {string|number|object|array} evt - Any number of optional parameters to be passed to\n\t     * the listener\n\t     * @private\n\t     */\n\t    that.fire = function (eventType, evt) {\n\t        var args = null;\n\t        var count = 0;\n\t        var toRemove = [];\n\t\n\t        evt = evt || {};\n\t        evt.name = eventType;\n\t        evt.target = that;\n\t\n\t        if (!eventType) {\n\t            return;\n\t        }\n\t\n\t        if (!eventList[eventType]) {\n\t            log.debug(\"fired \" + that.className + \"#\" + eventType + \" 0 listeners called with params\", evt);\n\t            return;\n\t        }\n\t\n\t        for (var i = 0; i < eventList[eventType].length; i += 1) {\n\t            var listener = eventList[eventType][i];\n\t            if (typeof listener === 'function') {\n\t                setTimeout(listenerBuilder(listener, evt, eventType));\n\t\n\t                count += 1;\n\t                if (listener.once === true) {\n\t                    toRemove.push(i);\n\t                }\n\t            }\n\t        }\n\t\n\t        for (var i = (toRemove.length - 1); i >= 0; i -= 1) {\n\t            eventList[eventType].splice(toRemove[i], 1);\n\t        }\n\t\n\t        log.debug(\"fired \" + that.className + \"#\" + eventType + \" \" + count + \" listeners called with params\", evt);\n\t    };\n\t\n\t    function listenerBuilder(listener, evt, eventType) {\n\t        return function () {\n\t            try {\n\t                listener.call(that, evt);\n\t            } catch (e) {\n\t                log.error('Error in ' + that.className + \"#\" + eventType, e.message, e.stack);\n\t            }\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Determine if an object has had any listeners registered for a given event outside the library. This method\n\t     * checks for the isInternal flag on each listener and doesn't count it toward an event being listened to. This\n\t     * method is used in the library to handle situations where an action is needed if an event won't be acted on.\n\t     * For instance, if a call comes in for the logged-in user, but the developer isn't listening to\n\t     * {respoke.Client#call}, we'll need to reject the call immediately.\n\t     *\n\t     *     if (client.hasListeners('call')) {\n\t     *         // already handled!\n\t     *     }\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.hasListeners\n\t     * @param {string} eventType - The name of the event\n\t     * @returns {boolean} Whether this event has any listeners that are external to this library.\n\t     */\n\t    that.hasListeners = function (eventType) {\n\t        if (eventType === undefined) {\n\t            throw new Error(\"Missing required parameter event type.\");\n\t        }\n\t\n\t        if (!eventList[eventType]) {\n\t            return false;\n\t        }\n\t\n\t        return !eventList[eventType].every(function eachListener(listener) {\n\t            return listener.isInternal;\n\t        });\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.EventEmitter\n\t/**\n\t * @callback respoke.EventEmitter.eventListener\n\t * @param {respoke.Event} evt\n\t */\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar Q = __webpack_require__(19);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * `respoke.Client` is the top-level interface to the API. Interacting with Respoke should be done using\n\t * a `respoke.Client` instance.\n\t *\n\t * There are two ways to get a client:\n\t *\n\t *      var client = respoke.createClient(clientParams);\n\t *      // . . . set stuff up, then . . .\n\t *      client.connect(connectParams);\n\t *\n\t * or\n\t *\n\t *      // creates client and connects to Respoke all at once\n\t *      var client = respoke.connect(allParams);\n\t *\n\t * A client does the following things:\n\t *\n\t * 1. authentication with the Respoke API\n\t * 1. receives server-side app-specific information\n\t * 1. tracks connections and presence\n\t * 1. provides methods to get and interact with tracked entities (like groups and endpoints)\n\t * 1. stores default settings for calls and direct connections\n\t * 1. automatically reconnects to the API when network activity is lost*\n\t *\n\t * *If `developmentMode` is set to true. If not using `developmentMode`, disable automatic\n\t * reconnect by sending `reconnect: false` and listening to the Client's disconnect event\n\t * to fetch a new brokered auth token, then call `client.connect()` with the new token.\n\t *\n\t * @class respoke.Client\n\t * @constructor\n\t * @augments respoke.Presentable\n\t * @param {object} params\n\t * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n\t * respoke.connect, respoke.createClient, or to client.connect.\n\t * @param {string} [params.token] - The endpoint's authentication token.\n\t * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t * endpoint. This is only used when `developmentMode` is set to `true`.\n\t * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t * operation and will limit the services you will be able to use.\n\t * @param {string|number|object|Array} [params.presence=unavailable] The initial presence to set once connected.\n\t * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n\t * when a disconnect occurs.\n\t * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n\t * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is received\n\t * from anywhere on the system.\n\t * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n\t * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n\t * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect.\n\t * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client's user receives a call.\n\t * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this client's user\n\t * receives a request for a direct connection.\n\t * @returns {respoke.Client}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId || respoke.makeGUID();\n\t    params.instanceId = instanceId;\n\t    var that = respoke.Presentable(params);\n\t    respoke.instances[instanceId] = that;\n\t    delete that.instanceId;\n\t    that.connectTries = 0;\n\t    /**\n\t     * A name to identify this class\n\t     * @memberof! respoke.Client\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Client';\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name host\n\t     * @type {string}\n\t     * @private\n\t     */\n\t    var host = window.location.hostname;\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name port\n\t     * @type {number}\n\t     * @private\n\t     */\n\t    var port = window.location.port;\n\t    /**\n\t     * A simple POJO to store some methods we will want to override but reference later.\n\t     * @memberof! respoke.Client\n\t     * @name superClass\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var superClass = {\n\t        setPresence: that.setPresence\n\t    };\n\t    /**\n\t     * A container for baseURL, token, and appId so they won't be accidentally viewable in any JavaScript debugger.\n\t     * @memberof! respoke.Client\n\t     * @name clientSettings\n\t     * @type {object}\n\t     * @private\n\t     * @property {string} [baseURL] - the URL of the cloud infrastructure's REST API.\n\t     * @property {string} [token] - The endpoint's authentication token.\n\t     * @property {string} [appId] - The id of your Respoke app.\n\t     * @property {string} [endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @property {boolean} [developmentMode=false] - Indication to obtain an authentication token from the service.\n\t     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t     * operation and will limit the services you will be able to use.\n\t     * @property {boolean} [reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n\t     * when a disconnect occurs.\n\t     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n\t     * @property {respoke.Client.onClientMessage} [onMessage] - Callback for when any message is received\n\t     * from anywhere on the system.\n\t     * @property {respoke.Client.onConnect} [onConnect] - Callback for Client connect.\n\t     * @property {respoke.Client.onDisconnect} [onDisconnect] - Callback for Client disconnect.\n\t     * @property {respoke.Client.onReconnect} [onReconnect] - Callback for Client reconnect. Not Implemented.\n\t     * @property {respoke.Client.onCall} [onCall] - Callback for when this client receives a call.\n\t     * @property {respoke.Client.onDirectConnection} [onDirectConnection] - Callback for when this client\n\t     * receives a request for a direct connection.\n\t     * @property {boolean} enableCallDebugReport=true - Upon finishing a call, should the client send debugging\n\t     * information to the API? Defaults to `true`.\n\t     */\n\t    var clientSettings = {};\n\t\n\t    delete that.appId;\n\t    delete that.baseURL;\n\t    delete that.developmentMode;\n\t    delete that.token;\n\t    delete that.resolveEndpointPresence;\n\t\n\t    /**\n\t     * Internal list of known groups.\n\t     * @memberof! respoke.Client\n\t     * @name groups\n\t     * @type {Array<respoke.Group>}\n\t     * @private\n\t     */\n\t    var groups = [];\n\t    /**\n\t     * Internal list of known endpoints.\n\t     * @memberof! respoke.Client\n\t     * @name endpoints\n\t     * @type {Array<respoke.Endpoint>}\n\t     * @private\n\t     */\n\t    var endpoints = [];\n\t    /**\n\t     * Array of calls in progress, made accessible for informational purposes only.\n\t     * **Never modify this array directly.**\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @name calls\n\t     * @type {array}\n\t     */\n\t    that.calls = [];\n\t    log.debug(\"Client ID is \", instanceId);\n\t\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name signalingChannel\n\t     * @type {respoke.SignalingChannel}\n\t     * @private\n\t     */\n\t    var signalingChannel = respoke.SignalingChannel({\n\t        instanceId: instanceId,\n\t        clientSettings: clientSettings\n\t    });\n\t\n\t    /**\n\t     * Save parameters of the constructor or client.connect() onto the clientSettings object\n\t     * @memberof! respoke.Client\n\t     * @method respoke.saveParameters\n\t     * @param {object} params\n\t     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n\t     * respoke.connect, respoke.createClient, or to client.connect.\n\t     * @param {string} [params.token] - The endpoint's authentication token.\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n\t     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n\t     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n\t     * to decide which Connection's presence gets precedence for the Endpoint.\n\t     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t     * operation and will limit the services you will be able to use.\n\t     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n\t     * when a disconnect occurs.\n\t     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n\t     * a group.\n\t     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n\t     * received from anywhere on the system.\n\t     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n\t     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n\t     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n\t     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n\t     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n\t     * client receives a request for a direct connection.\n\t     * @private\n\t     */\n\t    function saveParameters(params) {\n\t        Object.keys(params).forEach(function eachParam(key) {\n\t            if (['onSuccess', 'onError', 'reconnect'].indexOf(key) === -1 && params[key] !== undefined) {\n\t                clientSettings[key] = params[key];\n\t            }\n\t        });\n\t\n\t        clientSettings.developmentMode = !!clientSettings.developmentMode;\n\t        clientSettings.enableCallDebugReport = typeof clientSettings.enableCallDebugReport === 'boolean' ?\n\t            clientSettings.enableCallDebugReport : true;\n\t\n\t        if (typeof params.reconnect !== 'boolean') {\n\t            clientSettings.reconnect = typeof params.developmentMode === 'boolean' ? params.developmentMode : false;\n\t        } else {\n\t            clientSettings.reconnect = !!params.reconnect;\n\t        }\n\t    }\n\t    saveParameters(params);\n\t\n\t    /**\n\t     * Connect to the Respoke infrastructure and authenticate using `params.token`.\n\t     *\n\t     * After `connect`, the app auth session token is stored so it can be used in API requests.\n\t     *\n\t     * This method attaches quite a few event listeners for things like group joining and connection status changes.\n\t     *\n\t     * #### Usage\n\t     *\n\t     *      client.connect({\n\t     *          appId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\",\n\t     *          token: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\", // if not developmentMode\n\t     *          developmentMode: false || true,\n\t     *          // if developmentMode, otherwise your server will set endpointId\n\t     *          endpointId: \"billy\"\n\t     *      });\n\t     *      client.listen(\"connect\", function () { } );\n\t     *\n\t     *\n\t     * If no `params.token` is given and `developmentMode` is set to true, it will attempt to obtain a token\n\t     * automatically. You must set an `endpointId`.\n\t     *\n\t     *\n\t     * #### App auth session token expiration\n\t     *\n\t     * If `params.reconnect` is set to true (which it is by default for `developmentMode`), the `client`\n\t     * will attempt to keep reconnecting each time the app auth session expires.\n\t     *\n\t     * If not using `developmentMode`, automatic reconnect will be disabled. You will need to\n\t     * listen to the Client's `disconnect` event to fetch a new brokered auth token and call\n\t     * `client.connect()` with the new token.\n\t     *\n\t     *      client.listen('disconnect', function () {\n\t     *\n\t     *          // example method you implemented to get a new token from your server\n\t     *          myServer.getNewRespokeAccessToken(function (newToken) {\n\t     *              // reconnect with respoke.Client\n\t     *              client.connect({ token: newToken });\n\t     *          });\n\t     *\n\t     *      });\n\t     *\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.connect\n\t     * @param {object} params\n\t     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n\t     * respoke.connect, respoke.createClient, or to client.connect.\n\t     * @param {string} [params.token] - The endpoint's authentication token.\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n\t     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n\t     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n\t     * to decide which Connection's presence gets precedence for the Endpoint.\n\t     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t     * operation and will limit the services you will be able to use.\n\t     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n\t     * when a disconnect occurs.\n\t     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n\t     * a group.\n\t     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n\t     * received from anywhere on the system.\n\t     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n\t     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n\t     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n\t     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n\t     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n\t     * client receives a request for a direct connection.\n\t     * @returns {Promise|undefined}\n\t     * @fires respoke.Client#connect\n\t     */\n\t    that.connect = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        params = params || {};\n\t        log.debug('Client.connect');\n\t        that.connectTries += 1;\n\t\n\t        saveParameters(params);\n\t\n\t        that.endpointId = clientSettings.endpointId;\n\t        promise = actuallyConnect(params);\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        promise.then(function successHandler() {\n\t            /**\n\t             * This event is fired the first time the library connects to the cloud infrastructure.\n\t             * @event respoke.Client#connect\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.fire('connect');\n\t\n\t            /**\n\t             * This event fires only when the initial `connect` fails.\n\t             *\n\t             * @ignore **This comment is for documentation purposes**, since #error bubbles\n\t             * up from other classes, but it should show on `respoke.Client` docs.\n\t             *\n\t             * @event respoke.Client#error\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * This function contains the meat of the connection, the portions which can be repeated again on reconnect.\n\t     *\n\t     * When `reconnect` is true, this function will be added in an event listener to the Client#disconnect event.\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.actuallyConnect\n\t     * @private\n\t     * @param {object} params\n\t     * @param {connectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    function actuallyConnect(params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t\n\t        if (!clientSettings.token &&\n\t                (!clientSettings.appId || !clientSettings.endpointId || clientSettings.developmentMode !== true)) {\n\t            deferred.reject(new Error(\"Must pass either endpointID & appId & developmentMode=true, or a token, \" +\n\t                \"to client.connect().\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        signalingChannel.open({\n\t            actuallyConnect: actuallyConnect,\n\t            endpointId: that.endpointId,\n\t            token: clientSettings.token\n\t        }).then(function successHandler() {\n\t            return signalingChannel.authenticate();\n\t        }).done(function successHandler() {\n\t            // set initial presence for the connection\n\t            if (clientSettings.presence) {\n\t                that.setPresence({presence: clientSettings.presence});\n\t            }\n\t\n\t            /*\n\t             * These rely on the EventEmitter checking for duplicate event listeners in order for these\n\t             * not to be duplicated on reconnect.\n\t             */\n\t\n\t            /**\n\t             * This event provides notification for when an incoming call is being received.  If the user wishes\n\t             * to allow the call, `evt.call.answer()`.\n\t             * @event respoke.Client#call\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Call} call\n\t             * @property {respoke.Endpoint} endpoint\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('call', clientSettings.onCall);\n\t            /**\n\t             * This event is fired when the local end of the directConnection is available. It still will not be\n\t             * ready to send and receive messages until the 'open' event fires.\n\t             * @event respoke.Client#direct-connection\n\t             * @type {respoke.Event}\n\t             * @property {respoke.DirectConnection} directConnection\n\t             * @property {respoke.Endpoint} endpoint\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.listen('direct-connection', clientSettings.onDirectConnection);\n\t            that.listen('join', clientSettings.onJoin);\n\t            /**\n\t             * This event is fired every time the client leaves a group.\n\t             * @event respoke.Client#leave\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Group} group\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.listen('leave', clientSettings.onLeave);\n\t            /**\n\t             * A generic message handler when a message was received by the client.\n\t             *\n\t             * @event respoke.Client#message\n\t             * @type {respoke.Event}\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Endpoint} endpoint - If the message was private, this is the Endpoint who sent it.\n\t             * @property {respoke.Group} group - If the message was to a group, this is the group.\n\t             * @property {respoke.TextMessage} message - The generic message object.\n\t             * @property {string} message.connectionId\n\t             * @property {string} message.endpointId\n\t             * @property {string} message.message - Message body text.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('message', clientSettings.onMessage);\n\t            that.listen('connect', clientSettings.onConnect);\n\t            /**\n\t             * Client has disconnected from Respoke.\n\t             *\n\t             * @event respoke.Client#disconnect\n\t             * @type {respoke.Event}\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('disconnect', clientSettings.onDisconnect);\n\t            that.listen('disconnect', function () {\n\t                that.calls.forEach(function (call) {\n\t                    call.hangup({signal: false});\n\t                });\n\t            }, true);\n\t            /**\n\t             * Client has reconnected to Respoke.\n\t             *\n\t             * @event respoke.Client#reconnect\n\t             * @type {respoke.Event}\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('reconnect', clientSettings.onReconnect);\n\t\n\t            log.info('logged in as ' + that.endpointId, that);\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t            log.error(err.message, err.stack);\n\t        });\n\t\n\t        return deferred.promise;\n\t    }\n\t\n\t    /**\n\t     * Disconnect from the Respoke infrastructure, leave all groups, invalidate the token, and disconnect the websocket.\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.disconnect\n\t     * @returns {Promise|undefined}\n\t     * @param {object} params\n\t     * @param {disconnectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @fires respoke.Client#disconnect\n\t     */\n\t    that.disconnect = function (params) {\n\t        // TODO: also call this on socket disconnect\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            deferred.reject(e);\n\t            return retVal;\n\t        }\n\t\n\t        var leaveGroups = groups.map(function eachGroup(group) {\n\t            group.leave();\n\t        });\n\t\n\t        Q.all(leaveGroups).fin(function successHandler() {\n\t            return signalingChannel.close();\n\t        }).fin(function finallyHandler() {\n\t            that.presence = 'unavailable';\n\t            endpoints = [];\n\t            groups = [];\n\t            /**\n\t             * This event is fired when the library has disconnected from the cloud infrastructure.\n\t             * @event respoke.Client#disconnect\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.fire('disconnect');\n\t            deferred.resolve();\n\t        }).done();\n\t\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Set the presence for this client.\n\t     *\n\t     * The value of presence can be a string, number, object, or array - in any format -\n\t     * depending on the needs of your application. The only requirement is that\n\t     * `JSON.stringify()` must work (no circular references).\n\t     *\n\t     *      var myPresence = 'At lunch'\n\t     *                      || 4\n\t     *                      || { status: 'Away', message: 'At lunch' }\n\t     *                      || ['Away', 'At lunch'];\n\t     *\n\t     *      client.setPresence({\n\t     *          presence: myPresence,\n\t     *          onSuccess: function (evt) {\n\t     *              // successfully updated my presence\n\t     *          }\n\t     *      });\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.setPresence\n\t     * @param {object} params\n\t     * @param {string|number|object|array} params.presence\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @overrides Presentable.setPresence\n\t     * @return {Promise|undefined}\n\t     */\n\t    that.setPresence = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        params = params || {};\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        }\n\t\n\t        log.info('sending my presence update ' + params.presence);\n\t\n\t        promise = signalingChannel.sendPresence({\n\t            presence: params.presence\n\t        });\n\t\n\t        promise.then(function successHandler(p) {\n\t            superClass.setPresence(params);\n\t            clientSettings.presence = params.presence;\n\t        });\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Get the Call with the endpoint specified.\n\t     *\n\t     *     // hang up on chad\n\t     *     var call = client.getCall({\n\t     *         endpointId: 'chad'\n\t     *     });\n\t     *\n\t     *     if (call) {\n\t     *         call.hangup()\n\t     *     }\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getCall\n\t     * @param {object} params\n\t     * @param {string} [params.id] - Call ID.\n\t     * @param {string} [params.endpointId] - Endpoint ID. Warning: If you pass only the endpointId, this method\n\t     * will just return the first call that matches. If you are placing multiple calls to the same endpoint,\n\t     * pass in the call ID, too.\n\t     * @param {boolean} params.create - whether or not to create a new call if the specified endpointId isn't found\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.getCall = function (params) {\n\t        var call = null;\n\t        var endpoint = null;\n\t        var methods = {\n\t            did: \"startPhoneCall\",\n\t            web: \"startCall\",\n\t            sip: \"startSIPCall\"\n\t        };\n\t        params.fromType = params.fromType || \"web\";\n\t\n\t        that.calls.every(function findCall(one) {\n\t            if (params.id && one.id === params.id) {\n\t                call = one;\n\t                return false;\n\t            }\n\t\n\t            if (!params.id && params.endpointId && one.remoteEndpoint.id === params.endpointId) {\n\t                call = one;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        if (call === null && params.create === true) {\n\t            try {\n\t                call = that[methods[params.fromType]]({\n\t                    id: params.id,\n\t                    number: params.fromType === \"did\" ? params.endpointId : undefined,\n\t                    uri: params.fromType === \"sip\" ? params.endpointId : undefined,\n\t                    endpointId: params.fromType === \"web\" ? params.endpointId : undefined,\n\t                    caller: false,\n\t                    toType: params.fromType,\n\t                    fromType: \"web\"\n\t                });\n\t            } catch (e) {\n\t                log.error(\"Couldn't create Call.\", e.message, e.stack);\n\t            }\n\t        }\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Add the call to internal record-keeping.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.addCall\n\t     * @param {object} evt\n\t     * @param {respoke.Call} evt.call\n\t     * @param {respoke.Endpoint} evt.endpoint\n\t     * @private\n\t     */\n\t    function addCall(evt) {\n\t        log.debug('addCall');\n\t        if (!evt.call) {\n\t            throw new Error(\"Can't add call without a call parameter.\");\n\t        }\n\t        if (that.calls.indexOf(evt.call) === -1) {\n\t            that.calls.push(evt.call);\n\t        }\n\t\n\t        evt.call.listen('hangup', function () {\n\t            removeCall({call: evt.call});\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Remove the call or direct connection from internal record-keeping.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.removeCall\n\t     * @param {object} evt\n\t     * @param {respoke.Call} evt.target\n\t     * @private\n\t     */\n\t    function removeCall(evt) {\n\t        var match = 0;\n\t        if (!evt.call) {\n\t            throw new Error(\"Can't remove call without a call parameter.\");\n\t        }\n\t\n\t        // Loop backward since we're modifying the array in place.\n\t        for (var i = that.calls.length - 1; i >= 0; i -= 1) {\n\t            if (that.calls[i].id === evt.call.id) {\n\t                that.calls.splice(i, 1);\n\t                match += 1;\n\t            }\n\t        }\n\t\n\t        if (match !== 1) {\n\t            log.warn(\"Something went wrong.\", match, \"calls were removed!\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Convenience method for setting presence to `\"available\"`.\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.setOnline\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=available] - The presence to set.\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.setOnline = function (params) {\n\t        var promise;\n\t\n\t        params = params || {};\n\t        params.presence = params.presence || 'available';\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        }\n\t\n\t        return that.setPresence(params);\n\t    };\n\t\n\t    /**\n\t     * Convenience method for setting presence to `\"unavailable\"`.\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.setOffline\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=unavailable] - The presence to set.\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.setOffline = function (params) {\n\t        var promise;\n\t\n\t        params = params || {};\n\t        params.presence = params.presence || 'unavailable';\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        }\n\t\n\t        return that.setPresence(params);\n\t    };\n\t\n\t    /**\n\t     * Send a message to an endpoint.\n\t     *\n\t     *     client.sendMessage({\n\t     *         endpointId: 'dan',\n\t     *         message: \"Jolly good.\"\n\t     *     });\n\t     *\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The endpoint id of the recipient.\n\t     * @param {string} [params.connectionId] - The optional connection id of the receipient. If not set, message will be\n\t     * broadcast to all connections for this endpoint.\n\t     * @param {string} params.message - a string message.\n\t     * @param {sendHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        var endpoint;\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t            return retVal;\n\t        }\n\t        endpoint = that.getEndpoint({\n\t            skipPresence: true,\n\t            id: params.endpointId\n\t        });\n\t        delete params.endpointId;\n\t        return endpoint.sendMessage(params);\n\t    };\n\t\n\t    /**\n\t     * Place an audio and/or video call to an endpoint.\n\t     *\n\t     *     // defaults to video when no constraints are supplied\n\t     *     client.startCall({\n\t     *         endpointId: 'erin',\n\t     *         onConnect: function (evt) { },\n\t     *         onLocalMedia: function (evt) { }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startCall\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The id of the endpoint that should be called.\n\t     * @param {RTCConstraints} [params.constraints]\n\t     * @param {string} [params.connectionId]\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote video attached to it.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startCall = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        var endpoint;\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t            return retVal;\n\t        }\n\t\n\t        endpoint = that.getEndpoint({\n\t            skipPresence: true,\n\t            id: params.endpointId\n\t        });\n\t        delete params.endpointId;\n\t        return endpoint.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Place an audio only call to an endpoint.\n\t     *\n\t     *     client.startAudioCall({\n\t     *         endpointId: 'erin',\n\t     *         onConnect: function (evt) { },\n\t     *         onLocalMedia: function (evt) { }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startAudioCall\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The id of the endpoint that should be called.\n\t     * @param {string} [params.connectionId]\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n\t     * video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n\t     * video attached to it.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startAudioCall = function (params) {\n\t        params = params || {};\n\t        params.constraints = {\n\t            video: false,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        };\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Place a video call to an endpoint.\n\t     *\n\t     *     client.startVideoCall({\n\t     *         endpointId: 'erin',\n\t     *         onConnect: function (evt) { },\n\t     *         onLocalMedia: function (evt) { }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startVideoCall\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The id of the endpoint that should be called.\n\t     * @param {string} [params.connectionId]\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n\t     * video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n\t     * video attached to it.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startVideoCall = function (params) {\n\t        params = params || {};\n\t        params.constraints = {\n\t            video: true,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        };\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Place an audio call with a phone number.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startPhoneCall\n\t     * @param {object} params\n\t     * @param {string} params.number - The phone number that should be called.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startPhoneCall = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        var call = null;\n\t        var recipient = {};\n\t        params = params || {};\n\t        params.constraints = {\n\t            video: false,\n\t            audio: true,\n\t            mandatory: {},\n\t            optional: []\n\t        };\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t            return retVal;\n\t        }\n\t\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        if (!params.number) {\n\t            log.error(\"Can't start a phone call without a number.\");\n\t            promise = Q.reject(new Error(\"Can't start a phone call without a number.\"));\n\t            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t            return retVal;\n\t        }\n\t\n\t        recipient.id = params.number;\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = recipient;\n\t\n\t        params.toType = params.toType || 'did';\n\t        params.fromType = params.fromType || 'web';\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            signalParams.signalType = 'answer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.connectionId = signalParams.connectionId;\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send connected.\", err.message, err.stack);\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalModify = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send modify.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            log.debug(\"Sending debug report\", signalParams.report);\n\t            signalingChannel.sendReport(signalParams);\n\t        };\n\t\n\t        params.signalingChannel = signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({call: call});\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Place an audio call to a SIP URI.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startSIPCall\n\t     * @param {object} params\n\t     * @param {string} params.uri - The SIP URI to call.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startSIPCall = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        var call = null;\n\t        var recipient = {};\n\t        params = params || {};\n\t        params.constraints = {\n\t            video: false,\n\t            audio: true,\n\t            mandatory: {},\n\t            optional: []\n\t        };\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t            return retVal;\n\t        }\n\t\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        if (!params.uri) {\n\t            log.error(\"Can't start a phone call without a SIP URI.\");\n\t            promise = Q.reject(new Error(\"Can't start a phone call without a SIP URI.\"));\n\t            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t            return retVal;\n\t        }\n\t\n\t        recipient.id = params.uri;\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = recipient;\n\t\n\t        params.toType = params.toType || 'sip';\n\t        params.fromType = params.fromType || 'web';\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            signalParams.signalType = 'answer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.connectionId = signalParams.connectionId;\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send connected.\", err.message, err.stack);\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalModify = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send modify.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            log.debug(\"Sending debug report\", signalParams.report);\n\t            signalingChannel.sendReport(signalParams);\n\t        };\n\t\n\t        params.signalingChannel = signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({call: call});\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Assert that we are connected to the backend infrastructure.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.verifyConnected\n\t     * @throws {Error}\n\t     * @private\n\t     */\n\t    that.verifyConnected = function () {\n\t        if (!signalingChannel.isConnected()) {\n\t            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Check whether this client is connected to the Respoke API.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.isConnected\n\t     * @returns boolean\n\t     */\n\t    that.isConnected = function () {\n\t        return signalingChannel.isConnected();\n\t    };\n\t\n\t    /**\n\t     * Join a group and begin keeping track of it. If this method is called multiple times synchronously, it will\n\t     * batch requests and only make one API call to Respoke.\n\t     *\n\t     * You can leave the group by calling `group.leave()`;\n\t     *\n\t     * ##### Joining and leaving a group\n\t     *\n\t     *      var group;\n\t     *\n\t     *      client.join({\n\t     *          id: \"book-club\",\n\t     *          onSuccess: function (evt) {\n\t     *              console.log('I joined', evt.group.id);\n\t     *              // \"I joined book-club\"\n\t     *              group = evt.group;\n\t     *              group.sendMessage({\n\t     *                  message: 'sup'\n\t     *              });\n\t     *          }\n\t     *      });\n\t     *\n\t     *      // . . .\n\t     *      // Some time later, leave the group.\n\t     *      // . . .\n\t     *      group.leave({\n\t     *          onSuccess: function (evt) {\n\t     *              console.log('I left', evt.group.id);\n\t     *              // \"I left book-club\"\n\t     *          }\n\t     *      });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.join\n\t     * @param {object} params\n\t     * @param {string} params.id - The name of the group.\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.Group.onMessage} [params.onMessage] - Message handler for messages from this group only.\n\t     * @param {respoke.Group.onJoin} [params.onJoin] - Join event listener for endpoints who join this group only.\n\t     * @param {respoke.Group.onLeave} [params.onLeave] - Leave event listener for endpoints who leave\n\t     * this group only.\n\t     * @returns {Promise<respoke.Group>|undefined} The instance of the respoke.Group which the client joined.\n\t     * @fires respoke.Client#join\n\t     */\n\t    that.join = function (params) {\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            deferred.reject(e);\n\t            return retVal;\n\t        }\n\t\n\t        if (!params.id) {\n\t            deferred.reject(new Error(\"Can't join a group with no group id.\"));\n\t            return retVal;\n\t        }\n\t\n\t        signalingChannel.joinGroup({\n\t            groupList: [params.id]\n\t        }).done(function successHandler() {\n\t            var group;\n\t            params.signalingChannel = signalingChannel;\n\t            params.instanceId = instanceId;\n\t\n\t            group = that.getGroup({id: params.id});\n\t\n\t            if (!group) {\n\t                group = respoke.Group(params);\n\t                that.addGroup(group);\n\t            }\n\t\n\t            group.listen('join', params.onJoin);\n\t            group.listen('leave', params.onLeave);\n\t            group.listen('message', params.onMessage);\n\t\n\t            group.addMember({\n\t                connection: that.getConnection({\n\t                    endpointId: that.endpointId,\n\t                    connectionId: that.connectionId\n\t                })\n\t            });\n\t\n\t            /**\n\t             * This event is fired every time the client joins a group. If the client leaves\n\t             * a group, this event will be fired again on the next time the client joins the group.\n\t             * @event respoke.Client#join\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Group} group\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('join', {\n\t                group: group\n\t            });\n\t            deferred.resolve(group);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Add a Group. This is called when we join a group and need to begin keeping track of it.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.addGroup\n\t     * @param {respoke.Group}\n\t     * @private\n\t     */\n\t    that.addGroup = function (newGroup) {\n\t        if (!newGroup || newGroup.className !== 'respoke.Group') {\n\t            throw new Error(\"Can't add group to internal tracking without a group.\");\n\t        }\n\t\n\t        newGroup.listen('leave', function leaveHandler(evt) {\n\t            newGroup.removeMember({connectionId: evt.connection.id});\n\t            var endpt = evt.connection.getEndpoint();\n\t            if (!endpt.hasListeners('presence')) {\n\t                checkEndpointForRemoval(endpt);\n\t            }\n\t        }, true);\n\t\n\t        groups.push(newGroup);\n\t    };\n\t\n\t    /**\n\t     * Get a list of all the groups the client is currently a member of.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getGroups\n\t     * @returns {Array<respoke.Group>} All of the groups the library is aware of.\n\t     */\n\t    that.getGroups = function () {\n\t        return groups;\n\t    };\n\t\n\t    /**\n\t     * Find a group by id and return it.\n\t     *\n\t     *     var group = client.getGroup({\n\t     *         id: \"resistance\"\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getGroup\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     * @param {respoke.Group.onJoin} [params.onJoin] - Receive notification that an endpoint has joined this group.\n\t     * @param {respoke.Group.onLeave} [params.onLeave] - Receive notification that an endpoint has left this group.\n\t     * @param {respoke.Group.onMessage} [params.onMessage] - Receive notification that a message has been\n\t     * received to a group.\n\t     * @returns {respoke.Group|undefined} The group whose ID was specified.\n\t     */\n\t    that.getGroup = function (params) {\n\t        var group;\n\t        if (!params || !params.id) {\n\t            throw new Error(\"Can't get a group without group id.\");\n\t        }\n\t\n\t        groups.every(function eachGroup(grp) {\n\t            if (grp.id === params.id) {\n\t                group = grp;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        if (group) {\n\t            group.listen('join', params.onJoin);\n\t            group.listen('leave', params.onLeave);\n\t            group.listen('message', params.onMessage);\n\t        }\n\t\n\t        return group;\n\t    };\n\t\n\t    /**\n\t     * Remove an Endpoint. Since an endpoint can be a member of multiple groups, we can't just remove it from\n\t     * our list on respoke.Endpoint#leave. We must see if it's a member of any more groups. If it's not\n\t     * a member of any other groups, we can stop keeping track of it.\n\t     * @todo TODO Need to account for Endpoints not created as part of a group. These do not need to be\n\t     * deleted based on group membership.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.checkEndpointForRemoval\n\t     * @param {object} params\n\t     * @param {string} params.id - The ID of the Endpoint to check for removal.\n\t     * @private\n\t     */\n\t    function checkEndpointForRemoval(params) {\n\t        params = params || {};\n\t        if (!params.id) {\n\t            throw new Error(\"Can't remove endpoint from internal tracking without group id.\");\n\t        }\n\t\n\t        Q.all(groups.map(function eachGroup(group) {\n\t            return group.getMembers();\n\t        })).done(function successHandler(connectionsByGroup) {\n\t            // connectionsByGroup is a two-dimensional array where the first dimension is a group\n\t            // and the second dimension is a connection.\n\t            var absent = connectionsByGroup.every(function eachConnectionList(connectionList) {\n\t                return connectionList.every(function eachConnection(conn) {\n\t                    return (conn.endpointId !== params.id);\n\t                });\n\t            });\n\t            if (absent) {\n\t                endpoints.every(function eachEndpoint(ept, index) {\n\t                    if (ept.id === params.id) {\n\t                        endpoints.splice(index, 1);\n\t                        return false;\n\t                    }\n\t                    return true;\n\t                });\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Find an endpoint by id and return the `respoke.Endpoint` object.\n\t     *\n\t     * If it is not already cached locally, will be added to the local cache of tracked endpoints,\n\t     * its presence will be determined, and will be available in `client.getEndpoints()`.\n\t     *\n\t     *     var endpoint = client.getEndpoint({\n\t     *         id: \"dlee\"\n\t     *     });\n\t     *\n\t     * @ignore If the endpoint is not found in the local cache of endpoint objects (see `client.getEndpoints()`),\n\t     * it will be created. This is useful, for example, in the case of dynamic endpoints where groups are\n\t     * not in use. Override dynamic endpoint creation by setting `params.skipCreate = true`.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getEndpoint\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n\t     * from this one Endpoint.\n\t     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n\t     * Endpoint.\n\t     * @arg {boolean} [params.skipCreate] - Skip the creation step and return undefined if we don't yet\n\t     * @arg {boolean} [params.skipPresence] - Skip registering for this endpoint's presence.\n\t     * @returns {respoke.Endpoint} The endpoint whose ID was specified.\n\t     */\n\t    that.getEndpoint = function (params) {\n\t        var endpoint;\n\t        if (!params || !params.id) {\n\t            throw new Error(\"Can't get an endpoint without endpoint id.\");\n\t        }\n\t\n\t        endpoints.every(function eachEndpoint(ept) {\n\t            if (ept.id === params.id) {\n\t                endpoint = ept;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        if (!endpoint && params && !params.skipCreate) {\n\t            params.instanceId = instanceId;\n\t            params.signalingChannel = signalingChannel;\n\t            params.resolveEndpointPresence = clientSettings.resolveEndpointPresence;\n\t            params.addCall = addCall;\n\t\n\t            endpoint = respoke.Endpoint(params);\n\t            endpoints.push(endpoint);\n\t        }\n\t\n\t        if (!endpoint) {\n\t            return;\n\t        }\n\t\n\t        if (params.skipPresence !== true) {\n\t            signalingChannel.registerPresence({\n\t                endpointList: [endpoint.id]\n\t            }).done(null, function (err) {\n\t                log.error(\"Couldn't register for presence on\", endpoint.id, err.message);\n\t            });\n\t        }\n\t        endpoint.listen('presence', params.onPresence);\n\t        endpoint.listen('message', params.onMessage);\n\t\n\t        return endpoint;\n\t    };\n\t\n\t    /**\n\t     * Find a Connection by id and return it.\n\t     *\n\t     *     var connection = client.getConnection({\n\t     *         id: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n\t     *     });\n\t     *\n\t     * @ignore In most cases, if we don't find it we will create it. This is useful\n\t     * in the case of dynamic endpoints where groups are not in use. Set skipCreate=true\n\t     * to return undefined if the Connection is not already known.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getConnection\n\t     * @param {object} params\n\t     * @param {string} params.connectionId\n\t     * @param {string} [params.endpointId] - An endpointId to use in the creation of this connection.\n\t     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n\t     * from this one Connection.\n\t     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n\t     * Connection.\n\t     * @returns {respoke.Connection} The connection whose ID was specified.\n\t     */\n\t    that.getConnection = function (params) {\n\t        var connection;\n\t        var endpoint;\n\t        var endpointsToSearch = endpoints;\n\t\n\t        params = params || {};\n\t        if (!params.connectionId) {\n\t            throw new Error(\"Can't get a connection without connection id.\");\n\t        }\n\t        if (!params.endpointId && !params.skipCreate) {\n\t            throw new Error(\"Can't create a connection without endpoint id.\");\n\t        }\n\t\n\t        if (params.endpointId) {\n\t            endpoint = that.getEndpoint({\n\t                id: params.endpointId,\n\t                skipPresence: true,\n\t                skipCreate: params.skipCreate\n\t            });\n\t\n\t            endpointsToSearch = [];\n\t            if (endpoint) {\n\t                endpointsToSearch = [endpoint];\n\t            }\n\t        }\n\t\n\t        endpointsToSearch.every(function eachEndpoint(ept) {\n\t            connection = ept.getConnection(params);\n\t            return !connection;\n\t        });\n\t\n\t        if (!connection && !params.skipCreate) {\n\t            params.instanceId = instanceId;\n\t            connection = respoke.Connection(params);\n\t            endpoint.connections.push(connection);\n\t        }\n\t\n\t        return connection;\n\t    };\n\t\n\t    /**\n\t     * Get the list of **all endpoints** that the library has knowledge of.\n\t     * These are `respoke.Endpoint` objects, not just the endpointIds.\n\t     *\n\t     * The library gains knowledge of an endpoint in two ways:\n\t     * 1. when an endpoint joins a group that the user (currently logged-in endpoint) is a member of (if group presence is enabled)\n\t     * 2. when an endpoint that the user (currently logged-in endpoint) is watching*\n\t     *\n\t     * *If an endpoint that the library does not know about sends a message to the client, you\n\t     * can immediately call the `client.getEndpoint()` method on the sender of the message to enable\n\t     * watching of the sender's endpoint.\n\t     *\n\t     *      client.on('message', function (data) {\n\t     *          if (data.endpoint) {\n\t     *              // start tracking this endpoint.\n\t     *              client.getEndpoint({ id: data.endpoint.id });\n\t     *          }\n\t     *      });\n\t     *\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getEndpoints\n\t     * @returns {Array<respoke.Endpoint>}\n\t     */\n\t    that.getEndpoints = function () {\n\t        return endpoints;\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Client\n\t\n\t/**\n\t * Handle sending successfully.\n\t * @callback respoke.Client.successHandler\n\t */\n\t/**\n\t * Handle joining a group successfully. This callback is called only once when Client.join() is called.\n\t * @callback respoke.Client.joinHandler\n\t * @param {respoke.Group} group\n\t */\n\t/**\n\t * Receive notification that the client has joined a group. This callback is called everytime\n\t * respoke.Client#join is fired.\n\t * @callback respoke.Client.onJoin\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Group} evt.group\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Receive notification that the client has left a group. This callback is called everytime\n\t * respoke.Client#leave is fired.\n\t * @callback respoke.Client.onLeave\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Group} evt.group\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Receive notification that a message has been received. This callback is called every time\n\t * respoke.Client#message is fired.\n\t * @callback respoke.Client.onClientMessage\n\t * @param {respoke.Event} evt\n\t * @param {respoke.TextMessage} evt.message\n\t * @param {respoke.Group} [evt.group] - If the message is to a group we already know about,\n\t * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n\t * the group. From that point forward, Group#message will fire when a message is received as well. If\n\t * group is undefined instead of null, the message is not a group message at all.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Receive notification that the client is receiving a call from a remote party. This callback is called every\n\t * time respoke.Client#call is fired.\n\t * @callback respoke.Client.onCall\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.call\n\t * @param {respoke.Endpoint} evt.endpoint\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Receive notification that the client is receiving a request for a direct connection from a remote party.\n\t * This callback is called every time respoke.Client#direct-connection is fired.\n\t * @callback respoke.Client.onDirectConnection\n\t * @param {respoke.Event} evt\n\t * @param {respoke.DirectConnection} evt.directConnection\n\t * @param {respoke.Endpoint} evt.endpoint\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Receive notification Respoke has successfully connected to the cloud. This callback is called every time\n\t * respoke.Client#connect is fired.\n\t * @callback respoke.Client.onConnect\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Receive notification Respoke has successfully disconnected from the cloud. This callback is called every time\n\t * respoke.Client#disconnect is fired.\n\t * @callback respoke.Client.onDisconnect\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Receive notification Respoke has successfully reconnected to the cloud. This callback is called every time\n\t * respoke.Client#reconnect is fired.\n\t * @callback respoke.Client.onReconnect\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Handle disconnection to the cloud successfully.\n\t * @callback respoke.Client.disconnectSuccessHandler\n\t */\n\t/**\n\t * Handle an error that resulted from a method call.\n\t * @callback respoke.Client.errorHandler\n\t * @params {Error} err\n\t */\n\t/**\n\t * Handle connection to the cloud successfully.\n\t * @callback respoke.Client.connectSuccessHandler\n\t */\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * The purpose of the class is to allow multiple types of entities to expose presence functionality.\n\t * \n\t * Setting the presence on a client is provided via `client.setPresence({ presence: \"At lunch\" })`.\n\t * \n\t * @class respoke.Presentable\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId\n\t * @param {string} params.id\n\t * @returns {respoke.Presentable}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Presentable\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.Presentable\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Presentable';\n\t    /**\n\t     * Represents the presence status. Typically a string, but other types are supported.\n\t     * Defaults to `'unavailable'`.\n\t     * \n\t     * **Do not modify this directly** - it won't update presence with Respoke. Use `setPresence()`.\n\t     * \n\t     * @memberof! respoke.Presentable\n\t     * @name presence\n\t     * @type {string|number|object|Array}\n\t     * @private\n\t     */\n\t    that.presence = 'unavailable';\n\t\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name client\n\t     * @type {respoke.Client}\n\t     * @private\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t\n\t    /**\n\t     * Set the presence on the object for this session.\n\t     * \n\t     * @memberof! respoke.Presentable\n\t     * @method respoke.Presentable.setPresence\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=available]\n\t     * @param {string} params.connectionId\n\t     * @fires respoke.Presentable#presence\n\t     * @private\n\t     */\n\t    that.setPresence = function (params) {\n\t        var connection;\n\t        params = params || {};\n\t        params.presence = params.presence || 'available';\n\t        params.connectionId = params.connectionId || that.connectionId;\n\t\n\t        if (that.className === 'respoke.Client' || that.className === 'respoke.Connection') {\n\t            that.presence = params.presence;\n\t            if (that.className === 'respoke.Connection') {\n\t                that.getEndpoint().resolvePresence();\n\t            }\n\t        } else if (that.className === 'respoke.Endpoint') {\n\t            if (!params.connectionId) {\n\t                throw new Error(\"Can't set Endpoint presence without a connectionId.\");\n\t            }\n\t\n\t            connection = that.getConnection({connectionId: params.connectionId}) || client.getConnection({\n\t                connectionId: params.connectionId,\n\t                skipCreate: false,\n\t                endpointId: that.id\n\t            });\n\t\n\t            connection.presence = params.presence;\n\t            that.resolvePresence();\n\t        }\n\t\n\t        /**\n\t         * This event indicates that the presence for this endpoint has been updated.\n\t         * @event respoke.Presentable#presence\n\t         * @type {respoke.Event}\n\t         * @property {string|number|object|Array} presence\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Presentable} target\n\t         */\n\t        that.fire('presence', {\n\t            presence: that.presence\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Get the presence of a Presentable instance.\n\t     * \n\t     *      var billy = client.getEndpoint({ id: \"billychia\" });\n\t     *      var pres = billy.getPresence();\n\t     *      console.log('Billy is', pres); // \"Billy is available\"\n\t     * \n\t     * @memberof! respoke.Presentable\n\t     * @method respoke.Presentable.getPresence\n\t     * @returns {string|number|object|array} the current presence of this endpoint.\n\t     */\n\t    that.getPresence = function () {\n\t        return that.presence;\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Presentable\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A `respoke.Connection` always belongs to an Endpoint.\n\t *\n\t * There is a distinction between Endpoint and Connection because an Endpoint can be authenticated\n\t * from multiple devices, browsers, or browser tabs. Each of these separate authentications is a Connection.\n\t * A Client can choose to interact with connections of the same endpoint in different ways.\n\t *\n\t * @constructor\n\t * @class respoke.Connection\n\t * @augments respoke.Presentable\n\t * @param {object} params\n\t * @param {string} params.id\n\t * @returns {respoke.Connection}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Connection\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.Presentable(params);\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name client\n\t     * @type {respoke.Client}\n\t     * @private\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t\n\t    /**\n\t     * The connection id.\n\t     * @memberof! respoke.Connection\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = that.id || that.connectionId;\n\t    if (!that.id) {\n\t        throw new Error(\"Can't make a connection without an id.\");\n\t    }\n\t    delete that.instanceId;\n\t    delete that.connectionId;\n\t\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.Connection\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Connection';\n\t\n\t    /**\n\t     * Send a message to this connection of an endpoint. If the endpoint has multiple connections,\n\t     * it will only receive the message at this connection.\n\t     *\n\t     *     connection.sendMessage({\n\t     *         message: \"PJ, put that PBR down!\"\n\t     *     });\n\t     *\n\t     * **Using callbacks** will disable promises.\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.message\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        params = params || {};\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().sendMessage(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new Call for a voice and/or video call this particular connection, only. The Call cannot be answered\n\t     * by another connection of this Endpoint.\n\t     *\n\t     *     connection.startCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {RTCConstraints} [params.constraints]\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote video attached to it.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startCall = function (params) {\n\t        params = params || {};\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new audio-only call.\n\t     *\n\t     *     connection.startAudioCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startAudioCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startAudioCall = function (params) {\n\t        params = params || {};\n\t        params.connectionId = that.id;\n\t        params.constraints = {\n\t            video: false,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        };\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new call with audio and video.\n\t     *\n\t     *     connection.startVideoCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startVideoCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has\n\t     * been hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startVideoCall = function (params) {\n\t        params = params || {};\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new DirectConnection with this particular connection, only. The DirectConnection cannot be answered\n\t     * by another connection of this Endpoint.  This method creates a new Call as well, attaching this\n\t     * DirectConnection to it for the purposes of creating a peer-to-peer link for sending data such as messages to\n\t     * the other endpoint. Information sent through a DirectConnection is not handled by the cloud infrastructure.\n\t     *\n\t     *     connection.startDirectConnection({\n\t     *         onOpen: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startDirectConnection\n\t     * @param {object} params\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n\t     * connection begins. The direct connection will not be open yet.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n\t     * the DirectConnection is open and ready to be used.\n\t     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n\t     * connection.\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n\t     * when the DirectConnection is closed and the two Endpoints are disconnected.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n\t     * through the DirectConnection.\n\t     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n\t     * request for a direct connection and setup begins.\n\t     * @returns {respoke.DirectConnection} The DirectConnection which can be used to send data and messages\n\t     * directly to the other endpoint.\n\t     */\n\t    that.startDirectConnection = function (params) {\n\t        params = params || {};\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startDirectConnection(params);\n\t    };\n\t\n\t    /**\n\t     * Get the Endpoint that this Connection belongs to.\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.getEndpoint\n\t     * @returns {respoke.Endpoint}\n\t     */\n\t    that.getEndpoint = function () {\n\t        return client.getEndpoint({\n\t            id: that.endpointId,\n\t            skipPresence: true\n\t        });\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Connection\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar Q = __webpack_require__(19);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * `respoke.Endpoint`s are users of a Respoke app.\n\t *\n\t * An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.\n\t *\n\t * A Client can interact with endpoints through messages, audio or video calls, or direct connections.\n\t *\n\t * An Endpoint may be authenticated from multiple devices to the same app (each of\n\t * which is represented by a Connection).\n\t *\n\t *\n\t * @constructor\n\t * @class respoke.Endpoint\n\t * @augments respoke.Presentable\n\t * @param {object} params\n\t * @param {string} params.id\n\t * @param {string} params.instanceId\n\t * @param {respoke.client.resolvePresence} [params.resolvePresence] An optional function for resolving presence for an endpoint.\n\t * @returns {respoke.Endpoint}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Endpoint\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.Presentable(params);\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name client\n\t     * @type {respoke.Client}\n\t     * @private\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name signalingChannel\n\t     * @type {respoke.SignalingChannel}\n\t     * @private\n\t     */\n\t    var signalingChannel = params.signalingChannel;\n\t\n\t    var addCall = params.addCall;\n\t\n\t    delete that.signalingChannel;\n\t    delete that.instanceId;\n\t    delete that.connectionId;\n\t    delete that.addCall;\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.Endpoint\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Endpoint';\n\t    /**\n\t     * A direct connection to this endpoint. This can be used to send direct messages.\n\t     * @memberof! respoke.Endpoint\n\t     * @name directConnection\n\t     * @type {respoke.DirectConnection}\n\t     */\n\t    that.directConnection = null;\n\t\n\t    /**\n\t     * Array of connections for this endpoint.\n\t     * @memberof! respoke.Endpoint\n\t     * @name connections\n\t     * @type {Array<respoke.Connection>}\n\t     */\n\t    that.connections = [];\n\t    client.listen('disconnect', function disconnectHandler() {\n\t        that.connections = [];\n\t    });\n\t\n\t    var resolveEndpointPresence = params.resolveEndpointPresence;\n\t    delete that.resolveEndpointPresence;\n\t\n\t    /**\n\t     * Send a message to the endpoint through the infrastructure.\n\t     *\n\t     *    endpoint.sendMessage({\n\t     *        message: \"wassuuuuup\"\n\t     *    });\n\t     *\n\t     * **Using callbacks** will disable promises.\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.message\n\t     * @param {string} [params.connectionId]\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this method\n\t     * only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        params = params || {};\n\t\n\t        promise = signalingChannel.sendMessage({\n\t            connectionId: params.connectionId,\n\t            message: params.message,\n\t            recipient: that\n\t        });\n\t\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Create a new audio-only call.\n\t     *\n\t     *     endpoint.startAudioCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startAudioCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startAudioCall = function (params) {\n\t        params = params || {};\n\t        params.constraints = {\n\t            video: false,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        };\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new call with audio and video.\n\t     *\n\t     *     endpoint.startVideoCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startVideoCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startVideoCall = function (params) {\n\t        params = params || {};\n\t        params.constraints = {\n\t            video: true,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        };\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new call.\n\t     *\n\t     *     endpoint.startCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {RTCConstraints} [params.constraints]\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote video attached to it.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startCall = function (params) {\n\t        var call = null;\n\t        params = params || {};\n\t\n\t        log.debug('Endpoint.call');\n\t        client.verifyConnected();\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        if (!that.id) {\n\t            log.error(\"Can't start a call without endpoint ID!\");\n\t            return;\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = that;\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = that;\n\t\n\t            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            signalParams.signalType = 'answer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.connectionId = signalParams.call.connectionId;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalParams.recipient = that;\n\t            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send connected.\", err.message, err.stack);\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalModify = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send modify.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n\t                log.warn(\"Couldn't send candidate.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            log.debug(\"Sending debug report\", signalParams.report);\n\t            signalingChannel.sendReport(signalParams).done(null, function errorHandler(err) {\n\t                log.warn(\"Couldn't debug report.\", err.message, err.stack);\n\t            });\n\t        };\n\t\n\t        params.signalingChannel = signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({call: call});\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\n\t     * it for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\n\t     * Information sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\n\t     * a direct connection open, this method will resolve the promise with that direct connection instead of\n\t     * attempting to create a new one.\n\t     *\n\t     *     endpoint.startDirectConnection({\n\t     *         onOpen: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startDirectConnection\n\t     * @param {object} params\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n\t     * connection begins. The direct connection will not be open yet.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n\t     * the DirectConnection is open and ready to be used.\n\t     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n\t     * connection.\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n\t     * when the DirectConnection is closed and the two Endpoints are disconnected.\n\t     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n\t     * request for a direct connection and setup begins.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n\t     * through the DirectConnection.\n\t     * @param {string} [params.connectionId] - An optional connection ID to use for this connection. This allows\n\t     * the connection to be made to a specific instance of an endpoint in the case that the same endpoint is logged\n\t     * in from multiple locations.\n\t     * @returns {respoke.DirectConnection} The DirectConnection which can be used to send data and messages\n\t     * directly to the other endpoint.\n\t     */\n\t    that.startDirectConnection = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        var call;\n\t\n\t        try {\n\t            client.verifyConnected();\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        if (that.directConnection || params.create === false) {\n\t            deferred.resolve(that.directConnection);\n\t            return retVal;\n\t        }\n\t\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        if (!that.id) {\n\t            deferred.reject(new Error(\"Can't start a direct connection without endpoint ID!\"));\n\t            return retVal;\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = that;\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t\n\t            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send connected.\", err.message, err.stack);\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalParams.signalType = 'answer';\n\t            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            signalParams.report.target = 'directConnection';\n\t            log.debug(\"Not sending report\");\n\t            log.debug(signalParams.report);\n\t        };\n\t        params.needDirectConnection = true;\n\t        // Don't include audio in the offer SDP\n\t        params.offerOptions = {\n\t            mandatory: {\n\t                OfferToReceiveAudio: false\n\t            }\n\t        };\n\t\n\t        params.signalingChannel = signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({call: call});\n\t        call.listen('direct-connection', function directConnectionHandler(evt) {\n\t            that.directConnection = evt.directConnection;\n\t            if (params.caller !== true) {\n\t                if (!client.hasListeners('direct-connection') &&\n\t                        !client.hasListeners('direct-connection') &&\n\t                        !call.hasListeners('direct-connection')) {\n\t                    that.directConnection.reject();\n\t                    deferred.reject(new Error(\"Got an incoming direct connection with no handlers to accept it!\"));\n\t                    return;\n\t                }\n\t\n\t                deferred.resolve(that.directConnection);\n\t                that.directConnection.listen('close', function closeHandler(evt) {\n\t                    that.directConnection = undefined;\n\t                }, true);\n\t            }\n\t        }, true);\n\t\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Find the presence out of all known connections with the highest priority (most availability)\n\t     * and set it as the endpoint's resolved presence.\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.resolvePresence\n\t     * @private\n\t     */\n\t    that.resolvePresence = function () {\n\t\n\t        var presenceList = that.connections.map(function (connection) {\n\t            return connection.presence;\n\t        });\n\t\n\t        if (resolveEndpointPresence !== undefined) {\n\t            that.presence = resolveEndpointPresence(presenceList);\n\t        } else {\n\t            var options = ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable'];\n\t            var idList;\n\t\n\t            /*\n\t             * Sort the connections array by the priority of the value of the presence of that\n\t             * connectionId. This will cause the first element in the list to be the id of the\n\t             * session with the highest priority presence so we can access it by the 0 index.\n\t             * TODO: If we don't really care about the sorting and only about the highest priority\n\t             * we could use Array.prototype.every to improve this algorithm.\n\t             */\n\t            idList = that.connections.sort(function sorter(a, b) {\n\t                var indexA = options.indexOf(a.presence);\n\t                var indexB = options.indexOf(b.presence);\n\t                // Move it to the end of the list if it isn't one of our accepted presence values\n\t                indexA = indexA === -1 ? 1000 : indexA;\n\t                indexB = indexB === -1 ? 1000 : indexB;\n\t                return indexA < indexB ? -1 : (indexB < indexA ? 1 : 0);\n\t            });\n\t\n\t            if (idList[0]) {\n\t                that.presence = idList[0].presence;\n\t            } else {\n\t                that.presence = 'unavailable';\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Get the Connection with the specified id. The connection ID is optional if only one connection exists.\n\t     *\n\t     *     var connection = endpoint.getConnection({\n\t     *         connectionId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.getConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} [params.connectionId]\n\t     * @return {respoke.Connection}\n\t     */\n\t    that.getConnection = function (params) {\n\t        var connection = null;\n\t        params = params || {};\n\t        if (that.connections.length === 1 &&\n\t                (!params.connectionId || that.connections[0] === params.connectionId)) {\n\t            return that.connections[0];\n\t        }\n\t\n\t        if (!params || !params.connectionId) {\n\t            throw new Error(\"Can't find a connection without the connectionId.\");\n\t        }\n\t\n\t        that.connections.every(function eachConnection(conn) {\n\t            if (conn.id === params.connectionId) {\n\t                connection = conn;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        return connection;\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Endpoint\n\t/**\n\t * Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\n\t * respoke.Endpoint#message fires.\n\t * @callback respoke.Endpoint.onMessage\n\t * @param {respoke.Event} evt\n\t * @param {respoke.TextMessage} evt.message - the message\n\t * @param {respoke.Endpoint} evt.target\n\t * @param {string} evt.name - the event name\n\t */\n\t/**\n\t * Handle presence notifications from this one Endpoint.  This callback is called every time\n\t * respoke.Endpoint#message fires.\n\t * @callback respoke.Endpoint.onPresence\n\t * @param {respoke.Event} evt\n\t * @param {string|number|object|Array} evt.presence - the Endpoint's presence\n\t * @param {respoke.Endpoint} evt.target\n\t * @param {string} evt.name - the event name\n\t */\n\t /**\n\t * Handle resolving presence for this endpoint\n\t * @callback respoke.Client.resolveEndpointPresence\n\t * @param {Array<object>} connectionPresence\n\t * @returns {object|string|number}\n\t */\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\t/**\n\t * A text message and the information needed to route it.\n\t * @class respoke.TextMessage\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} [params.endpointId] - If sending, endpoint ID of the thing we're sending a message to.\n\t * @param {string} [params.connectionId] - If sending, connection ID of the thing we're sending a message to.\n\t * @param {string} [params.message] - If sending, a message to send\n\t * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n\t * @private\n\t * @returns {respoke.TextMessage}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = {};\n\t\n\t    /**\n\t     * Parse rawMessage and set attributes required for message delivery.\n\t     * @memberof! respoke.TextMessage\n\t     * @method respoke.TextMessage.parse\n\t     * @private\n\t     */\n\t    function parse() {\n\t        if (params.rawMessage) {\n\t            try {\n\t                that.endpointId = params.rawMessage.header.from;\n\t                that.connectionId = params.rawMessage.header.fromConnection;\n\t                that.timestamp = params.rawMessage.header.timestamp;\n\t            } catch (e) {\n\t                throw new Error(e);\n\t            }\n\t            that.message = params.rawMessage.message || params.rawMessage.body;\n\t            if (params.rawMessage.header.channel) {\n\t                that.recipient = params.rawMessage.header.channel;\n\t            }\n\t        } else {\n\t            try {\n\t                that.to = params.endpointId;\n\t                that.toConnection = params.connectionId;\n\t                that.requestConnectionReply = (params.requestConnectionReply === true);\n\t            } catch (e) {\n\t                throw new Error(e);\n\t            }\n\t            that.message = params.message;\n\t        }\n\t    }\n\t\n\t    parse();\n\t    return that;\n\t}; // End respoke.TextMessage\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\t/**\n\t * A signaling message and the information needed to route it.\n\t * @class respoke.SignalingMessage\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} [params.fromEndpoint] - If sending, the endpoint ID of the recipient\n\t * @param {string} [params.fromConnection] - If sending, the connection ID of the recipient\n\t * @param {string} [params.connectionId] - The connectionId of the endpoint whose answer signal has been accepted.\n\t * @param {string} [params.signal] - If sending, a message to send\n\t * @param {respoke.Endpoint} [params.recipient]\n\t * @param {string} [params.signalType]\n\t * @param {string} [params.sessionId] - A globally unique ID to identify this call.\n\t * @param {string} [params.target] - Either 'call' or 'directConnection', TODO remove the need for this.\n\t * @param {string} [params.callerId] - Human readable caller ID. Not implemented.\n\t * @param {RTCSessionDescription} [params.sdp]\n\t * @param {Array<RTCIceCandidate>} [params.iceCandidates]\n\t * @param {object} [params.offering] - Object describing the media we're offering to send the remote party in a more\n\t * usable way than SDP. Not implemented.\n\t * @param {object} [params.requesting] - Object describing the media we're requesting from the remote party in a more\n\t * usable way than SDP. Not implemented.\n\t * @param {string} [params.reason] - Human readable reason for hanging up.\n\t * @param {string} [params.error] - String indicating that a previous signal was malformed or received in the wrong\n\t * state. Not implemented.\n\t * @param {string} [params.status] - \"Ringing\". Not implemented.\n\t * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n\t * @private\n\t * @returns {respoke.SignalingMessage}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = {};\n\t    /**\n\t     * Attributes without which we cannot build a signaling message.\n\t     * @memberof! respoke.SignalingMessage\n\t     * @name required\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var required = ['recipient', 'signalType', 'sessionId', 'target', 'signalId'];\n\t    /**\n\t     * Attributes which we will copy onto the signal if defined.\n\t     * @memberof! respoke.SignalingMessage\n\t     * @name required\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var allowed = [\n\t        'signalType', 'sessionId', 'callerId', 'sessionDescription', 'iceCandidates', 'offering', 'target', 'signalId',\n\t        'requesting', 'reason', 'error', 'status', 'connectionId', 'version'\n\t    ];\n\t\n\t    params.version = '1.0';\n\t\n\t    /**\n\t     * Parse rawMessage and set attributes required for message delivery.\n\t     * @memberof! respoke.SignalingMessage\n\t     * @method respoke.SignalingMessage.parse\n\t     * @private\n\t     */\n\t    function parse() {\n\t        if (params.rawMessage) {\n\t            try {\n\t                that = JSON.parse(params.rawMessage.body); // Incoming message\n\t            } catch (e) {\n\t                that = params.rawMessage.body;\n\t            }\n\t            that.fromType = params.rawMessage.header.fromType;\n\t            that.fromEndpoint = params.rawMessage.header.from;\n\t            that.fromConnection = params.rawMessage.header.fromConnection;\n\t            that.timestamp = params.rawMessage.header.timestamp;\n\t\n\t            if (!that.target) {\n\t                that.target = 'call';\n\t            }\n\t        } else {\n\t            required.forEach(function eachAttr(attr) {\n\t                if (params[attr] === 0 || !params[attr]) {\n\t                    throw new Error(\"Can't build a signaling without \" + attr);\n\t                }\n\t            });\n\t\n\t            allowed.forEach(function eachAttr(attr) {\n\t                if (params[attr] === 0 || params[attr]) {\n\t                    that[attr] = params[attr];\n\t                }\n\t            });\n\t        }\n\t    }\n\t\n\t    parse();\n\t    return that;\n\t}; // End respoke.SignalingMessage\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(19);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A `respoke.Group` represents a collection of endpoints.\n\t *\n\t * There are methods to communicate with the endpoints at the group level and track\n\t * their presence in the group.\n\t *\n\t * @class respoke.Group\n\t * @augments respoke.EventEmitter\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} params.instanceId\n\t * @param {respoke.Group.onJoin} params.onJoin - A callback to receive notifications every time a new\n\t * endpoint has joined the group. This callback does not get called when the client joins the group.\n\t * @param {respoke.Group.onMessage} params.onMessage - A callback to receive messages sent to the group from\n\t * remote endpoints.\n\t * @param {respoke.Group.onLeave} params.onLeave - A callback to receive notifications every time a new\n\t * endpoint has left the group. This callback does not get called when the client leaves the group.\n\t * @returns {respoke.Group}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t\n\t    var that = respoke.EventEmitter(params);\n\t    /**\n\t     * @memberof! respoke.Group\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var client = respoke.getClient(instanceId);\n\t\n\t    if (!that.id) {\n\t        throw new Error(\"Can't create a group without an ID.\");\n\t    }\n\t\n\t    /**\n\t     * Internal reference to the api signaling channel.\n\t     * @memberof! respoke.Group\n\t     * @name signalingChannel\n\t     * @type respoke.SignalingChannel\n\t     * @private\n\t     */\n\t    var signalingChannel = params.signalingChannel;\n\t    delete params.signalingChannel;\n\t\n\t    /**\n\t     * The connections to members of this group.\n\t     * @memberof! respoke.Group\n\t     * @name endpoints\n\t     * @type {array<respoke.Connection>}\n\t     */\n\t    that.connections = [];\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.Group\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Group';\n\t    that.listen('join', params.onJoin);\n\t    /**\n\t     * Indicates that a message has been sent to this group.\n\t     *\n\t     * @event respoke.Group#message\n\t     * @type {respoke.Event}\n\t     * @property {respoke.TextMessage} message\n\t     * @property {string} name - The event name.\n\t     * @property {respoke.Group} target\n\t     */\n\t    that.listen('message', params.onMessage);\n\t    that.listen('leave', params.onLeave);\n\t    client.listen('disconnect', function disconnectHandler() {\n\t        that.connections = [];\n\t    });\n\t\n\t    delete that.instanceId;\n\t    delete that.onMessage;\n\t    delete that.onPresence;\n\t    delete that.onJoin;\n\t    delete that.onLeave;\n\t\n\t    /**\n\t     * Join this group.\n\t     *\n\t     *     group.join().done(function () {\n\t     *         group.sendMessage({\n\t     *             message: \"Hey, ppl! I'm here!\"\n\t     *         });\n\t     *     }, function (err) {\n\t     *         // Couldn't join the group, possibly permissions error\n\t     *     });\n\t     *\n\t     * **Using callbacks** will disable promises.\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.join\n\t     * @return {Promise|undefined}\n\t     * @param {object} params\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @fires respoke.Client#join\n\t     */\n\t    that.join = function () {\n\t        var params = {\n\t            id: that.id\n\t        };\n\t        var promise;\n\t        var deferred;\n\t        var retVal;\n\t\n\t        try {\n\t            validateConnection();\n\t        } catch (err) {\n\t            deferred = Q.defer();\n\t            retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        promise = client.join(params);\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Leave this group. If this method is called multiple times synchronously, it will batch requests and\n\t     * only make one API call to Respoke.\n\t     *\n\t     *     group.leave({\n\t     *         onSuccess: function () {\n\t     *             // good riddance\n\t     *         },\n\t     *         onError: function (err) {\n\t     *             // Couldn't leave the group, possibly a permissions error\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.leave\n\t     * @param {object} params\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @return {Promise|undefined}\n\t     * @fires respoke.Client#leave\n\t     */\n\t    that.leave = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        signalingChannel.leaveGroup({\n\t            groupList: [that.id]\n\t        }).done(function successHandler() {\n\t            /**\n\t             * This event is fired when the client leaves a group.\n\t             * @event respoke.Client#leave\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Group} group\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             * @private\n\t             */\n\t            client.fire('leave', {\n\t                group: that\n\t            });\n\t            that.connections = [];\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject();\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Remove a Connection from a Group. This does not change the status of the remote Endpoint, it only changes the\n\t     * internal representation of the Group membership. This method should only be used internally.\n\t     * @private\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.removeMember\n\t     * @param {object} params\n\t     * @param {string} [params.connectionId] - Endpoint's connection id\n\t     * @fires respoke.Group#leave\n\t     */\n\t    that.removeMember = function (params) {\n\t        params = params || {};\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            return;\n\t        }\n\t\n\t        if (!params.connectionId) {\n\t            throw new Error(\"Can't remove a member to the group without it's Connection id.\");\n\t        }\n\t\n\t        that.connections.every(function eachConnection(conn, index) {\n\t            if (conn.id === params.connectionId) {\n\t                that.connections.splice(index, 1);\n\t\n\t                /**\n\t                 * This event is fired when a member leaves a group the client is a member of.\n\t                 * @event respoke.Group#leave\n\t                 * @type {respoke.Event}\n\t                 * @property {respoke.Connection} connection - The connection that left the group.\n\t                 * @property {string} name - The event name.\n\t                 * @property {respoke.Group} target\n\t                 */\n\t                that.fire('leave', {\n\t                    connection: conn\n\t                });\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Return true if the logged-in user is a member of this group and false if not.\n\t     *\n\t     *     if (group.isJoined()) {\n\t     *         // I'm a member!\n\t     *     } else {\n\t     *         // Maybe join here\n\t     *     }\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.isJoined\n\t     * @returns {boolean}\n\t     */\n\t    that.isJoined = function () {\n\t        // connections array contains some connections and ours is among them.\n\t        return (that.connections.length > 0 && !that.connections.every(function (conn) {\n\t            return conn.id !== client.connectionId;\n\t        }));\n\t    };\n\t\n\t    /**\n\t     * Add a Connection to a group. This does not change the status of the remote Endpoint, it only changes the\n\t     * internal representation of the Group membership. This method should only be used internally.\n\t     * @memberof! respoke.Group\n\t     * @private\n\t     * @method respoke.Group.addMember\n\t     * @param {object} params\n\t     * @param {respoke.Connection} params.connection\n\t     * @fires respoke.Group#join\n\t     */\n\t    that.addMember = function (params) {\n\t        params = params || {};\n\t        var absent;\n\t\n\t        validateConnection();\n\t\n\t        if (!params.connection) {\n\t            throw new Error(\"Can't add a member to the group without it's Connection object.\");\n\t        }\n\t\n\t        absent = that.connections.every(function eachConnection(conn) {\n\t            return (conn.id !== params.connection.id);\n\t        });\n\t\n\t        if (absent) {\n\t            that.connections.push(params.connection);\n\t            if (params.skipEvent) {\n\t                return;\n\t            }\n\t\n\t            /**\n\t             * This event is fired when a member joins a Group that the currently logged-in endpoint is a member\n\t             * of.\n\t             * @event respoke.Group#join\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Connection} connection - The connection that joined the group.\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Group} target\n\t             */\n\t            that.fire('join', {\n\t                connection: params.connection\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Validate that the client is connected to the Respoke infrastructure.\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.validateConnection\n\t     * @private\n\t     */\n\t    function validateConnection() {\n\t        if (!signalingChannel || !signalingChannel.isConnected()) {\n\t            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Validate that the client is a member of this group.\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.validateMembership\n\t     * @private\n\t     */\n\t    function validateMembership() {\n\t        if (!that.isJoined()) {\n\t            throw new Error(\"Not a member of this group anymore.\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     *\n\t     * Send a message to all of the endpoints in the group.\n\t     *\n\t     *      var group = client.getGroup({ id: 'js-enthusiasts'});\n\t     *\n\t     *      group.sendMessage({\n\t     *          message: \"Cat on keyboard\",\n\t     *          onSuccess: function (evt) {\n\t     *              console.log('Message was sent');\n\t     *          }\n\t     *      });\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.message - The message.\n\t     * @param {function} params.onSuccess - Success handler indicating that the message was delivered.\n\t     * @param {function} params.onError - Error handler indicating that the message was not delivered.\n\t     * @returns {Promise}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        params = params || {};\n\t        params.id = that.id;\n\t        var promise;\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            promise = Q.reject(err);\n\t        }\n\t\n\t        return respoke.handlePromise(promise ? promise : signalingChannel.publish(params),\n\t                params.onSuccess, params.onError);\n\t    };\n\t\n\t    /**\n\t     * Get group members\n\t     *\n\t     * Get an array containing the members of the group. Accepts `onSuccess` or `onError` parameters,\n\t     * or a promise.\n\t     *\n\t     *     group.getMembers({\n\t     *         onSuccess: function (members) {\n\t     *             members.forEach(function (member) {\n\t     *                 // do something\n\t     *             });\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.getMembers\n\t     * @param {object} params\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Success handler for this invocation of this method only.\n\t     * @returns {Promise<Array>} A promise to an array of Connections.\n\t     */\n\t    that.getMembers = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        signalingChannel.getGroupMembers({\n\t            id: that.id\n\t        }).done(function successHandler(list) {\n\t            var endpointList = [];\n\t            list.forEach(function eachMember(params) {\n\t                var connection = client.getConnection({\n\t                    endpointId: params.endpointId,\n\t                    connectionId: params.connectionId,\n\t                    skipCreate: true\n\t                });\n\t\n\t                if (!connection) {\n\t                    // Create the connection\n\t                    connection = client.getConnection({\n\t                        endpointId: params.endpointId,\n\t                        connectionId: params.connectionId\n\t                    });\n\t                }\n\t\n\t                if (endpointList.indexOf(params.endpointId) === -1) {\n\t                    endpointList.push(params.endpointId);\n\t                }\n\t                that.addMember({\n\t                    connection: connection,\n\t                    skipEvent: true\n\t                });\n\t            });\n\t\n\t            deferred.resolve(that.connections);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Group\n\t/**\n\t * Receive notification that an endpoint has joined this group. This callback is called everytime\n\t * respoke.Group#join is fired.\n\t * @callback respoke.Group.onJoin\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Connection} evt.connection\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Group} evt.target\n\t */\n\t/**\n\t * Receive notification that an endpoint has left this group. This callback is called everytime\n\t * respoke.Group#leave is fired.\n\t * @callback respoke.Group.onLeave\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Connection} evt.connection\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Group} evt.target\n\t */\n\t/**\n\t * Receive notification that a message has been received to a group. This callback is called every time\n\t * respoke.Group#message is fired.\n\t * @callback respoke.Group.onMessage\n\t * @param {respoke.Event} evt\n\t * @param {respoke.TextMessage} evt.message\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Group} evt.target\n\t */\n\t/**\n\t * Get a list of the Connections which are members of this Group.\n\t * @callback respoke.Group.connectionsHandler\n\t * @param {Array<respoke.Connection>} connections\n\t */\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar Q = __webpack_require__(19);\n\tvar io = __webpack_require__(20);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * Returns a timestamp, measured in milliseconds.\n\t *\n\t * This method will use high resolution time, if available. Otherwise it falls back to just\n\t * using the wall clock.\n\t *\n\t * @return {number} Number of milliseconds that have passed since some point in the past.\n\t * @private\n\t */\n\tvar now;\n\tvar performance;\n\tif (performance && performance.now) {\n\t    now = performance.now.bind(performance);\n\t} else if (Date.now) {\n\t    now = Date.now.bind(Date);\n\t} else {\n\t    now = function () {\n\t        return new Date().getTime();\n\t    };\n\t}\n\t\n\t/**\n\t * Container for holding requests that are currently waiting on responses.\n\t * @returns {PendingRequests}\n\t * @private\n\t * @constructor\n\t */\n\tvar PendingRequests = function () {\n\t    /**\n\t     * Pending requests.\n\t     * @private\n\t     * @type {Array}\n\t     */\n\t    var contents = [];\n\t    /**\n\t     * Counter to provide the next id.\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var counter = 0;\n\t    var that = {};\n\t\n\t    /**\n\t     * Add a new pending request.\n\t     *\n\t     * @memberof PendingRequests\n\t     * @param obj\n\t     * @returns {*} The key to use for the `remove` method.\n\t     */\n\t    that.add = function (obj) {\n\t        contents[counter] = obj;\n\t        counter++;\n\t        return counter;\n\t    };\n\t\n\t    /**\n\t     * Remove a pending request.\n\t     *\n\t     * @param {*} key Key returned from `add` method.\n\t     */\n\t    that.remove = function (key) {\n\t        delete contents[key];\n\t    };\n\t\n\t    /**\n\t     * Disposes of any currently pending requests, synchronously invoking the provided function on\n\t     * each.\n\t     *\n\t     * @param {function} [fn] Callback for pending requests.\n\t     */\n\t    that.reset = function (fn) {\n\t        if (fn) {\n\t            contents.forEach(fn);\n\t        }\n\t        contents = [];\n\t    };\n\t\n\t    return that;\n\t};\n\t\n\t/**\n\t * The purpose of this class is to make a method call for each API call\n\t * to the backend REST interface.  This class takes care of App authentication, websocket connection,\n\t * Endpoint authentication, and all App interactions thereafter.  Almost all methods return a Promise.\n\t * @class respoke.SignalingChannel\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @private\n\t * @returns {respoke.SignalingChannel}\n\t */\n\tmodule.exports = function (params) {\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name className\n\t     * @type {string}\n\t     * @private\n\t     */\n\t    that.className = 'respoke.SignalingChannel';\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.Client}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name socket\n\t     * @private\n\t     * @type {Socket.io.Socket}\n\t     */\n\t    var socket = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name clientSettings\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var clientSettings = params.clientSettings;\n\t    delete that.clientSettings;\n\t    clientSettings.baseURL = clientSettings.baseURL || 'https://api.respoke.io';\n\t    /**\n\t     * A map to avoid duplicate endpoint presence registrations.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name presenceRegistered\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var presenceRegistered = {};\n\t    /**\n\t     * A reference to the private function Client.actuallyConnect that gets set in SignalingChannel.open() so we\n\t     * don't have to make it public.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name actuallyConnect\n\t     * @private\n\t     * @type {function}\n\t     */\n\t    var actuallyConnect = null;\n\t    /**\n\t     * Set of promises for any pending requests on the WebSocket.\n\t     * @private\n\t     * @type {PendingRequests}\n\t     */\n\t    var pendingRequests = PendingRequests();\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name reconnectTimeout\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var reconnectTimeout = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name maxReconnectTimeout\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var maxReconnectTimeout = 5 * 60 * 1000;\n\t    /**\n\t     * Rejects a message if the body size is greater than this. It is enforced servcer side, so changing this\n\t     * won't make the bodySizeLimit any bigger, this just gives you a senseable error if it's too big.\n\t     * @memberof! respoke.signalingChannel\n\t     * @name bodySizeLimit\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var bodySizeLimit = 20000;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name appId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var appId = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name endpointId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var endpointId = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name token\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var token = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name appToken\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var appToken = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name xhr\n\t     * @private\n\t     * @type {XMLHttpRequest}\n\t     */\n\t    var xhr = new XMLHttpRequest();\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name routingMethods\n\t     * @private\n\t     * @type {object}\n\t     * @desc The methods contained in this object are statically defined methods that are called by constructing\n\t     * their names dynamically. 'do' + $className + $signalType == 'doCallOffer', et. al.\n\t     */\n\t    var routingMethods = {};\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name handlerQueue\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var handlerQueue = {\n\t        'message': [],\n\t        'signal': [],\n\t        'presence': []\n\t    };\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name errors\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var errors = {\n\t        400: \"Can't perform this action: missing or invalid parameters.\",\n\t        401: \"Can't perform this action: not authenticated.\",\n\t        403: \"Can't perform this action: not authorized.\",\n\t        404: \"Item not found.\",\n\t        409: \"Can't perform this action: item in the wrong state.\",\n\t        429: \"API rate limit was exceeded.\",\n\t        500: \"Can't perform this action: server problem.\"\n\t    };\n\t\n\t    /**\n\t     * Indicate whether the signaling channel has a valid connection to Respoke.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.isConnected\n\t     * @return {boolean}\n\t     */\n\t    that.isConnected = function () {\n\t        return !!(socket && socket.socket.connected);\n\t    };\n\t\n\t    /**\n\t     * Indicate whether the signaling channel is currently waiting on a websocket to connect.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.isConnecting\n\t     * @private\n\t     * @return {boolean}\n\t     */\n\t    function isConnecting() {\n\t        return !!(socket && socket.socket.connecting);\n\t    }\n\t\n\t    /**\n\t     * Get the call debug preference.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.isSendingReport\n\t     * @private\n\t     * @return {boolean}\n\t     */\n\t    that.isSendingReport = function (params) {\n\t        return  clientSettings.enableCallDebugReport;\n\t    };\n\t\n\t    /**\n\t     * Open a connection to the REST API and validate the app, creating a session token.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.open\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} [params.token] - The Endpoint's auth token\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @return {Promise}\n\t     */\n\t    that.open = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug('SignalingChannel.open', params, clientSettings);\n\t        token = params.token || token;\n\t        actuallyConnect = typeof params.actuallyConnect === 'function' ? params.actuallyConnect : actuallyConnect;\n\t\n\t        Q.fcall(function tokenPromise() {\n\t            if (clientSettings.developmentMode === true && clientSettings.appId && params.endpointId) {\n\t                return that.getToken({\n\t                    appId: clientSettings.appId,\n\t                    endpointId: params.endpointId\n\t                });\n\t            }\n\t            return null;\n\t        }).then(function successHandler(newToken) {\n\t            token = newToken || token;\n\t            return doOpen({token: token});\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t            log.debug('client', client);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Get a developer mode token for an endpoint. App must be in developer mode.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getToken\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @return {Promise<String>}\n\t     */\n\t    that.getToken = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug('SignalingChannel.getToken', params);\n\t\n\t        var callParams = {\n\t            path: '/v1/tokens',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                appId: clientSettings.appId,\n\t                endpointId: params.endpointId,\n\t                ttl: 60 * 60 * 6\n\t            }\n\t        };\n\t\n\t        call(callParams).done(function (response) {\n\t            if (response.code === 200 && response.result && response.result.tokenId) {\n\t                token = response.result.tokenId;\n\t                deferred.resolve(response.result.tokenId);\n\t                return;\n\t            }\n\t            deferred.reject(new Error(\"Couldn't get a developer mode token: \" + response.error));\n\t        }, function (err) {\n\t            deferred.reject(new Error(\"Couldn't get a developer mode token: \" + err));\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Open a connection to the REST API and validate the app, creating a session token.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.doOpen\n\t     * @param {object} params\n\t     * @param {string} params.token - The Endpoint's auth token\n\t     * @return {Promise}\n\t     * @private\n\t     */\n\t    function doOpen(params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug('SignalingChannel.doOpen', params);\n\t\n\t        if (!params.token) {\n\t            deferred.reject(new Error(\"Can't open connection to Respoke without a token.\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        call({\n\t            path: '/v1/session-tokens',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                tokenId: params.token\n\t            }\n\t        }).done(function (response) {\n\t            if (response.code === 200) {\n\t                appToken = response.result.token;\n\t                deferred.resolve();\n\t                log.debug(\"Signaling connection open to\", clientSettings.baseURL);\n\t            } else {\n\t                deferred.reject(new Error(\"Couldn't authenticate app: \" + response.error));\n\t            }\n\t        }, function (err) {\n\t            log.error(\"Network call failed:\", err.message);\n\t            deferred.reject(new Error(\"Couldn't authenticate app: \" + err.message));\n\t        });\n\t\n\t        return deferred.promise;\n\t    }\n\t\n\t    /**\n\t     * Close a connection to the REST API. Invalidate the session token.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.close\n\t     * @private\n\t     * @param {object} params\n\t     * @return {Promise}\n\t     */\n\t    that.close = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t\n\t        wsCall({\n\t            path: '/v1/connections/%s/',\n\t            httpMethod: 'DELETE',\n\t            objectId: client.endpointId\n\t        }).fin(function finallyHandler() {\n\t            return call({\n\t                path: '/v1/session-tokens',\n\t                httpMethod: 'DELETE'\n\t            });\n\t        }).fin(function finallyHandler() {\n\t            if (socket) {\n\t                socket.removeAllListeners();\n\t                socket.disconnect();\n\t            }\n\t            deferred.resolve();\n\t        }).done();\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Generate and send a presence message representing the client's current status. This triggers\n\t     * the server to send the client's endpoint's presence.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendPresence\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=available]\n\t     * @param {string} [params.status] - Non-enumeration human-readable status.\n\t     * @param {string} [params.show] - I can't remember what this is.\n\t     * @returns {Promise}\n\t     */\n\t    that.sendPresence = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug(\"Signaling sendPresence\");\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/presence',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                'presence': {\n\t                    show: params.show,\n\t                    'status': params.status,\n\t                    type: params.presence || \"available\"\n\t                }\n\t            }\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Get or create a group in the infrastructure.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getGroup\n\t     * @private\n\t     * @returns {Promise<respoke.Group>}\n\t     * @param {object} params\n\t     * @param {string} name\n\t     */\n\t    that.getGroup = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug('signalingChannel.getGroup');\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            httpMethod: 'POST',\n\t            path: '/v1/channels/',\n\t            parameters: {\n\t                name: params.name\n\t            }\n\t        }).then(function successHandler(group) {\n\t            deferred.resolve(group);\n\t        }, function errorHandler(err) {\n\t            // Group was already created, just return back the same params we were given.\n\t            deferred.resolve({id: params.name});\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Leave a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n\t     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n\t     * issued. The same instance of Promise is returned each time.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @private\n\t     * @method respoke.SignalingChannel.leaveGroup\n\t     * @returns {Promise}\n\t     * @param {object} params\n\t     * @param {array} params.groupList\n\t     */\n\t    that.leaveGroup = (function () {\n\t        var groups = {};\n\t        var deferred = Q.defer();\n\t\n\t        return function (params) {\n\t            params = params || {};\n\t            params.groupList = params.groupList || [];\n\t\n\t            var toRun = (Object.keys(groups).length === 0);\n\t\n\t            if (!that.isConnected()) {\n\t                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t                return deferred.promise;\n\t            }\n\t\n\t            params.groupList.forEach(function (id) {\n\t                if (typeof id === 'string') {\n\t                    groups[id] = true;\n\t                }\n\t            });\n\t\n\t            if (!toRun) {\n\t                return deferred.promise;\n\t            }\n\t\n\t            setTimeout(function () {\n\t                // restart accumulation\n\t                var groupList = Object.keys(groups);\n\t                groups = {};\n\t                var saveDeferred = deferred;\n\t                deferred = Q.defer();\n\t\n\t                if (groupList.length === 0) {\n\t                    saveDeferred.resolve();\n\t                    return;\n\t                }\n\t\n\t                wsCall({\n\t                    path: '/v1/groups/',\n\t                    parameters: {\n\t                        groups: groupList\n\t                    },\n\t                    httpMethod: 'DELETE'\n\t                }).done(function successHandler() {\n\t                    saveDeferred.resolve();\n\t                }, function errorHandler(err) {\n\t                    saveDeferred.reject(err);\n\t                });\n\t            });\n\t            return deferred.promise;\n\t        };\n\t    })();\n\t\n\t    /**\n\t     * Join a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n\t     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n\t     * issued. The same instance of Promise is returned each time.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.joinGroup\n\t     * @private\n\t     * @returns {Promise}\n\t     * @param {object} params\n\t     * @param {array} params.groupList\n\t     */\n\t    that.joinGroup = (function () {\n\t        var groups = {};\n\t        var deferred = Q.defer();\n\t\n\t        return function (params) {\n\t            params = params || {};\n\t            params.groupList = params.groupList || [];\n\t\n\t            var toRun = (Object.keys(groups).length === 0);\n\t\n\t            if (!that.isConnected()) {\n\t                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t                return deferred.promise;\n\t            }\n\t\n\t            params.groupList.forEach(function (id) {\n\t                if (typeof id === 'string') {\n\t                    groups[id] = true;\n\t                }\n\t            });\n\t\n\t            if (!toRun) {\n\t                return deferred.promise;\n\t            }\n\t\n\t            setTimeout(function () {\n\t                // restart accumulation\n\t                var groupList = Object.keys(groups);\n\t                groups = {};\n\t                var saveDeferred = deferred;\n\t                deferred = Q.defer();\n\t\n\t                if (groupList.length === 0) {\n\t                    saveDeferred.resolve();\n\t                    return;\n\t                }\n\t\n\t                wsCall({\n\t                    path: '/v1/groups/',\n\t                    parameters: {\n\t                        groups: groupList\n\t                    },\n\t                    httpMethod: 'POST'\n\t                }).done(function successHandler() {\n\t                    saveDeferred.resolve();\n\t                }, function errorHandler(err) {\n\t                    saveDeferred.reject(err);\n\t                });\n\t            });\n\t            return deferred.promise;\n\t        };\n\t    })();\n\t\n\t    /**\n\t     * Publish a message to a group.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @private\n\t     * @method respoke.SignalingChannel.publish\n\t     * @returns {Promise}\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     * @param {string} params.message\n\t     */\n\t    that.publish = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var message = respoke.TextMessage({\n\t            endpointId: params.id,\n\t            message: params.message\n\t        });\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/channels/%s/publish/',\n\t            objectId: params.id,\n\t            httpMethod: 'POST',\n\t            parameters: message\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Register as an observer of presence for the specified endpoint ids. In order to aggregate subsequent repeated\n\t     * requests, this function, when called synchronously, will continue to accumulate endpoint ids until the next\n\t     * tick of the event loop, when the request will be issued. The same instance of Promise is returned each time.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.registerPresence\n\t     * @private\n\t     * @param {object} params\n\t     * @param {Array<string>} params.endpointList\n\t     * @returns {Promise}\n\t     */\n\t    that.registerPresence = (function () {\n\t        var endpoints = {};\n\t        var deferred = Q.defer();\n\t\n\t        return function (params) {\n\t            params = params || {};\n\t            params.endpointList = params.endpointList || [];\n\t            var toRun = (Object.keys(endpoints).length === 0);\n\t\n\t            if (!that.isConnected()) {\n\t                return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            }\n\t\n\t            params.endpointList.forEach(function (ep) {\n\t                if (typeof ep === 'string' && presenceRegistered[ep] !== true) {\n\t                    endpoints[ep] = true;\n\t                }\n\t            });\n\t\n\t            if (!toRun) {\n\t                return deferred.promise;\n\t            }\n\t\n\t            setTimeout(function () {\n\t                // restart accumulation\n\t                var endpointList = Object.keys(endpoints);\n\t                endpoints = {};\n\t                var saveDeferred = deferred;\n\t                deferred = Q.defer();\n\t\n\t                if (endpointList.length === 0) {\n\t                    saveDeferred.resolve();\n\t                    return;\n\t                }\n\t\n\t                wsCall({\n\t                    httpMethod: 'POST',\n\t                    path: '/v1/presenceobservers',\n\t                    parameters: {\n\t                        endpointList: endpointList\n\t                    }\n\t                }).done(function successHandler() {\n\t                    params.endpointList.forEach(function eachId(id) {\n\t                        presenceRegistered[id] = true;\n\t                    });\n\t                    saveDeferred.resolve();\n\t                }, function (err) {\n\t                    saveDeferred.reject(err);\n\t                });\n\t            // We could even add a tiny delay like 10ms if we want to get more conservative and\n\t            // catch asychronous calls to client.getEndpoint() and other methods which call\n\t            // this method.\n\t            });\n\t\n\t            return deferred.promise;\n\t        }\n\t    })();\n\t\n\t    /**\n\t     * Join a group.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getGroupMembers\n\t     * @private\n\t     * @returns {Promise<Array>}\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     */\n\t    that.getGroupMembers = function (params) {\n\t        var deferred = Q.defer();\n\t        var promise;\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!params.id) {\n\t            deferred.reject(new Error(\"Can't get group's endpoints without group ID.\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        promise = wsCall({\n\t            path: '/v1/channels/%s/subscribers/',\n\t            objectId: params.id,\n\t            httpMethod: 'GET'\n\t        });\n\t\n\t        promise.done(function successHandler(list) {\n\t            list.forEach(function eachSubscriber(params) {\n\t                presenceRegistered[params.endpointId] = true;\n\t            });\n\t        });\n\t        return promise;\n\t    };\n\t\n\t    /**\n\t     * Send a chat message.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendMessage\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.SignalingMessage} params.message - The string text message to send.\n\t     * @param {respoke.Endpoint} params.recipient\n\t     * @param {string} [params.connectionId]\n\t     * @returns {Promise}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var message = respoke.TextMessage({\n\t            endpointId: params.recipient.id,\n\t            connectionId: params.connectionId,\n\t            message: params.message\n\t        });\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/messages',\n\t            httpMethod: 'POST',\n\t            parameters: message\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Send an ACK signal to acknowlege reception of a signal.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendACK\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.SignalingMessage} params.signal\n\t     * @return {Promise}\n\t     */\n\t    that.sendACK = function (params) {\n\t        var endpoint;\n\t        params = params || {};\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        if (!params.signal) {\n\t            return Q.reject(new Error(\"Can't send ACK, no signal was given.\"));\n\t        }\n\t\n\t        endpoint = client.getEndpoint({\n\t            id: params.signal.fromEndpoint,\n\t            skipPresence: true\n\t        });\n\t        if (!endpoint) {\n\t            return Q.reject(new Error(\"Can't send ACK, can't get endpoint.\"));\n\t        }\n\t\n\t        return that.sendSignal({\n\t            recipient: endpoint,\n\t            signalType: 'ack',\n\t            signalId: params.signal.signalId,\n\t            sessionId: params.signal.sessionId,\n\t            target: params.signal.target,\n\t            ackedSignalType: params.signal.signalType\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Send a signaling message.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendSignal\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Call} [params.call] - For getting the sessionId & connectionId. Not required for 'ack'.\n\t     * @return {Promise}\n\t     */\n\t    that.sendSignal = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var signal;\n\t        var to;\n\t        var toConnection;\n\t        var toType;\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (params.call) {\n\t            params.sessionId = params.call.id;\n\t            if (params.call.connectionId) { // the recipient's connectionId\n\t                params.connectionId = params.call.connectionId;\n\t            }\n\t        }\n\t\n\t        to = params.recipient.id;\n\t        toConnection = params.connectionId;\n\t        toType = params.toType || 'web';\n\t\n\t        //hack\n\t        if (params.signalType === 'iceCandidates' && window.webrtcDetectedType === 'plugin') {\n\t            var keys = ['candidate', 'sdpMLineIndex', 'sdpMid'];\n\t\n\t            var candidate = {};\n\t\n\t            keys.forEach(function(key){\n\t                candidate[key] = params.candidate[key];\n\t            });\n\t\n\t            params.candidate = candidate;\n\t\n\t            var iceCandidates = [];\n\t\n\t            params.iceCandidates.forEach(function(jsapiObject){\n\t                var ic = {};\n\t                keys.forEach(function(key){\n\t                    ic[key] = jsapiObject[key];\n\t                });\n\t                iceCandidates.push(ic);\n\t            });\n\t\n\t            params.iceCandidates = iceCandidates;\n\t\n\t        }\n\t\n\t        try {\n\t            params.signalId = respoke.makeGUID();\n\t            // This will strip off non-signaling attributes.\n\t            signal = respoke.SignalingMessage(params);\n\t        } catch (e) {\n\t            deferred.reject(e);\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/signaling',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                signal: JSON.stringify(signal),\n\t                to: to,\n\t                toConnection: toConnection,\n\t                toType: toType\n\t            }\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Send an ICE candidate.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendCandidate\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} [params.connectionId]\n\t     * @param {Array<RTCIceCandidate>} params.iceCandidates - An array of ICE candidate.\n\t     * @return {Promise}\n\t     */\n\t    that.sendCandidate = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'iceCandidates';\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send an SDP.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendSDP\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} [params.connectionId]\n\t     * @param {RTCSessionDescription} params.sessionDescription - An SDP to JSONify and send.\n\t     * @return {Promise}\n\t     */\n\t    that.sendSDP = function (params) {\n\t        params = params || {};\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        if (['offer', 'answer'].indexOf(params.signalType) === -1) {\n\t            return Q.reject(\"Not an SDP type signal.\");\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send a call report to the cloud infrastructure.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendReport\n\t     * @private\n\t     * @param {object} params\n\t     * @todo TODO document the params.\n\t     * @return {Promise}\n\t     */\n\t    that.sendReport = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var message = {\n\t            debugData: params\n\t        };\n\t\n\t        if (!clientSettings.enableCallDebugReport) {\n\t            log.debug('not sending call debugs - disabled');\n\t            deferred.resolve();\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/call-debugs',\n\t            httpMethod: 'POST',\n\t            parameters: message\n\t        }).done(function () {\n\t            deferred.resolve();\n\t        }, function (err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Send a message hanging up the WebRTC session.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendHangup\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} [params.connectionId]\n\t     * @param {string} params.reason - The reason the session is being hung up.\n\t     * @return {Promise}\n\t     */\n\t    that.sendHangup = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'bye';\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send a message to all connection ids indicating we have negotiated a call with one connection.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendConnected\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @return {Promise}\n\t     */\n\t    that.sendConnected = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'connected';\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send a message to the remote party indicating a desire to renegotiate media.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendModify\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} params.action - The state of the modify request, one of: 'initiate', 'accept', 'reject'\n\t     * @return {Promise}\n\t     */\n\t    that.sendModify = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'modify';\n\t\n\t        if (['initiate', 'accept', 'reject'].indexOf(params.action) === -1) {\n\t            return Q.reject(\"No valid action in modify signal.\");\n\t        }\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Uppercase the first letter of the word.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.firstUpper\n\t     * @private\n\t     */\n\t    function firstUpper(str) {\n\t        return str[0].toUpperCase() + str.slice(1);\n\t    }\n\t\n\t    /**\n\t     * Route different types of signaling messages via events.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routeSignal\n\t     * @private\n\t     * @param {respoke.SignalingMessage} message - A message to route\n\t     * @fires respoke.Call#offer\n\t     * @fires respoke.Call#connected\n\t     * @fires respoke.Call#answer\n\t     * @fires respoke.Call#iceCandidates\n\t     * @fires respoke.Call#hangup\n\t     * @fires respoke.DirectConnection#offer\n\t     * @fires respoke.DirectConnection#connected\n\t     * @fires respoke.DirectConnection#answer\n\t     * @fires respoke.DirectConnection#iceCandidates\n\t     * @fires respoke.DirectConnection#hangup\n\t     */\n\t    that.routeSignal = function (signal) {\n\t        var target = null;\n\t        var method = 'do';\n\t\n\t        if (signal.signalType !== 'iceCandidates') { // Too many of these!\n\t            log.debug(signal.signalType, signal);\n\t        }\n\t\n\t        if (signal.target === undefined) {\n\t            throw new Error(\"target undefined\");\n\t        }\n\t\n\t        // Only create if this signal is an offer.\n\t        Q.fcall(function makePromise() {\n\t            var endpoint;\n\t            /*\n\t             * This will return calls regardless of whether they are associated\n\t             * with a direct connection or not, and it will create a call if no\n\t             * call is found and this signal is an offer. Direct connections get\n\t             * created in the next step.\n\t             */\n\t            target = client.getCall({\n\t                id: signal.sessionId,\n\t                endpointId: signal.fromEndpoint,\n\t                fromType: signal.fromType,\n\t                create: (signal.target === 'call' && signal.signalType === 'offer')\n\t            });\n\t            if (target) {\n\t                return target;\n\t            }\n\t\n\t            if (signal.target === 'directConnection') {\n\t                // return a promise\n\t                endpoint = client.getEndpoint({\n\t                    id: signal.fromEndpoint,\n\t                    skipPresence: true\n\t                });\n\t\n\t                if (endpoint.directConnection && endpoint.directConnection.call.id === signal.sessionId) {\n\t                    return endpoint.directConnection;\n\t                }\n\t\n\t                return endpoint.startDirectConnection({\n\t                    id: signal.sessionId,\n\t                    create: (signal.signalType === 'offer'),\n\t                    caller: (signal.signalType !== 'offer')\n\t                });\n\t            }\n\t        }).done(function successHandler(target) {\n\t            // target might be null, a Call, or a DirectConnection.\n\t            if (target) {\n\t                target = target.call || target;\n\t            }\n\t            if (!target || target.id !== signal.sessionId) {\n\t                // orphaned signal\n\t                log.warn(\"Couldn't associate signal with a call.\", signal);\n\t                return;\n\t            }\n\t\n\t            method += firstUpper(signal.signalType);\n\t            routingMethods[method]({\n\t                call: target,\n\t                signal: signal\n\t            });\n\t        }, null);\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doOffer\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-offer\n\t     */\n\t    routingMethods.doOffer = function (params) {\n\t        params.call.connectionId = params.signal.fromConnection;\n\t        /**\n\t         * @event respoke.Call#signal-offer\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-offer', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doConnected\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-connected\n\t     */\n\t    routingMethods.doConnected = function (params) {\n\t        /**\n\t         * @event respoke.Call#signal-connected\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-connected', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.dModify\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-modify\n\t     */\n\t    routingMethods.doModify = function (params) {\n\t        /**\n\t         * @event respoke.Call#signal-modify\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-modify', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doAnswer\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-answer\n\t     */\n\t    routingMethods.doAnswer = function (params) {\n\t        params.call.connectionId = params.signal.fromConnection;\n\t        /**\n\t         * @event respoke.Call#signal-answer\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-answer', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doIceCandidates\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-icecandidates\n\t     */\n\t    routingMethods.doIceCandidates = function (params) {\n\t        /**\n\t         * @event respoke.Call#signal-icecandidates\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-icecandidates', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doBye\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-hangup\n\t     */\n\t    routingMethods.doBye = function (params) {\n\t        /**\n\t         *  We may receive hangup from one or more parties after connectionId is set if the call is rejected\n\t         *  by a connection that didn't win the call. In this case, we have to ignore the signal since\n\t         *  we are already on a call. TODO: this should really be inside PeerConnection.\n\t         */\n\t        if (params.call.connectionId && params.call.connectionId !== params.signal.fromConnection) {\n\t            return;\n\t        }\n\t        /**\n\t         * @event respoke.Call#signal-hangup\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-hangup', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doUnknown\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     */\n\t    routingMethods.doUnknown = function (params) {\n\t        log.error(\"Don't know what to do with\", params.signal.target, \"msg of unknown type\", params.signal.signalType);\n\t    };\n\t\n\t    /**\n\t     * Add a handler to the connection for messages of different types.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.addHandler\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} params.type - The type of socket message, i. e., 'message', 'presence', 'join'\n\t     * @param {function} params.handler - A function to which to pass the message\n\t     * @todo TODO See if this is necessary anymore\n\t     */\n\t    that.addHandler = function (params) {\n\t        if (socket.socket && socket.socket.open) {\n\t            socket.on(params.type, params.handler);\n\t        } else {\n\t            handlerQueue[params.type].push(params.handler);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Socket handler for pub-sub messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.onPubSub\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     * @fires respoke.Group#message\n\t     * @fires respoke.Client#message\n\t     */\n\t    var onPubSub = function onPubSub(message) {\n\t        var group;\n\t        var groupMessage;\n\t\n\t        if (message.header.from === client.endpointId) {\n\t            return;\n\t        }\n\t\n\t        groupMessage = respoke.TextMessage({\n\t            rawMessage: message\n\t        });\n\t\n\t        group = client.getGroup({id: message.header.channel});\n\t        if (group) {\n\t            /**\n\t             * @event respoke.Group#message\n\t             * @type {respoke.Event}\n\t             * @property {respoke.TextMessage} message\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Group} target\n\t             */\n\t            group.fire('message', {\n\t                message: groupMessage\n\t            });\n\t        }\n\t        /**\n\t         * @event respoke.Client#message\n\t         * @type {respoke.Event}\n\t         * @property {respoke.TextMessage} message\n\t         * @property {respoke.Group} [group] - If the message is to a group we already know about,\n\t         * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n\t         * the group. From that point forward, Group#message will fire when a message is received as well. If\n\t         * group is undefined instead of null, the message is not a group message at all.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Client} target\n\t         */\n\t        client.fire('message', {\n\t            message: groupMessage,\n\t            group: group || null\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Socket handler for join messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.onJoin\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     */\n\t    var onJoin = function onJoin(message) {\n\t        var group;\n\t        var presenceMessage;\n\t        var endpoint;\n\t        var connection;\n\t\n\t        if (message.connectionId === client.connectionId) {\n\t            connection = client.getConnection({connectionId: message.connectionId, endpointId: message.endpointId});\n\t            group = client.getGroup({id: message.header.channel});\n\t            if (!group) {\n\t                group = respoke.Group({\n\t                    id: message.header.channel,\n\t                    instanceId: instanceId,\n\t                    signalingChannel: that\n\t                });\n\t                client.addGroup(group);\n\t            }\n\t            if (!group.isJoined()) {\n\t                group.addMember({connection: connection});\n\t                client.fire('join', {\n\t                    group: group\n\t                });\n\t            }\n\t        } else {\n\t\n\t            endpoint = client.getEndpoint({\n\t                skipPresence: true,\n\t                id: message.endpointId,\n\t                instanceId: instanceId,\n\t                name: message.endpointId\n\t            });\n\t\n\t            // Handle presence not associated with a channel\n\t            if (!connection) {\n\t                endpoint.setPresence({\n\t                    connectionId: message.connectionId\n\t                });\n\t                connection = client.getConnection({\n\t                    connectionId: message.connectionId,\n\t                    endpointId: message.endpointId\n\t                });\n\t            }\n\t\n\t            group = client.getGroup({id: message.header.channel});\n\t\n\t            if (group && connection) {\n\t                group.addMember({connection: connection});\n\t            } else {\n\t                log.error(\"Can't add endpoint to group:\", message, group, endpoint, connection);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Socket handler for leave messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.onLeave\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     */\n\t    var onLeave = function onLeave(message) {\n\t        var group;\n\t        var presenceMessage;\n\t        var endpoint;\n\t        if (message.connectionId === client.connectionId) {\n\t            group = client.getGroup({id: message.header.channel});\n\t            client.fire('leave', {\n\t                group: group\n\t            });\n\t        } else {\n\t\n\t            endpoint = client.getEndpoint({\n\t                skipPresence: true,\n\t                id: message.endpointId\n\t            });\n\t\n\t            endpoint.connections.every(function eachConnection(conn, index) {\n\t                if (conn.id === message.connectionId) {\n\t                    endpoint.connections.splice(index, 1);\n\t                    return false;\n\t                }\n\t                return true;\n\t            });\n\t\n\t            group = client.getGroup({id: message.header.channel});\n\t            group.removeMember({connectionId: message.connectionId});\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Socket handler for presence messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.onMessage\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     * @fires respoke.Endpoint#message\n\t     * @fires respoke.Client#message\n\t     */\n\t    var onMessage = function onMessage(message) {\n\t        var endpoint;\n\t        message = respoke.TextMessage({rawMessage: message});\n\t        if (message.endpointId) {\n\t            endpoint = client.getEndpoint({\n\t                id: message.endpointId,\n\t                skipCreate: true\n\t            });\n\t        }\n\t        if (endpoint) {\n\t            /**\n\t             * @event respoke.Endpoint#message\n\t             * @type {respoke.Event}\n\t             * @property {respoke.TextMessage} message\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Endpoint} target\n\t             */\n\t            endpoint.fire('message', {\n\t                message: message\n\t            });\n\t        }\n\t        /**\n\t         * @event respoke.Client#message\n\t         * @type {respoke.Event}\n\t         * @property {respoke.TextMessage} message\n\t         * @property {respoke.Endpoint} [endpoint] - If the message is from an endpoint we already know about,\n\t         * this will be set. If null, the developer can use client.getEndpoint({id: evt.message.endpointId}) to get\n\t         * the Endpoint. From that point forward, Endpoint#message will fire when a message is received as well.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Client} target\n\t         */\n\t        client.fire('message', {\n\t            endpoint: endpoint || null,\n\t            message: message\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Create a socket handler for the onConnect event with all the right things in scope.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.generateConnectHandler\n\t     * @param {respoke.Client.successHandler} [onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @private\n\t     */\n\t    var generateConnectHandler = function generateConnectHandler(onSuccess, onError) {\n\t        onSuccess = onSuccess || function () {};\n\t        onError = onError || function () {};\n\t        return function onConnect() {\n\t            Object.keys(handlerQueue).forEach(function addEachHandlerType(category) {\n\t                if (!handlerQueue[category]) {\n\t                    return;\n\t                }\n\t\n\t                handlerQueue[category].forEach(function addEachHandler(handler) {\n\t                    socket.on(category, handler);\n\t                });\n\t                handlerQueue[category] = [];\n\t            });\n\t\n\t            wsCall({\n\t                path: '/v1/connections',\n\t                httpMethod: 'POST'\n\t            }).done(function successHandler(res) {\n\t                log.debug('connections result', res);\n\t                client.endpointId = res.endpointId;\n\t                client.connectionId = res.id;\n\t                onSuccess();\n\t            }, onError);\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Socket handler for presence messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.onPresence\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     */\n\t    function onPresence(message) {\n\t        var endpoint;\n\t        var groups;\n\t\n\t        if (message.header.from === client.endpointId) {\n\t            // Skip ourselves\n\t            return;\n\t        }\n\t        log.debug('socket.on presence', message);\n\t\n\t        endpoint = client.getEndpoint({\n\t            skipPresence: true,\n\t            id: message.header.from,\n\t            instanceId: instanceId,\n\t            name: message.header.from,\n\t            connection: message.header.fromConnection\n\t        });\n\t\n\t        endpoint.setPresence({\n\t            connectionId: message.header.fromConnection,\n\t            presence: message.type\n\t        });\n\t\n\t        if (endpoint.getPresence() === 'unavailable') {\n\t            var groups = client.getGroups();\n\t            if (groups) {\n\t                groups.forEach(function eachGroup(group) {\n\t                    group.removeMember({connectionId: message.header.fromConnection});\n\t                });\n\t            }\n\t        }\n\t    }\n\t\n\t    /*\n\t     * On reconnect, start with a reconnect interval of 2000ms. Every time reconnect fails, the interval\n\t     * is doubled up to a maximum of 5 minutes. From then on, it will attempt to reconnect every 5 minutes forever.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.reconnect\n\t     * @private\n\t     */\n\t    function reconnect() {\n\t        appToken = undefined;\n\t        token = undefined;\n\t        reconnectTimeout = (reconnectTimeout === null) ? 2500 : 2 * reconnectTimeout;\n\t\n\t        if (reconnectTimeout > (maxReconnectTimeout)) {\n\t            reconnectTimeout = maxReconnectTimeout;\n\t        }\n\t\n\t        setTimeout(function doReconnect() {\n\t            actuallyConnect().then(function successHandler() {\n\t                reconnectTimeout = null;\n\t                log.debug('socket reconnected');\n\t                return Q.all(client.getGroups().map(function iterGroups(group) {\n\t                    client.join({\n\t                        id: group.id,\n\t                        onMessage: clientSettings.onMessage,\n\t                        onJoin: clientSettings.onJoin,\n\t                        onLeave: clientSettings.onLeave\n\t                    });\n\t                }));\n\t            }).done(function successHandler(user) {\n\t                /**\n\t                 * @event respoke.Client#reconnect\n\t                 * @property {string} name - the event name.\n\t                 * @property {respoke.Client}\n\t                 */\n\t                client.fire('reconnect');\n\t            }, function (err) {\n\t                log.error(\"Couldn't rejoin previous groups.\", err.message, err.stack);\n\t                reconnect();\n\t            });\n\t        }, reconnectTimeout);\n\t    }\n\t\n\t    /**\n\t     * Authenticate to the cloud and call the handler on state change.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.authenticate\n\t     * @private\n\t     * @param {object} params\n\t     * @return {Promise}\n\t     */\n\t    that.authenticate = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var pieces = [];\n\t        var protocol = null;\n\t        var host = null;\n\t        var port = null;\n\t\n\t        if (!appToken) {\n\t            deferred.reject(new Error(\"Can't open a websocket without an app token.\"));\n\t        }\n\t\n\t        pieces = clientSettings.baseURL.split(/:\\/\\//);\n\t        protocol = pieces[0];\n\t        pieces = pieces[1].split(/:/);\n\t        host = pieces[0];\n\t        port = pieces[1];\n\t\n\t        /*\n\t         * Try to connect for 2 seconds before failing.\n\t         * @private\n\t         */\n\t        var connectParams = {\n\t            'connect timeout': 2000,\n\t            'force new connection': true, // Don't try to reuse old connection.\n\t            'sync disconnect on unload': true, // have Socket.io call disconnect() on the browser unload event.\n\t            reconnect: false,\n\t            host: host,\n\t            port: port || '443',\n\t            protocol: protocol,\n\t            secure: (protocol === 'https'),\n\t            query: '__sails_io_sdk_version=0.10.0&app-token=' + appToken\n\t        };\n\t\n\t        if (that.isConnected() || isConnecting()) {\n\t            return;\n\t        }\n\t        socket = io.connect(clientSettings.baseURL, connectParams);\n\t\n\t        socket.on('connect', generateConnectHandler(function onSuccess() {\n\t            deferred.resolve();\n\t        }, function onError(err) {\n\t            deferred.reject(err);\n\t        }));\n\t\n\t        socket.on('join', onJoin);\n\t        socket.on('leave', onLeave);\n\t        socket.on('pubsub', onPubSub);\n\t        socket.on('message', onMessage);\n\t        socket.on('presence', onPresence);\n\t\n\t        // connection timeout\n\t        socket.on('connect_failed', function connectFailedHandler(res) {\n\t            deferred.reject(new Error(\"WebSocket connection failed.\"));\n\t            log.error('Socket.io connect timeout.', res || \"\");\n\t            reconnect();\n\t        });\n\t\n\t        // handshake error, 403\n\t        socket.on('error', function errorHandler(res) {\n\t            log.debug('Socket.io request failed.', res || \"\");\n\t            reconnect();\n\t        });\n\t\n\t        that.addHandler({\n\t            type: 'signal',\n\t            handler: function signalHandler(message) {\n\t                var knownSignals = ['offer', 'answer', 'connected', 'modify', 'iceCandidates', 'bye'];\n\t                var signal = respoke.SignalingMessage({\n\t                    rawMessage: message\n\t                });\n\t\n\t                if (signal.signalType === 'ack') {\n\t                    return;\n\t                }\n\t\n\t                if (!signal.target || !signal.signalType || knownSignals.indexOf(signal.signalType) === -1) {\n\t                    log.error(\"Got malformed signal.\", signal);\n\t                    throw new Error(\"Can't route signal without target or type.\");\n\t                }\n\t\n\t                that.routeSignal(signal);\n\t            }\n\t        });\n\t\n\t        socket.on('disconnect', function onDisconnect() {\n\t            pendingRequests.reset(function (pendingRequest) {\n\t                log.debug('Failing pending requests');\n\t                pendingRequest.reject(new Error(\"WebSocket disconnected\"));\n\t            });\n\t\n\t            /**\n\t             * @event respoke.Client#disconnect\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            client.fire('disconnect');\n\t\n\t            if (clientSettings.reconnect !== true) {\n\t                socket = null;\n\t                return;\n\t            }\n\t            reconnect();\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Get ephemeral TURN credentials.  This method is called whenever a call is either\n\t     * sent or received, prior to creating a PeerConnection\n\t     *\n\t     * @memberof! respoke.SignalingChannel\n\t     * @private\n\t     * @method respoke.SignalingChannel.getTurnCredentials\n\t     * @return {Promise<Array>}\n\t     */\n\t    that.getTurnCredentials = function () {\n\t        var deferred = Q.defer();\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            httpMethod: 'GET',\n\t            path: '/v1/turn'\n\t        }).done(function successHandler(creds) {\n\t            var result = [];\n\t\n\t            if (!creds || !creds.uris) {\n\t                deferred.reject(new Error(\"Turn credentials empty.\"));\n\t                return;\n\t            }\n\t\n\t            creds.uris.forEach(function saveTurnUri(uri) {\n\t                var cred = null;\n\t\n\t                if (!uri) {\n\t                    return;\n\t                }\n\t\n\t                cred = createIceServer(uri, creds.username, creds.password);\n\t                result.push(cred);\n\t            });\n\t\n\t            if (result.length === 0) {\n\t                deferred.reject(new Error(\"Got no TURN credentials.\"));\n\t            }\n\t\n\t            log.debug('TURN creds', result);\n\t            deferred.resolve(result);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Construct a websocket API call and return the formatted response and errors. The 'success'\n\t     * attribute indicates the success or failure of the API call. The 'response' attribute\n\t     * is an associative array constructed by json.decode. The 'error' attriute is a message.\n\t     * If the API call is successful but the server returns invalid JSON, error will be\n\t     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.wsCall\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} params.httpMethod\n\t     * @param {string} params.path\n\t     * @param {string} params.objectId\n\t     * @param {object} params.parameters\n\t     * @return {Promise<object>}\n\t     */\n\t    function wsCall(params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var start = now();\n\t        // Too many of these!\n\t        var logRequest = params.path.indexOf('messages') === -1 && params.path.indexOf('signaling') === -1;\n\t        var request;\n\t        var bodyLength = 0;\n\t        if (params.paramaters) {\n\t            bodyLength = encodeURI(JSON.stringify(params.parameters)).split(/%..|./).length - 1;\n\t        }\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!params) {\n\t            deferred.reject(new Error('No params.'));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!params.path) {\n\t            deferred.reject(new Error('No request path.'));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (bodyLength > bodySizeLimit) {\n\t            deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n\t            return deferred.promise;\n\t        }\n\t\n\t        params.httpMethod = (params.httpMethod || 'get').toLowerCase();\n\t\n\t        if (params.objectId) {\n\t            params.path = params.path.replace(/\\%s/ig, params.objectId);\n\t        }\n\t\n\t        if (logRequest) {\n\t            log.debug('socket request', {\n\t                method: params.httpMethod,\n\t                path: params.path,\n\t                parameters: params.parameters\n\t            });\n\t        }\n\t\n\t        request = {\n\t            method: params.httpMethod,\n\t            path: params.path,\n\t            parameters: params.parameters,\n\t            tries: 0,\n\t            durationMillis: 0\n\t        };\n\t\n\t        request.id = pendingRequests.add(deferred);\n\t\n\t        function handleResponse(response) {\n\t            /*\n\t             * Response:\n\t             *  {\n\t             *      body: {},\n\t             *      headers: {},\n\t             *      statusCode: 200\n\t             *  }\n\t             */\n\t            try {\n\t                response.body = JSON.parse(response.body);\n\t            } catch (e) {\n\t                if (typeof response.body !== 'object') {\n\t                    deferred.reject(new Error(\"Server response could not be parsed!\" + response.body));\n\t                    return;\n\t                }\n\t            }\n\t\n\t            if (response.statusCode === 429) {\n\t                if (request.tries < 3 && deferred.promise.isPending()) {\n\t                    setTimeout(function () {\n\t                        start = now();\n\t                        sendWebsocketRequest(request, handleResponse);\n\t                    }, 1000); // one day this will be response.interval or something\n\t                } else {\n\t                    request.durationMillis = now() - start;\n\t                    pendingRequests.remove(request.id);\n\t                    failWebsocketRequest(request, response.body,\n\t                            \"Too many retries after rate limit exceeded.\", deferred);\n\t                }\n\t                return;\n\t            }\n\t\n\t            request.durationMillis = now() - start;\n\t            pendingRequests.remove(request.id);\n\t\n\t            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(this.status) === -1) {\n\t                failWebsocketRequest(request, response.body,\n\t                        response.body.error || errors[this.status] || \"Unknown error\", deferred);\n\t            } else {\n\t                deferred.resolve(response.body);\n\t            }\n\t\n\t            if (logRequest) {\n\t                log.debug('socket response', {\n\t                    method: request.method,\n\t                    path: request.path,\n\t                    durationMillis: request.durationMillis,\n\t                    response: response.body\n\t                });\n\t            }\n\t        }\n\t\n\t        start = now();\n\t        sendWebsocketRequest(request, handleResponse);\n\t        return deferred.promise;\n\t    }\n\t\n\t    function failWebsocketRequest(request, response, error, deferred) {\n\t        if (response && response.error) {\n\t            deferred.reject(new Error(error + '(' + request.method + ' ' + params.path + ')'));\n\t        } else {\n\t            deferred.resolve(response);\n\t        }\n\t    }\n\t\n\t    function sendWebsocketRequest(request, handleResponse) {\n\t        request.tries += 1;\n\t        socket.emit(request.method, JSON.stringify({\n\t            url: request.path,\n\t            data: request.parameters,\n\t            headers: {'App-Token': appToken}\n\t        }), handleResponse);\n\t    }\n\t\n\t    /**\n\t     * Construct an API call and return the formatted response and errors. The 'success'\n\t     * attribute indicates the success or failure of the API call. The 'response' attribute\n\t     * is an associative array constructed by json.decode. The 'error' attribute is a message.\n\t     * If the API call is successful but the server returns invalid JSON, error will be\n\t     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.call\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} params.httpMethod\n\t     * @param {string} params.objectId\n\t     * @param {string} params.path\n\t     * @param {object} params.parameters\n\t     * @returns {Promise}\n\t     */\n\t    function call(params) {\n\t        /* Params go in the URI for GET, DELETE, same format for\n\t         * POST and PUT, but they must be sent separately after the\n\t         * request is opened. */\n\t        var deferred = Q.defer();\n\t        var paramString = null;\n\t        var uri = null;\n\t        var response = {\n\t            'result': null,\n\t            'code': null\n\t        };\n\t        var start;\n\t\n\t        uri = clientSettings.baseURL + params.path;\n\t\n\t        if (!params) {\n\t            deferred.reject(new Error('No params.'));\n\t            return;\n\t        }\n\t\n\t        if (!params.httpMethod) {\n\t            deferred.reject(new Error('No HTTP method.'));\n\t            return;\n\t        }\n\t\n\t        if (!params.path) {\n\t            deferred.reject(new Error('No request path.'));\n\t            return;\n\t        }\n\t\n\t        if (params.objectId) {\n\t            params.path = params.path.replace(/\\%s/ig, params.objectId);\n\t        }\n\t\n\t        if (['GET', 'DELETE'].indexOf(params.httpMethod) > -1) {\n\t            uri += makeParamString(params.parameters);\n\t        }\n\t\n\t        xhr.open(params.httpMethod, uri);\n\t        if (appToken) {\n\t            xhr.setRequestHeader(\"App-Token\", appToken);\n\t        }\n\t        if (['POST', 'PUT'].indexOf(params.httpMethod) > -1) {\n\t            paramString = JSON.stringify(params.parameters);\n\t            if (paramString.length > bodySizeLimit) {\n\t                deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n\t                return;\n\t            }\n\t            xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\t        } else if (['GET', 'DELETE'].indexOf(params.httpMethod) === -1) {\n\t            deferred.reject(new Error('Illegal HTTP request method ' + params.httpMethod));\n\t            return;\n\t        }\n\t        log.debug('request', {\n\t            method: params.httpMethod,\n\t            uri: uri,\n\t            params: paramString\n\t        });\n\t\n\t        try {\n\t            xhr.send(paramString);\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return;\n\t        }\n\t\n\t        xhr.onreadystatechange = function () {\n\t            var durationMillis = now() - start;\n\t            var limit;\n\t            var unit;\n\t\n\t            if (this.readyState !== 4) {\n\t                return;\n\t            }\n\t            if (this.status === 0) {\n\t                deferred.reject(new Error(\"Status is 0: Incomplete request, SSL error, or CORS error.\"));\n\t                return;\n\t            }\n\t            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(this.status) > -1) {\n\t                response.code = this.status;\n\t                response.uri = uri;\n\t                response.params = params.parameters;\n\t                response.error = errors[this.status];\n\t                if (this.response) {\n\t                    try {\n\t                        response.result = JSON.parse(this.response);\n\t                    } catch (e) {\n\t                        response.result = this.response;\n\t                        response.error = \"Invalid JSON.\";\n\t                    }\n\t                }\n\t                log.debug('response', {\n\t                    method: params.httpMethod,\n\t                    durationMillis: durationMillis,\n\t                    response: response\n\t                });\n\t                deferred.resolve(response);\n\t            } else if (this.status === 429) {\n\t                unit = this.getResponseHeader('RateLimit-Time-Units');\n\t                limit = this.getResponseHeader('RateLimit-Limit');\n\t                deferred.reject(new Error(\"Rate limit of \" + limit + \"/\" + unit +\n\t                    \" exceeded. Try again in 1 \" + unit + \".\"));\n\t                return;\n\t            } else {\n\t                deferred.reject(new Error('unexpected response ' + this.status));\n\t                return;\n\t            }\n\t        };\n\t\n\t        return deferred.promise;\n\t    }\n\t\n\t    /**\n\t     * Turn key/value and key/list pairs into an HTTP URL parameter string.\n\t     * var1=value1&var2=value2,value3,value4\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.makeParamString\n\t     * @private\n\t     * @param {object} params - Arbitrary collection of strings and arrays to serialize.\n\t     * @returns {string}\n\t     */\n\t    function makeParamString(params) {\n\t        var strings = [];\n\t        if (!params) {\n\t            return '';\n\t        }\n\t\n\t        Object.keys(params).forEach(function formatParam(name) {\n\t            var value = params[name];\n\t            /* Skip objects -- We won't know how to name these. */\n\t            if (value instanceof Array) {\n\t                strings.push([name, value.join(',')].join('='));\n\t            } else if (typeof value !== 'object' && typeof value !== 'function') {\n\t                strings.push([name, value].join('='));\n\t            }\n\t        });\n\t\n\t        if (strings.length > 0) {\n\t            return '?' + strings.join('&');\n\t        } else {\n\t            return '';\n\t        }\n\t    }\n\t\n\t    return that;\n\t}; // End respoke.SignalingChannel\n\t/**\n\t * Handle an error that resulted from a method call.\n\t * @callback respoke.SignalingChannel.errorHandler\n\t * @params {Error} err\n\t */\n\t/**\n\t * Handle sending successfully.\n\t * @callback respoke.SignalingChannel.sendHandler\n\t */\n\t/**\n\t * Receive a group.\n\t * @callback respoke.SignalingChannel.groupHandler\n\t * @param {respoke.Group}\n\t */\n\t/**\n\t * Receive a list of groups.\n\t * @callback respoke.SignalingChannel.groupListHandler\n\t * @param {Array}\n\t */\n\t/**\n\t * Receive a list of TURN credentials.\n\t * @callback respoke.SignalingChannel.turnSuccessHandler\n\t * @param {Array}\n\t */\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar Q = __webpack_require__(19);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A direct connection via RTCDataChannel, including state and path negotation.\n\t * @class respoke.DirectConnection\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {string} params\n\t * @param {string} params.instanceId - client id\n\t * @param {respoke.Call} params.call - The call that is handling state for this direct connection.\n\t * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n\t * it to flow peer-to-peer. The relay acts like a blind proxy.\n\t * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n\t * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n\t * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n\t * @param {function} params.signalReport - Signaling action from SignalingChannel.\n\t * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n\t * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when setup of the direct connection\n\t * begins. The direct connection will not be open yet.\n\t * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors that happen during\n\t * direct connection setup or media renegotiation.\n\t * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for closing the direct connection.\n\t * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for opening the direct connection.\n\t * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the request\n\t * for a direct connection and setup is about to begin.\n\t * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages. Not usually\n\t * necessary to listen to this event if you are already listening to respoke.Endpoint#message.\n\t * @returns {respoke.DirectConnection}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t\n\t    /**\n\t     * A name to identify this class\n\t     * @memberof! respoke.DirectConnection\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.DirectConnection';\n\t    /**\n\t     * The unique identifier of the direct connection.\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = respoke.makeGUID();\n\t\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name call\n\t     * @type {respoke.Call}\n\t     */\n\t    if (!that.call.caller) {\n\t        that.call.caller = false;\n\t    }\n\t\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name dataChannel\n\t     * @type {RTCDataChannel}\n\t     * @private\n\t     */\n\t    var dataChannel = null;\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name client\n\t     * @type {respoke.Client}\n\t     * @private\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name pc\n\t     * @type {RTCPeerConnection}\n\t     * @private\n\t     */\n\t    var pc = params.pc;\n\t    delete params.pc;\n\t\n\t    /**\n\t     * When the datachannel is availble, we need to attach the callbacks. The event this function is attached to\n\t     * only fires for the callee.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.listenDataChannel\n\t     * @param {respoke.Event} evt\n\t     * @private\n\t     */\n\t    function listenDataChannel(evt) {\n\t        dataChannel = evt.channel;\n\t        dataChannel.onerror = onDataChannelError;\n\t        dataChannel.onmessage = onDataChannelMessage;\n\t        if (dataChannel.readyState === 'open') {\n\t            dataChannel.onopen = null;\n\t            onDataChannelOpen();\n\t        } else {\n\t            dataChannel.onopen = onDataChannelOpen;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Register any event listeners passed in as callbacks\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.saveParameters\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for when the direct connection\n\t     * is closed.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for when the direct connection\n\t     * is open.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages.\n\t     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n\t     * connection.\n\t     * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when the direct connection\n\t     * is being set up. The direct connection will not be open yet.\n\t     * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n\t     * it to flow peer-to-peer. The relay acts like a blind proxy.\n\t     * @private\n\t     */\n\t    function saveParameters(params) {\n\t        /**\n\t         * The direct connection is open.\n\t         * @event respoke.DirectConnection#open\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('open', params.onOpen);\n\t        /**\n\t         * The direct connection is closed.\n\t         * @event respoke.DirectConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('close', params.onClose);\n\t        /**\n\t         * Incoming message on this direct connection.\n\t         * @event respoke.DirectConnection#message\n\t         * @type {respoke.Event}\n\t         * @property {respoke.TextMessage} message\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('message', params.onMessage);\n\t        // documented elsewhere\n\t        that.listen('start', params.onStart);\n\t        /**\n\t         * An error occurred while setting up the direct connection.\n\t         * @event respoke.DirectConnection#error\n\t         * @type {respoke.Event}\n\t         * @property {string} reason - A human-readable description of the error.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('error', params.onError);\n\t        pc.listen('direct-connection', listenDataChannel, true);\n\t        pc.listen('stats', function fireStats(evt) {\n\t            /**\n\t             * This event is fired every time statistical information about the direct connection\n\t             * becomes available.\n\t             * @event respoke.DirectConnection#stats\n\t             * @type {respoke.Event}\n\t             * @property {object} stats - an object with stats in it.\n\t             * @property {respoke.DirectConnection} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('stats', {stats: evt.stats});\n\t        }, true);\n\t\n\t    }\n\t    saveParameters(params);\n\t\n\t    delete that.onOpen;\n\t    delete that.onClose;\n\t    delete that.onMessage;\n\t\n\t    /**\n\t     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n\t     * statistics, we'll return a promise for the stats object.\n\t     *\n\t     *     directConnection.getStats({\n\t     *         onStats: function (evt) {\n\t     *             console.log('Stats', evt.stats);\n\t     *         }\n\t     *     }).done(function () {\n\t     *         console.log('Stats started.');\n\t     *     }, function (err) {\n\t     *         console.log('Direct connection is already closed.');\n\t     *     });\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.getStats\n\t     * @returns {Promise<object>|undefined}\n\t     * @param {object} params\n\t     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive the\n\t     * stats if the Respoke stats module is loaded. If no callback is provided, the connection's report will\n\t     * contain stats but the developer will not receive them on the client-side.\n\t     * @param {respoke.DirectConnection.statsSuccessHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation of\n\t     * this method only.\n\t     */\n\t    that.getStats = function (params) {\n\t        if (pc && pc.getStats) {\n\t            that.listen('stats', params.onStats);\n\t            delete params.onStats;\n\t            return pc.getStats(params);\n\t        }\n\t        return null;\n\t    };\n\t\n\t    if (!respoke.MediaStats) {\n\t        delete that.getStats;\n\t    }\n\t\n\t    /**\n\t     * Detect datachannel errors for internal state.\n\t     * @memberof! respoke.DirectConnection\n\t     * @private\n\t     * @method respoke.DirectConnection.onDataChannelError\n\t     */\n\t    function onDataChannelError(error) {\n\t        /**\n\t         * @event respoke.DirectConnection#error\n\t         * @type {respoke.Event}\n\t         * @property {object} error\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('error', {\n\t            error: error\n\t        });\n\t        that.close();\n\t    }\n\t\n\t    /**\n\t     * Receive and route messages to the Endpoint.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.onDataChannelMessage\n\t     * @private\n\t     * @param {MessageEvent}\n\t     * @fires respoke.DirectConnection#message\n\t     */\n\t    function onDataChannelMessage(evt) {\n\t        var message;\n\t        try {\n\t            message = JSON.parse(evt.data);\n\t        } catch (e) {\n\t            message = evt.data;\n\t        }\n\t        /**\n\t         * @event respoke.Endpoint#message\n\t         * @type {respoke.Event}\n\t         * @property {object} message\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.call.remoteEndpoint.fire('message', {\n\t            message: message,\n\t            directConnection: that\n\t        });\n\t        /**\n\t         * @event respoke.DirectConnection#message\n\t         * @type {respoke.Event}\n\t         * @property {object} message\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('message', {\n\t            message: message,\n\t            endpoint: that.call.remoteEndpoint\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Detect when the channel is open.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.onDataChannelOpen\n\t     * @private\n\t     * @param {MessageEvent}\n\t     * @fires respoke.DirectConnection#open\n\t     */\n\t    function onDataChannelOpen(evt) {\n\t        //dataChannel = evt.target || evt.channel;\n\t        /**\n\t         * @event respoke.DirectConnection#open\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('open');\n\t    }\n\t\n\t    /**\n\t     * Detect when the channel is closed.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.onDataChannelClose\n\t     * @private\n\t     * @param {MessageEvent}\n\t     * @fires respoke.DirectConnection#close\n\t     */\n\t    function onDataChannelClose(evt) {\n\t        //dataChannel = evt.target || evt.channel;\n\t        /**\n\t         * @event respoke.DirectConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('close');\n\t    }\n\t\n\t    /**\n\t     * Create the datachannel. For the caller, set up all the handlers we'll need to keep track of the\n\t     * datachannel's state and to receive messages.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.createDataChannel\n\t     * @private\n\t     */\n\t    function createDataChannel() {\n\t        dataChannel = pc.createDataChannel(\"respokeDataChannel\");\n\t        dataChannel.binaryType = 'arraybuffer';\n\t        dataChannel.onerror = onDataChannelError;\n\t        dataChannel.onmessage = onDataChannelMessage;\n\t        dataChannel.onopen = onDataChannelOpen;\n\t\n\t        /**\n\t         * The direct connection setup has begun. This does NOT mean it's ready to send messages yet. Listen to\n\t         * DirectConnection#open for that notification.\n\t         * @event respoke.DirectConnection#start\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('start');\n\t    }\n\t\n\t    /**\n\t     * Start the process of obtaining media. saveParameters will only be meaningful for the callee,\n\t     * since the library calls this method for the caller. Developers will use this method to pass in\n\t     * callbacks for the callee.\n\t     *\n\t     *     directConnection.accept({\n\t     *         onOpen: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.accept\n\t     * @fires respoke.DirectConnection#accept\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen]\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose]\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage]\n\t     */\n\t    that.accept = function (params) {\n\t        params = params || {};\n\t        log.debug('DirectConnection.accept');\n\t        saveParameters(params);\n\t\n\t        log.debug(\"I am \" + (pc.state.caller ? '' : 'not ') + \"the caller.\");\n\t\n\t        if (pc.state.caller === true) {\n\t            createDataChannel();\n\t        }\n\t        that.call.answer();\n\t\n\t        /**\n\t         * @event respoke.DirectConnection#accept\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('accept');\n\t    };\n\t\n\t    /**\n\t     * Tear down the connection.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.close\n\t     * @fires respoke.DirectConnection#close\n\t     */\n\t    that.close = function (params) {\n\t        params = params || {};\n\t        log.debug(\"DirectConnection.close\");\n\t        if (dataChannel) {\n\t            dataChannel.close();\n\t        }\n\t\n\t        /**\n\t         * @event respoke.DirectConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('close');\n\t\n\t        that.ignore();\n\t\n\t        if (params.skipRemove !== true) {\n\t            that.call.removeDirectConnection();\n\t        }\n\t\n\t        dataChannel = null;\n\t        that.call.remoteEndpoint.directConnection = null;\n\t        that.call = null;\n\t        pc = null;\n\t    };\n\t\n\t    /**\n\t     * Send a message over the datachannel in the form of a JSON-encoded plain old JavaScript object. Only one\n\t     * attribute may be given: either a string 'message' or an object 'object'.\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     *     directConnection.sendMessage({\n\t     *         message: \"And they say HTTP is stateless!\"\n\t     *     });\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.sendMessage\n\t     * @param {object} params\n\t     * @param {string} [params.message] - The message to send.\n\t     * @param {object} [params.object] - An object to send.\n\t     * @param {respoke.DirectConnection.sendHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation\n\t     * of this method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        if (that.isActive()) {\n\t            dataChannel.send(JSON.stringify(params.object || {\n\t                message: params.message\n\t            }));\n\t            deferred.resolve();\n\t        } else {\n\t            deferred.reject(new Error(\"dataChannel not in an open state.\"));\n\t        }\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Expose close as reject for approve/reject workflow.\n\t     *\n\t     *     client.listen('direct-connection, function (evt) {\n\t     *         if (iDontLikeThisPerson()) {\n\t     *             evt.directConnection.reject();\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.reject\n\t     * @param {boolean} signal - Optional flag to indicate whether to send or suppress sending\n\t     * a hangup signal to the remote side.\n\t     */\n\t    that.reject = that.close;\n\t\n\t    /**\n\t     * Indicate whether a datachannel is being setup or is in progress.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.isActive\n\t     * @returns {boolean}\n\t     */\n\t    that.isActive = function () {\n\t        // Why does pc.iceConnectionState not transition into 'connected' even though media is flowing?\n\t        //return (pc && pc.isActive() && dataChannel && dataChannel.readyState === 'open');\n\t        return (dataChannel && dataChannel.readyState === 'open');\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.DirectConnection\n\t\n\t/**\n\t * Called when the direct connection is closed.  This callback is called every time respoke.DirectConnection#close\n\t * fires.\n\t * @callback respoke.DirectConnection.onClose\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when the setup of the direct connection has begun. The direct connection will not be open yet. This\n\t * callback is called every time respoke.DirectConnection#start fires.\n\t * @callback respoke.DirectConnection.onStart\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when the direct connection is opened.  This callback is called every time respoke.DirectConnection#open\n\t * fires.\n\t * @callback respoke.DirectConnection.onOpen\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when a message is received over the direct connection.  This callback is called every time\n\t * respoke.DirectConnection#message fires.\n\t * @callback respoke.DirectConnection.onMessage\n\t * @param {respoke.Event} evt\n\t * @param {object} evt.message\n\t * @param {respoke.Endpoint} evt.endpoint\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Handle an error that resulted from a specific method call. This handler will not fire more than once.\n\t * @callback respoke.DirectConnection.errorHandler\n\t * @param {Error} err\n\t */\n\t/**\n\t * When a call is in setup or media renegotiation happens. This callback will be called every time\n\t * respoke.DirectConnection#error.\n\t * @callback respoke.DirectConnection.onError\n\t * @param {respoke.Event} evt\n\t * @param {boolean} evt.reason - A human-readable description of the error.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when the callee accepts the direct connection. This callback is called every time\n\t * respoke.DirectConnection#accept is fired.\n\t * @callback respoke.DirectConnection.onAccept\n\t * @param {respoke.Event} evt\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Handle the successful kick-off of stats on a call.\n\t * @callback respoke.DirectConnection.statsSuccessHandler\n\t * @param {respoke.Event} evt\n\t * @param {object} evt.stats - an object with stats in it.\n\t * @param {respoke.DirectConnection} evt.target\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Handle sending successfully.\n\t * @callback respoke.DirectConnection.sendHandler\n\t */\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar Q = __webpack_require__(19);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * WebRTC PeerConnection. This class handles all the state and connectivity for Call and DirectConnection.\n\t * This class cannot be used alone, but is instantiated by and must be given media by either Call, DirectConnection,\n\t * or the not-yet-implemented ScreenShare.\n\t * @class respoke.PeerConnection\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @param {boolean} [params.forceTurn] - If true, delete all 'host' and 'srvflx' candidates and send only 'relay'\n\t * candidates.\n\t * @param {boolean} [params.disableTurn] - If true, delete all 'relay' candidates and send only 'host' and 'srvflx'\n\t * candidates.\n\t * @param {respoke.Call} params.call\n\t * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n\t * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n\t * @param {function} params.signalModify - Signaling action from SignalingChannel.\n\t * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n\t * @param {function} params.signalReport - Signaling action from SignalingChannel.\n\t * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n\t * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n\t * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for the developer to receive\n\t * statistics about the call. This is only used if call.getStats() is called and the stats module is loaded.\n\t * @param {object} [params.pcOptions]\n\t * @param {object} [params.offerOptions]\n\t * @returns {respoke.PeerConnection}\n\t */\n\t\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.PeerConnection';\n\t\n\t    /**\n\t     * Whether or not we will send a 'hangup' signal to the other side during hangup.\n\t     * @memberof! respoke.PeerConnection\n\t     * @name toSendHangup\n\t     * @type {respoke.Endpoint}\n\t     */\n\t    var toSendHangup;\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @private\n\t     * @name pc\n\t     * @type RTCPeerConnection\n\t     * @desc The RTCPeerConnection as provided by the browser API. All internal state, networking functionality, and\n\t     * raw data transfer occurs within the PeerConnection.\n\t     */\n\t    var pc = null;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name defModify\n\t     * @private\n\t     * @type {Promise}\n\t     * @desc Used in the state machine to trigger methods or functions whose execution depends on the reception,\n\t     * handling, or sending of some information.\n\t     */\n\t    var defModify;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name previewLocalMedia\n\t     * @private\n\t     * @type {respoke.Call.previewLocalMedia}\n\t     * @desc A callback provided by the developer that we'll call after receiving local media and before\n\t     * approve() is called.\n\t     */\n\t    var previewLocalMedia = typeof params.previewLocalMedia === 'function' ? params.previewLocalMedia : undefined;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name candidateSendingQueue\n\t     * @private\n\t     * @type {array}\n\t     * @desc An array to save candidates between offer and answer so that both parties can process them simultaneously.\n\t     */\n\t    var candidateSendingQueue = [];\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name candidateReceivingQueue\n\t     * @private\n\t     * @type {array}\n\t     * @desc An array to save candidates between offer and answer so that both parties can process them simultaneously.\n\t     */\n\t    var candidateReceivingQueue = [];\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.Client}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalOffer\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalOffer = params.signalOffer;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalConnected\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalConnected = params.signalConnected;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalModify\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalModify = params.signalModify;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalAnswer\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalAnswer = params.signalAnswer;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalHangup\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalHangup = respoke.once(params.signalHangup);\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalReport\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalReport = params.signalReport;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalCandidateOrig\n\t     * @private\n\t     * @type {function}\n\t     * @desc A temporary function saved from params in order to construct the candidate signaling function.\n\t     */\n\t    var signalCandidateOrig = params.signalCandidate;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalCandidate\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed from the one passed to us by the signaling channel with additions\n\t     * to facilitate candidate logging.\n\t     */\n\t    function signalCandidate(params) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        params.iceCandidates = [params.candidate];\n\t        signalCandidateOrig(params);\n\t        that.report.candidatesSent.push({candidate: params.candidate});\n\t    }\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name offerOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var offerOptions = params.offerOptions || null;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name pcOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var pcOptions = params.pcOptions || {\n\t        optional: [\n\t            { DtlsSrtpKeyAgreement: true },\n\t            { RtpDataChannels: false }\n\t        ]\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name report\n\t     * @type {object}\n\t     */\n\t    that.report = {\n\t        callStarted: 0,\n\t        callStopped: 0,\n\t        callerendpoint: that.call.caller ? client.name : that.call.remoteEndpoint.id,\n\t        callerconnection: that.call.caller ? client.id : that.call.connectionId,\n\t        calleeendpoint: that.call.caller ? that.call.remoteEndpoint.id : client.id,\n\t        calleeconnection: that.call.caller ? that.call.connectionId : client.connectionId,\n\t        sessionId: that.call.id,\n\t        lastSDPString: '',\n\t        sdpsSent: [],\n\t        sdpsReceived: [],\n\t        candidatesSent: [],\n\t        candidatesReceived: [],\n\t        userAgent: navigator.userAgent,\n\t        os: navigator.platform\n\t    };\n\t\n\t    /**\n\t     * Start the process of network and media negotiation. Called after local video approved.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.initOffer\n\t     * @fires respoke.PeerConnection#initOffer\n\t     * @private\n\t     */\n\t    function initOffer() {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        log.info('creating offer', offerOptions);\n\t        pc.createOffer(saveOfferAndSend, function errorHandler(p) {\n\t            log.error('createOffer failed');\n\t        }, offerOptions);\n\t    }\n\t\n\t    /**\n\t     * Process a remote offer if we are not the caller. This is necessary because we don't process the offer until\n\t     * the callee has answered the call.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.processOffer\n\t     * @param {RTCSessionDescriptor}\n\t     * @returns {Promise}\n\t     */\n\t    that.processOffer = function (oOffer) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        log.debug('processOffer', oOffer);\n\t\n\t        that.report.sdpsReceived.push(oOffer);\n\t        that.report.lastSDPString = oOffer.sdp;\n\t\n\t        //set flags for audio / video being offered\n\t        that.call.hasAudio = respoke.sdpHasAudio(oOffer.sdp);\n\t        that.call.hasVideo = respoke.sdpHasVideo(oOffer.sdp);\n\t        that.call.hasDataChannel = respoke.sdpHasDataChannel(oOffer.sdp);\n\t\n\t        try {\n\t            pc.setRemoteDescription(new RTCSessionDescription(oOffer),\n\t                function successHandler() {\n\t                    if (!pc) {\n\t                        return;\n\t                    }\n\t\n\t                    log.debug('set remote desc of offer succeeded');\n\t                    that.call.incomingMedia.setSDP(oOffer); // callee's incoming media\n\t                    pc.createAnswer(function successHandler(oSession) {\n\t                        that.state.processedRemoteSDP = true;\n\t                        that.call.outgoingMedia.setSDP(oSession); // callee's outgoing media\n\t                        saveAnswerAndSend(oSession);\n\t                    }, function errorHandler(err) {\n\t                        err = new Error(\"Error creating SDP answer.\" + err.message);\n\t                        that.report.callStoppedReason = err.message;\n\t                        /**\n\t                         * This event is fired on errors that occur during call setup or media negotiation.\n\t                         * @event respoke.Call#error\n\t                         * @type {respoke.Event}\n\t                         * @property {string} reason - A human readable description about the error.\n\t                         * @property {respoke.Call} target\n\t                         * @property {string} name - the event name.\n\t                         */\n\t                        that.call.fire('error', {\n\t                            message: err.message\n\t                        });\n\t                        log.error('create answer failed');\n\t                        that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n\t                        that.close();\n\t                    });\n\t                }, function errorHandler(err) {\n\t                    err = new Error('Error calling setRemoteDescription on offer I received.' + err.message);\n\t                    that.report.callStoppedReason = err.message;\n\t                    /**\n\t                     * This event is fired on errors that occur during call setup or media negotiation.\n\t                     * @event respoke.Call#error\n\t                     * @type {respoke.Event}\n\t                     * @property {string} reason - A human readable description about the error.\n\t                     * @property {respoke.Call} target\n\t                     * @property {string} name - the event name.\n\t                     */\n\t                    that.call.fire('error', {\n\t                        message: err.message\n\t                    });\n\t                }\n\t            );\n\t        } catch (err) {\n\t            var newErr = new Error(\"Exception calling setRemoteDescription on offer I received.\" + err.message);\n\t            that.report.callStoppedReason = newErr.message;\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.call.fire('error', {\n\t                message: newErr.message\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n\t     * statistics, we'll return a promise for the stats object.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.getStats\n\t     * @returns {Promise<{respoke.MediaStatsParser}>|undefined}\n\t     * @param {object} params\n\t     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @fires respoke.PeerConnection#stats\n\t     */\n\t    function getStats(params) {\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        if (!respoke.MediaStats) {\n\t            deferred.reject(new Error(\"Statistics module is not loaded.\"));\n\t            return retVal;\n\t        }\n\t\n\t        function onConnect() {\n\t            var stats = respoke.MediaStatsParser({\n\t                peerConnection: pc,\n\t                interval: params.interval,\n\t                onStats: function statsHandler(stats) {\n\t                    if (!pc) {\n\t                        return;\n\t                    }\n\t\n\t                    /**\n\t                     * @event respoke.PeerConnection#stats\n\t                     * @type {respoke.Event}\n\t                     * @property {object} stats - an object with stats in it.\n\t                     * @property {string} name - the event name.\n\t                     * @property {respoke.PeerConnection}\n\t                     */\n\t                    that.fire('stats', {\n\t                        stats: stats\n\t                    });\n\t                }\n\t            });\n\t            that.listen('close', function closeHandler(evt) {\n\t                stats.stopStats();\n\t            }, true);\n\t            deferred.resolve();\n\t        }\n\t\n\t        if (!pc) {\n\t            that.once('stream-received', onConnect);\n\t        } else {\n\t            onConnect();\n\t        }\n\t\n\t        return retVal;\n\t    }\n\t\n\t    if (respoke.MediaStats) {\n\t        that.getStats = getStats;\n\t    }\n\t\n\t    /**\n\t     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.init\n\t     */\n\t    that.init = function init() {\n\t        log.debug('PC.init');\n\t\n\t        if (pc) {\n\t            return;\n\t        }\n\t\n\t        that.report.callStarted = new Date().getTime();\n\t\n\t        pc = new RTCPeerConnection(that.servers, pcOptions);\n\t        pc.onicecandidate = onIceCandidate;\n\t        pc.onnegotiationneeded = onNegotiationNeeded;\n\t        pc.onaddstream = function onaddstream(evt) {\n\t            /**\n\t             * @event respoke.PeerConnection#connect\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('connect', {\n\t                stream: evt.stream\n\t            });\n\t        };\n\t        pc.onremovestream = function onremovestream(evt) {\n\t            /**\n\t             * @event respoke.PeerConnection#remote-stream-removed\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('remote-stream-removed', {\n\t                stream: evt.stream\n\t            });\n\t        };\n\t        pc.ondatachannel = function ondatachannel(evt) {\n\t            /**\n\t             * CAUTION: This event is only called for the callee because RTCPeerConnection#ondatachannel\n\t             * is only called for the callee.\n\t             * @event respoke.PeerConnection#direct-connection\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('direct-connection', {\n\t                channel: evt.channel\n\t            });\n\t        };\n\t\n\t        that.state.listen('offering:entry', function (evt) {\n\t            if (that.state.caller) {\n\t                initOffer();\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Return an array of remote media streams.\n\t     * @muremberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.getRemoteStreams\n\t     */\n\t    that.getRemoteStreams = function () {\n\t        if (!pc) {\n\t            return [];\n\t        }\n\t        return pc.getRemoteStreams.apply(pc, Array.prototype.slice.call(arguments));\n\t    };\n\t\n\t    /**\n\t     * Return an array of local media streams.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.getLocalStreams\n\t     */\n\t    that.getLocalStreams = function () {\n\t        if (!pc) {\n\t            return [];\n\t        }\n\t        return pc.getLocalStreams.apply(pc, Array.prototype.slice.call(arguments));\n\t    };\n\t\n\t    /**\n\t     * Create a data channel.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.createDataChannel\n\t     */\n\t    that.createDataChannel = function () {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        return pc.createDataChannel.apply(pc, Array.prototype.slice.call(arguments));\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.addStream\n\t     * Expose addStream.\n\t     * @param {RTCMediaStream}\n\t     */\n\t    that.addStream = function (stream) {\n\t        if (!pc) {\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.call.fire('error', {\n\t                message: \"Got local stream in a precall state.\"\n\t            });\n\t            return;\n\t        }\n\t        pc.addStream(stream);\n\t    };\n\t\n\t    /**\n\t     * Process a local ICE Candidate\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.onIceCandidate\n\t     * @private\n\t     * @param {RTCIceCandidate}\n\t     */\n\t    function onIceCandidate(oCan) {\n\t        var candidate = oCan.candidate; // {candidate: ..., sdpMLineIndex: ... }\n\t        if (!candidate || !candidate.candidate) {\n\t            return;\n\t        }\n\t\n\t        if (that.forceTurn === true && candidate.candidate.indexOf(\"typ relay\") === -1) {\n\t            log.debug(\"Dropping candidate because forceTurn is on.\");\n\t            return;\n\t        } else if (that.disableTurn === true && candidate.candidate.indexOf(\"typ relay\") !== -1) {\n\t            log.debug(\"Dropping candidate because disableTurn is on.\");\n\t            return;\n\t        }\n\t\n\t        if (!that.state.sentSDP && !that.state.processedRemoteSDP) {\n\t            candidateSendingQueue.push(candidate);\n\t        } else {\n\t            signalCandidate({\n\t                candidate: candidate,\n\t                call: that.call\n\t            });\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handle renegotiation\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.onNegotiationNeeded\n\t     * @private\n\t     */\n\t    function onNegotiationNeeded() {\n\t        log.warn(\"Negotiation needed.\");\n\t    }\n\t\n\t    /**\n\t     * Process any ICE candidates that we received either from the browser or the other side while\n\t     * we were trying to set up our RTCPeerConnection to handle them.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.processQueues\n\t     * @private\n\t     */\n\t    function processQueues() {\n\t        /* We only need to queue (and thus process queues) if\n\t         * we are the caller. The person receiving the call\n\t         * never has a valid PeerConnection at a time when we don't\n\t         * have one. */\n\t        var can = null;\n\t        for (var i = 0; i < candidateSendingQueue.length; i += 1) {\n\t            signalCandidate({\n\t                candidate: candidateSendingQueue[i],\n\t                call: that.call\n\t            });\n\t        }\n\t        candidateSendingQueue = [];\n\t        for (var i = 0; i < candidateReceivingQueue.length; i += 1) {\n\t            that.addRemoteCandidate({\n\t                candidate: candidateReceivingQueue[i],\n\t                processingQueue: true\n\t            });\n\t        }\n\t        candidateReceivingQueue = [];\n\t    }\n\t\n\t    /**\n\t     * Save an SDP we've gotten from the browser which will be an offer and send it to the other\n\t     * side.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.saveOfferAndSend\n\t     * @param {RTCSessionDescription}\n\t     * @private\n\t     */\n\t    function saveOfferAndSend(oSession) {\n\t        oSession.type = 'offer';\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        log.debug('setting and sending offer', oSession);\n\t        that.report.sdpsSent.push(oSession);\n\t        that.call.outgoingMedia.setSDP(oSession); // caller's outgoing media\n\t        that.call.incomingMedia.setSDP(oSession); // caller's incoming media estimate\n\t        pc.setLocalDescription(oSession, function successHandler(p) {\n\t            oSession.type = 'offer';\n\t            signalOffer({\n\t                call: that.call,\n\t                sessionDescription: oSession,\n\t                onSuccess: function () {\n\t                    that.state.sentSDP = true;\n\t                    setTimeout(processQueues);\n\t                },\n\t                onError: function (err) {\n\t                    respoke.log.error('offer could not be sent');\n\t                    that.call.hangup({signal: false});\n\t                }\n\t            });\n\t        }, function errorHandler(p) {\n\t            var err = new Error('Error calling setLocalDescription on offer I created.');\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.call.fire('error', {\n\t                message: err.message\n\t            });\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Save our SDP we've gotten from the browser which will be an answer and send it to the\n\t     * other side.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.saveAnswerAndSend\n\t     * @param {RTCSessionDescription}\n\t     * @private\n\t     */\n\t    function saveAnswerAndSend(oSession) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        if (!that.state.caller) {\n\t            that.report.callerconnection = that.call.connectionId;\n\t        }\n\t\n\t        oSession.type = 'answer';\n\t        log.debug('setting and sending answer', oSession);\n\t        that.report.sdpsSent.push(oSession);\n\t\n\t        pc.setLocalDescription(oSession, function successHandler(p) {\n\t            oSession.type = 'answer';\n\t            signalAnswer({\n\t                sessionDescription: oSession,\n\t                call: that.call\n\t            });\n\t            that.state.sentSDP = true;\n\t            processQueues();\n\t        }, function errorHandler(p) {\n\t            var err = new Error('Error calling setLocalDescription on answer I created.');\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.call.fire('error', {\n\t                message: err.message\n\t            });\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n\t     * signal is not false and we have not received a hangup signal from the remote party.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.close\n\t     * @fires respoke.PeerConnection#destoy\n\t     * @param {object} param\n\t     * @param {boolean} [param.signal] - Optional flag to indicate whether to send or suppress sending\n\t     * a hangup signal to the remote side. This is set to false by the library if we're responding to a\n\t     * hangup signal.\n\t     * @fires respoke.PeerConnection#close\n\t     */\n\t    that.close = function (params) {\n\t        params = params || {};\n\t        toSendHangup = true;\n\t\n\t        if (that.state.caller === true) {\n\t            if (!that.state.sentSDP) {\n\t                // Never send hangup if we are the caller but we haven't sent any other signal yet.\n\t                toSendHangup = false;\n\t            }\n\t        }\n\t\n\t        toSendHangup = (typeof params.signal === 'boolean' ? params.signal : toSendHangup);\n\t        if (toSendHangup) {\n\t            log.info('sending hangup');\n\t            signalHangup({\n\t                call: that.call\n\t            });\n\t        }\n\t\n\t        that.report.callStopped = new Date().getTime();\n\t\n\t        /**\n\t         * @event respoke.PeerConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.PeerConnection}\n\t         */\n\t        that.fire('close', {\n\t            sentSignal: toSendHangup\n\t        });\n\t        that.ignore();\n\t\n\t        if (pc && that.report) {\n\t            pc.close();\n\t        }\n\t        pc = null;\n\t\n\t        if (that.call.enableCallDebugReport) {\n\t            signalReport({\n\t                report: that.report\n\t            });\n\t        }\n\t        that.report = null;\n\t    };\n\t    that.close = respoke.once(that.close);\n\t\n\t    /**\n\t     * Indicate whether a call is being setup or is in progress.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.isActive\n\t     * @returns {boolean}\n\t     */\n\t    that.isActive = function () {\n\t        return !!(pc && ['completed', 'connected', 'new', 'checking'].indexOf(pc.iceConnectionState) > -1);\n\t    };\n\t\n\t    /**\n\t     * Set the estimated media status on incoming and outgoing media.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.listenOffer\n\t     * @param {object} evt\n\t     * @param {object} evt.signal - The signal, including the remote SDP and the connectionId of the endpoint who\n\t     * answered the call.\n\t     * @private\n\t     */\n\t    function listenOffer(evt) {\n\t        that.call.incomingMedia.setSDP(evt.signal.sessionDescription); // callee's incoming media\n\t        that.call.outgoingMedia.setSDP(evt.signal.sessionDescription); // callee's outgoing media estimate\n\t    }\n\t\n\t    /**\n\t     * Save the answer and tell the browser about it.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.listenAnswer\n\t     * @param {object} evt\n\t     * @param {object} evt.signal - The signal, including the remote SDP and the connectionId of the endpoint who\n\t     * answered the call.\n\t     * @private\n\t     */\n\t    function listenAnswer(evt) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        log.debug('got answer', evt.signal);\n\t\n\t        that.report.sdpsReceived.push(evt.signal.sessionDescription);\n\t        that.report.lastSDPString = evt.signal.sessionDescription.sdp;\n\t        //set flags for audio / video for answer\n\t        that.call.hasAudio = respoke.sdpHasAudio(evt.signal.sessionDescription.sdp);\n\t        that.call.hasVideo = respoke.sdpHasVideo(evt.signal.sessionDescription.sdp);\n\t        that.call.hasDataChannel = respoke.sdpHasDataChannel(evt.signal.sessionDescription.sdp);\n\t        if (that.state.caller) {\n\t            that.report.calleeconnection = evt.signal.fromConnection;\n\t        }\n\t        that.call.connectionId = evt.signal.fromConnection;\n\t        // TODO don't signal connected more than once.\n\t        signalConnected({\n\t            call: that.call\n\t        });\n\t\n\t        pc.setRemoteDescription(\n\t            new RTCSessionDescription(evt.signal.sessionDescription),\n\t            function successHandler() {\n\t                that.call.incomingMedia.setSDP(evt.signal.sessionDescription); // caller's incoming media\n\t                that.state.dispatch('receiveAnswer');\n\t            }, function errorHandler(p) {\n\t                var newErr = new Error(\"Exception calling setRemoteDescription on answer I received.\");\n\t                that.report.callStoppedReason = newErr.message;\n\t                /**\n\t                 * This event is fired on errors that occur during call setup or media negotiation.\n\t                 * @event respoke.Call#error\n\t                 * @type {respoke.Event}\n\t                 * @property {string} reason - A human readable description about the error.\n\t                 * @property {respoke.Call} target\n\t                 * @property {string} name - the event name.\n\t                 */\n\t                that.call.fire('error', {\n\t                    message: newErr.message\n\t                });\n\t                log.error('set remote desc of answer failed', evt.signal.sessionDescription);\n\t                that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n\t                that.close();\n\t            }\n\t        );\n\t    }\n\t\n\t    /**\n\t     * Figure out who won the call. This necessary to prevent two connections of the same endpoint from thinking\n\t     * they are both on the same call.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.listenConnected\n\t     * @private\n\t     */\n\t    function listenConnected(evt) {\n\t        if (evt.signal.connectionId !== client.connectionId) {\n\t            log.debug(\"Hanging up because I didn't win the call.\", evt.signal, client);\n\t            that.call.hangup({signal: false});\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Send the initiate signal to start the modify process. This method is only called by the caller of the\n\t     * renegotiation.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.startModify\n\t     * @param {object} params\n\t     * @param {object} [params.constraints] - Indicate this is a request for media and what type of media.\n\t     * @param {boolean} [params.directConnection] - Indicate this is a request for a direct connection.\n\t     */\n\t    that.startModify = function (params) {\n\t        defModify = Q.defer();\n\t        signalModify({\n\t            action: 'initiate',\n\t            call: that.call,\n\t            constraints: params.constraints,\n\t            directConnection: params.directConnection\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Indicate a desire from the other side to renegotiate media.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.listenModify\n\t     * @param {object} evt\n\t     * @param {object} evt.signal\n\t     * @private\n\t     */\n\t    function listenModify(evt) {\n\t        var err;\n\t        log.debug('PC.listenModify', evt.signal);\n\t\n\t        if (evt.signal.action === 'accept') {\n\t            if (defModify.promise.isPending()) {\n\t                defModify.resolve();\n\t                /**\n\t                 * @event respoke.PeerConnection#modify-accept\n\t                 * @type {respoke.Event}\n\t                 * @property {string} name - the event name.\n\t                 * @property {respoke.PeerConnection}\n\t                 */\n\t                that.fire('modify-accept', {signal: evt.signal});\n\t            }\n\t            return;\n\t        } else if (evt.signal.action === 'reject') {\n\t            if (defModify.promise.isPending()) {\n\t                err = new Error(\"Remote party cannot negotiate.\");\n\t                log.debug(err.message);\n\t                defModify.reject(err);\n\t                /**\n\t                 * @event respoke.PeerConnection#modify-reject\n\t                 * @type {respoke.Event}\n\t                 * @property {Error} err\n\t                 * @property {string} name - the event name.\n\t                 * @property {respoke.PeerConnection}\n\t                 */\n\t                that.fire('modify-reject', {err: err});\n\t            }\n\t            return;\n\t        }\n\t\n\t        // This code only gets executed if signal.action === 'initiate'\n\t        if (defModify && defModify.promise.isPending()) {\n\t            // TODO compare signal request ID and accept if we have the higher request ID,\n\t            // reject if we have the lower request ID.\n\t            err = new Error(\"Got modify in a negotiating state.\");\n\t            log.debug(err.message);\n\t            defModify.reject(err);\n\t            /**\n\t             * @event respoke.PeerConnection#modify-reject\n\t             * @type {respoke.Event}\n\t             * @property {Error} err\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('modify-reject', {err: err});\n\t            signalModify({\n\t                action: 'reject',\n\t                call: that.call\n\t            });\n\t            return;\n\t        }\n\t\n\t        defModify = Q.defer();\n\t\n\t        if (!that.state.sentSDP || that.state.isState('idle')) {\n\t            err = new Error(\"Got modify in a precall state.\");\n\t            /**\n\t             * @event respoke.PeerConnection#modify-reject\n\t             * @type {respoke.Event}\n\t             * @property {Error} err\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('modify-reject', {err: err});\n\t            signalModify({\n\t                action: 'reject',\n\t                call: that.call\n\t            });\n\t            defModify.reject(err);\n\t            return;\n\t        }\n\t\n\t       /**\n\t         * @event respoke.PeerConnection#modify-accept\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.PeerConnection}\n\t         */\n\t        that.fire('modify-accept', {signal: evt.signal});\n\t        signalModify({\n\t            action: 'accept',\n\t            call: that.call\n\t        });\n\t        defModify.resolve();\n\t    }\n\t\n\t    /**\n\t     * Save the candidate. If we initiated the call, place the candidate into the queue so\n\t     * we can process them after we receive the answer.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.addRemoteCandidate\n\t     * @param {object} params\n\t     * @param {RTCIceCandidate} params.candidate\n\t     */\n\t    that.addRemoteCandidate = function (params) {\n\t        params = params || {};\n\t\n\t        if (!pc && params.processingQueue) { // we hung up.\n\t            return;\n\t        }\n\t\n\t        if (!params.candidate || !params.candidate.hasOwnProperty('sdpMLineIndex')) {\n\t            log.warn(\"addRemoteCandidate got wrong format!\", params);\n\t            return;\n\t        }\n\t\n\t        if (!pc) {\n\t            candidateReceivingQueue.push(params.candidate);\n\t            log.debug('Queueing a candidate because pc is null.');\n\t            return;\n\t        }\n\t\n\t        if (that.state.sentSDP || that.state.processedRemoteSDP) {\n\t            try {\n\t                pc.addIceCandidate(new RTCIceCandidate(params.candidate));\n\t                log.debug('Got a remote candidate.', params.candidate);\n\t                that.report.candidatesReceived.push(params.candidate);\n\t            } catch (e) {\n\t                log.error(\"Couldn't add ICE candidate: \" + e.message, params.candidate);\n\t                return;\n\t            }\n\t        } else if (!params.processingQueue) {\n\t            candidateReceivingQueue.push(params.candidate);\n\t            log.debug('Queueing a candidate because no offer yet.');\n\t        }\n\t    };\n\t\n\t    that.call.listen('signal-offer', listenOffer, true);\n\t    that.call.listen('signal-answer', listenAnswer, true);\n\t    that.call.listen('signal-connected', listenConnected, true);\n\t    that.call.listen('signal-modify', listenModify, true);\n\t\n\t    return that;\n\t}; // End respoke.PeerConnection\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar respoke = __webpack_require__(1);\n\tvar Statechart = __webpack_require__(21);\n\tvar Q = __webpack_require__(19);\n\t\n\t/**\n\t * State machine for WebRTC calling, data channels, and screen sharing.\n\t * NOTE: All state transitions are synchronous! However, listeners to the events this class fires will be called\n\t * asynchronously.\n\t * @class respoke.CallState\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {respoke.Call} call\n\t * @link https://cdn.respoke.io/respoke.min.js\n\t * @returns {respoke.CallState}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var fsm;\n\t    var that = respoke.EventEmitter(params);\n\t    that.className = 'respoke.CallState';\n\t\n\t    var allTimers = [];\n\t    var answerTimer;\n\t    var answerTimeout = params.answerTimeout || 10000;\n\t    var receiveAnswerTimer;\n\t    var receiveAnswerTimeout = params.receiveAnswerTimeout || 60000;\n\t    var connectionTimer;\n\t    var connectionTimeout = params.connectionTimeout || 10000;\n\t    var modifyTimer;\n\t    var modifyTimeout = params.modifyTimeout || 60000;\n\t    var oldRole;\n\t\n\t    /*\n\t     * These can quite often result in a condition in which they do not cause a transition to occur.\n\t     * There is at least one \"universal\" (air quotes) event which probably? shouldn't? but may\n\t     * result in a non-transition error when it's OK, and that is the 'reject' event.\n\t     */\n\t    var nontransitionEvents = ['receiveLocalMedia', 'receiveRemoteMedia', 'approve', 'answer', 'sentOffer',\n\t        'receiveAnswer'];\n\t\n\t    function assert(condition) {\n\t        if (!condition) {\n\t            throw new Error(\"Assertion failed.\");\n\t        }\n\t    }\n\t\n\t    that.hasLocalMediaApproval = false;\n\t    that.hasLocalMedia = false;\n\t    that.receivedBye = false;\n\t    that.isAnswered = false;\n\t    that.sentSDP = false;\n\t    that.receivedSDP = false;\n\t    that.processedRemoteSDP = false;\n\t    that.needDirectConnection = !!that.needDirectConnection;\n\t    that.sendOnly = !!that.sendOnly;\n\t    that.receiveOnly = !!that.receiveOnly;\n\t\n\t    // Event\n\t    var rejectEvent = [{\n\t        target: 'connected',\n\t        guard: function (params) {\n\t            // we have any media flowing or data channel open\n\t            if (typeof oldRole === 'boolean') {\n\t                // Reset the role if we have aborted a modify.\n\t                that.caller = oldRole;\n\t            }\n\t\n\t            if (modifyTimer) {\n\t                modifyTimer.clear();\n\t            }\n\t\n\t            return that.hasMedia();\n\t        }\n\t    }, {\n\t        target: 'terminated',\n\t        guard: function (params) {\n\t            params = params || {};\n\t            // we have no media flowing or data channel open\n\t            that.hangupReason = params.reason || \"no media\";\n\t            return !that.hasMedia();\n\t        }\n\t    }];\n\t\n\t    // Event\n\t    function rejectModify() {\n\t        // reject modification\n\t        if (modifyTimer) {\n\t            modifyTimer.clear();\n\t        }\n\t    }\n\t\n\t    // Event\n\t    function clearReceiveAnswerTimer() {\n\t        that.processedRemoteSDP = true;\n\t        if (receiveAnswerTimer) {\n\t            receiveAnswerTimer.clear();\n\t        }\n\t    }\n\t\n\t    // Event\n\t    var hangupEvent = {\n\t        target: 'terminated',\n\t        action: function (params) {\n\t            params = params || {};\n\t            that.signalBye = params.signal;\n\t            that.hangupReason = that.hangupReason || params.reason || \"none\";\n\t        }\n\t    };\n\t\n\t    function needToObtainMedia(params) {\n\t        return (that.needDirectConnection !== true && that.receiveOnly !== true);\n\t    }\n\t\n\t    function needToApproveDirectConnection(params) {\n\t        return (that.needDirectConnection === true && typeof params.previewLocalMedia === 'function');\n\t    }\n\t\n\t    function automaticDirectConnectionCaller(params) {\n\t        return (that.needDirectConnection === true && typeof params.previewLocalMedia !== 'function' &&\n\t            that.caller === true);\n\t    }\n\t\n\t    function createTimer(func, name, time) {\n\t        var id = setTimeout(function () {\n\t            id = null;\n\t            respoke.log.error(name, \"timer expired.\");\n\t            func();\n\t        }, time);\n\t        respoke.log.debug('setting timer', name, 'for', time / 1000, 'secs');\n\t        var timer  = {\n\t            name: name,\n\t            clear: function () {\n\t                if (id === null) {\n\t                    return;\n\t                }\n\t                respoke.log.debug('clearing timer', name);\n\t                clearTimeout(id);\n\t                id = null;\n\t            }\n\t        };\n\t        allTimers.push(timer);\n\t        return timer;\n\t    }\n\t\n\t    var stateParams = {\n\t        initialState: 'idle',\n\t        receiveLocalMedia: function () {\n\t            that.hasLocalMedia = true;\n\t        },\n\t        states: {\n\t            // State\n\t            idle: {\n\t                // Event\n\t                exit: function () {\n\t                    that.fire('idle:exit');\n\t                },\n\t                // Event\n\t                initiate: [{\n\t                    target: 'negotiatingContainer',\n\t                    guard: function (params) {\n\t                        assert(typeof params.client === 'object');\n\t                        assert(typeof params.caller === 'boolean');\n\t                        return (params.caller === true || params.client.hasListeners('call'));\n\t                    }\n\t                }, {\n\t                    target: 'terminated',\n\t                    guard: function (params) {\n\t                        if (params.caller !== true && !params.client.hasListeners('call')) {\n\t                            that.hangupReason = 'no call listener';\n\t                            that.signalBye = true;\n\t                            return true;\n\t                        }\n\t                        return false;\n\t                    }\n\t                }],\n\t                // Event\n\t                hangup: hangupEvent\n\t            },\n\t            // State\n\t            negotiatingContainer: {\n\t                init: \"preparing\",\n\t                // Event\n\t                hangup: hangupEvent,\n\t                // Event\n\t                modify: rejectModify,\n\t                states: {\n\t                    preparing: {\n\t                        // Event\n\t                        entry: {\n\t                            action: function () {\n\t                                that.hasLocalMediaApproval = false;\n\t                                that.hasLocalMedia = false;\n\t                                that.sentSDP = false;\n\t                                that.receivedSDP = false;\n\t                                that.processedRemoteSDP = false;\n\t                                that.isAnswered = false;\n\t                                if (!that.isModifying()) {\n\t                                    answerTimer = createTimer(function () {\n\t                                        that.dispatch('reject', {reason: \"answer own call timer \" + that.caller});\n\t                                    }, 'answer own call', answerTimeout);\n\t                                }\n\t                                that.fire('preparing:entry');\n\t                            }\n\t                        },\n\t                        // Event\n\t                        exit: function () {\n\t                            that.fire('preparing:exit');\n\t                            if (answerTimer) {\n\t                                answerTimer.clear();\n\t                            }\n\t                        },\n\t                        // Event\n\t                        reject: rejectEvent,\n\t                        // Event\n\t                        receiveOffer: {\n\t                            action: function (params) {\n\t                                that.receivedSDP = true;\n\t                                if (that.isAnswered) {\n\t                                    // If we get here, we are the callee and we've answered the call before the call\n\t                                    // creation/receive offer promise chain completed.\n\t                                    setTimeout(function () {\n\t                                        that.dispatch('answer', params);\n\t                                    });\n\t                                }\n\t                            }\n\t                        },\n\t                        // Event\n\t                        answer: [{\n\t                            action: function (params) {\n\t                                assert(!params.previewLocalMedia || typeof params.previewLocalMedia === 'function');\n\t                                that.isAnswered = true;\n\t                                if (typeof params.previewLocalMedia !== 'function') {\n\t                                    that.hasLocalMediaApproval = true;\n\t                                }\n\t                            }\n\t                        }, {\n\t                            // we are going to send media\n\t                            target: 'approvingDeviceAccess',\n\t                            guard: needToObtainMedia\n\t                        }, {\n\t                            // we are sending a direct connection & developer wants to approve\n\t                            target: 'approvingContent',\n\t                            guard: needToApproveDirectConnection\n\t                        }, {\n\t                            target: 'offering',\n\t                            guard: automaticDirectConnectionCaller\n\t                        }, {\n\t                            // we are not sending anything or developer does not want to approve media.\n\t                            target: 'connecting',\n\t                            guard: function (params) {\n\t                                // always for callee, caller will always answer before sending offer.\n\t                                // callee should always answer after receiving offer.\n\t                                if (!that.receivedSDP) {\n\t                                    return false;\n\t                                }\n\t\n\t                                if (needToObtainMedia(params) || needToApproveDirectConnection(params) ||\n\t                                        automaticDirectConnectionCaller(params)) {\n\t                                    return false;\n\t                                }\n\t\n\t                                if (!params.previewLocalMedia || that.receiveOnly) {\n\t                                    setTimeout(function () {\n\t                                        params.approve();\n\t                                    });\n\t                                }\n\t                                return (that.receiveOnly === true || that.needDirectConnection === true);\n\t                            }\n\t                        }]\n\t                    },\n\t                    // State\n\t                    gettingMedia: {\n\t                        reject: rejectEvent,\n\t                        // Event\n\t                        receiveLocalMedia: [{\n\t                            action: function () {\n\t                                that.hasLocalMedia = true;\n\t                            }\n\t                        }, {\n\t                            target: 'offering',\n\t                            guard: function (params) {\n\t                                return (that.caller === true && that.hasLocalMediaApproval === true &&\n\t                                    that.hasLocalMedia === true);\n\t                            }\n\t                        }, {\n\t                            target: 'connecting',\n\t                            guard: function (params) {\n\t                                return (that.caller === false && that.hasLocalMediaApproval === true &&\n\t                                    that.hasLocalMedia === true);\n\t                            }\n\t                        }],\n\t                        states: {\n\t                            // State\n\t                            approvingDeviceAccess: {\n\t                                // Event\n\t                                entry: function () {\n\t                                    that.fire('approving-device-access:entry');\n\t                                },\n\t                                // Event\n\t                                approve: [{\n\t                                    target: 'approvingContent',\n\t                                    guard: function (params) {\n\t                                        return (typeof params.previewLocalMedia === 'function');\n\t                                    }\n\t                                }, {\n\t                                    target: 'connecting',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === false &&\n\t                                            (that.hasLocalMedia === true || that.needDirectConnection === true) &&\n\t                                            typeof params.previewLocalMedia !== 'function');\n\t                                    }\n\t                                }, {\n\t                                    target: 'offering',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === true && that.hasLocalMedia === true &&\n\t                                            typeof params.previewLocalMedia !== 'function');\n\t                                    }\n\t                                }]\n\t                            },\n\t                            // State\n\t                            approvingContent: {\n\t                                // Event\n\t                                entry: function () {\n\t                                    that.fire('approving-content:entry');\n\t                                },\n\t                                // Event\n\t                                exit: function () {\n\t                                    that.fire('approving-content:exit');\n\t                                },\n\t                                // Event\n\t                                approve: [function (params) {\n\t                                    that.hasLocalMediaApproval = true;\n\t                                }, {\n\t                                    target: 'offering',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === true && that.hasLocalMedia === true);\n\t                                    }\n\t                                }, {\n\t                                    target: 'connecting',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === false && that.hasLocalMedia === true);\n\t                                    }\n\t                                }]\n\t                            }\n\t                        }\n\t                    },\n\t                    // State\n\t                    offeringContainer: {\n\t                        init: 'offering',\n\t                        reject: rejectEvent,\n\t                        sentOffer: function () {\n\t                            // start answer timer\n\t                            receiveAnswerTimer = createTimer(function () {\n\t                                that.dispatch('reject', {reason: \"receive answer timer\"});\n\t                            }, 'receive answer', receiveAnswerTimeout);\n\t                        },\n\t                        states: {\n\t                            offering: {\n\t                                // Event\n\t                                entry: function () {\n\t                                    that.fire('offering:entry');\n\t                                },\n\t                                // Event\n\t                                exit: function () {\n\t                                    that.fire('offering:exit');\n\t                                },\n\t                                // Event\n\t                                receiveLocalMedia: [function () {\n\t                                    that.hasLocalMedia = true;\n\t                                }, {\n\t                                    target: 'connected',\n\t                                    guard: function (params) {\n\t                                        // for direct connection, local media is the same as remote media\n\t                                        return (that.needDirectConnection === true);\n\t                                    }\n\t                                }],\n\t                                // Event\n\t                                receiveRemoteMedia: {\n\t                                    target: 'connected'\n\t                                },\n\t                                // Event\n\t                                receiveAnswer: [clearReceiveAnswerTimer, {\n\t                                    target: 'connecting'\n\t                                }]\n\t                            }\n\t                        }\n\t                    },\n\t                    // State\n\t                    connectingContainer: {\n\t                        init: 'connecting',\n\t                        reject: rejectEvent,\n\t                        receiveAnswer: clearReceiveAnswerTimer,\n\t                        states: {\n\t                            connecting: {\n\t                                // Event\n\t                                entry: function () {\n\t                                    that.fire('connecting:entry');\n\t\n\t                                    // set connection timer\n\t                                    connectionTimer = createTimer(function () {\n\t                                        that.dispatch('reject', {reason: \"connection timer\"});\n\t                                    }, 'connection', connectionTimeout);\n\t                                },\n\t                                // Event\n\t                                exit: function () {\n\t                                    if (connectionTimer) {\n\t                                        connectionTimer.clear();\n\t                                    }\n\t                                    if (modifyTimer) {\n\t                                        modifyTimer.clear();\n\t                                    }\n\t                                    that.fire('connecting:exit');\n\t                                },\n\t                                // Event\n\t                                receiveLocalMedia: [{\n\t                                    action: function () {\n\t                                        that.hasLocalMedia = true;\n\t                                    }\n\t                                }, {\n\t                                    target: 'connected',\n\t                                    guard: function (params) {\n\t                                        // for direct connection, local media is the same as remote media\n\t                                        return (that.needDirectConnection === true && that.caller === false);\n\t                                    }\n\t                                }],\n\t                                // Event\n\t                                receiveRemoteMedia: {\n\t                                    target: 'connected'\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            // State\n\t            // This state is for when we are in limbo between connected and negotiating and we are\n\t            // trying to figure out if the other side will allow us to modify. If we receive modify in\n\t            // this state, we will reject it. If the other party is in connected, we will be able to modify.\n\t            modifyingContainer: {\n\t                init: 'modifying',\n\t                reject: rejectEvent,\n\t                // Event\n\t                modify: rejectModify,\n\t                // Event\n\t                hangup: hangupEvent,\n\t                states: {\n\t                    modifying: {\n\t                        // Event\n\t                        entry: function () {\n\t                            modifyTimer = createTimer(function () {\n\t                                that.dispatch('reject', {reason: \"modify timer\"});\n\t                            }, 'modify for caller', modifyTimeout);\n\t                            that.fire('modifying:entry');\n\t                        },\n\t                        // Event\n\t                        accept: [function () {\n\t                            that.caller = true;\n\t                        }, {\n\t                            target: 'preparing'\n\t                        }],\n\t                        // Event\n\t                        exit: function () {\n\t                            that.fire('modifying:exit');\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            // State\n\t            connectedContainer: {\n\t                init: 'connected',\n\t                reject: {\n\t                    target: 'terminated',\n\t                    action: function (params) {\n\t                        that.hangupReason = params.reason || \"got reject while connected\";\n\t                    }\n\t                },\n\t                receiveAnswer: clearReceiveAnswerTimer,\n\t                // Event\n\t                hangup: hangupEvent,\n\t                states: {\n\t                    connected: {\n\t                        // Event\n\t                        entry: function () {\n\t                            oldRole = that.caller;\n\t                            that.needDirectConnection = false;\n\t                            that.fire('connected:entry');\n\t                        },\n\t                        // Event\n\t                        exit: function () {\n\t                            that.fire('connected:exit');\n\t                        },\n\t                        // Event\n\t                        modify: [{\n\t                            // be notified that the other side would like modification\n\t                            target: 'preparing',\n\t                            guard: function (params) {\n\t                                params = params || {};\n\t                                if (params.receive === true) {\n\t                                    that.caller = false;\n\t                                    modifyTimer = createTimer(function () {\n\t                                        // If modify gets interrupted, go back to previous roles.\n\t                                        that.dispatch('reject', {reason: \"modify timer\"});\n\t                                    }, 'modify', modifyTimeout);\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }, {\n\t                            // request to begin modification\n\t                            target: 'modifying',\n\t                            guard: function (params) {\n\t                                params = params || {};\n\t                                return (params.receive !== true);\n\t                            }\n\t                        }]\n\t                    }\n\t                }\n\t            },\n\t            // State\n\t            terminatedContainer: {\n\t                init: 'terminated',\n\t                states: {\n\t                    terminated: {\n\t                        // Event\n\t                        entry: {\n\t                            action: function () {\n\t                                that.fire('terminated:entry');\n\t                                allTimers.forEach(function (timer) {\n\t                                    timer.clear();\n\t                                });\n\t                                setTimeout(function () {\n\t                                    fsm = null;\n\t                                    that.ignore();\n\t                                });\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    stateParams.that = Object.create(Statechart);\n\t    fsm = respoke.Class(stateParams);\n\t    fsm.run({\n\t        // rename to 'debug' to enable\n\t        debugOff: function () {\n\t            // So we can print the caller. Debug most often used when testing & tests run in the same tab.\n\t            var args = Array.prototype.slice.call(arguments);\n\t            args.splice(0, 0, that.caller);\n\t            respoke.log.debug.apply(respoke.log, args);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Return the name of the current state.\n\t     * @memberof! respoke.CallState\n\t     * @method respoke.Call.getState\n\t     * @returns {string}\n\t     */\n\t    that.getState = function () {\n\t        if (!fsm) {\n\t            return 'terminated';\n\t        }\n\t        return fsm.currentState().name;\n\t    };\n\t\n\t    /**\n\t     * Synchronously dispatch an event, which may or may not change the state.\n\t     * @memberof! respoke.CallState\n\t     * @method respoke.Call.dispatch\n\t     */\n\t    that.dispatch = function (evt, args) {\n\t        var oldState;\n\t        var newState;\n\t\n\t        if (!fsm) {\n\t            return;\n\t        }\n\t\n\t        oldState = that.getState();\n\t        try {\n\t            fsm.dispatch(evt, args);\n\t        } catch (err) {\n\t            respoke.log.debug('error dispatching', evt, 'from', oldState, \"with\", args, err);\n\t            throw err;\n\t        }\n\t        newState = that.getState();\n\t        if (oldState === newState && nontransitionEvents.indexOf(evt) === -1) {\n\t            respoke.log.debug(that.caller, \"Possible bad event \" + evt + \", no transition occured.\");\n\t        }\n\t        respoke.log.debug(that.caller, 'dispatching', evt, 'moving from ', oldState, 'to', newState, args);\n\t    };\n\t\n\t    /**\n\t     * Determine whether or not we are in the middle of a call modification.\n\t     * @memberof! respoke.CallState\n\t     * @method respoke.Call.isModifying\n\t     * @returns {boolean}\n\t     */\n\t    that.isModifying = function () {\n\t        var modifyingStates = ['preparing', 'modifying', 'approvingDeviceAccess', 'approvingMedia', 'offering'];\n\t        return (modifyingStates.indexOf(that.getState()) > -1 && that.hasMedia());\n\t    };\n\t\n\t    /**\n\t     * Helper for testing state name\n\t     * @memberof! respoke.CallState\n\t     * @method respoke.Call.isState\n\t     * @param {string} name\n\t     * @returns {boolean}\n\t     */\n\t    that.isState = function (name) {\n\t        return (that.getState() === name);\n\t    };\n\t\n\t    assert(typeof that.hasMedia === 'function');\n\t    assert(typeof that.caller === 'boolean');\n\t    return that;\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(19);\n\tvar log = __webpack_require__(18);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A `respoke.Call` is Respoke's interface into a WebRTC call, including getUserMedia, path and codec negotation,\n\t * and call state.\n\t *\n\t * There are several methods on an instance of `respoke.Client` which return a `respoke.Call`.\n\t *\n\t * @class respoke.Call\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @param {boolean} params.caller - whether or not we initiated the call\n\t * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t * @param {boolean} [params.sendOnly] - whether or not we send media\n\t * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t * relay servers. If it cannot flow through relay servers, the call will fail.\n\t * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t * required to flow peer-to-peer. If it cannot, the call will fail.\n\t * @param {respoke.Endpoint} params.remoteEndpoint - The endpoint who is being called.\n\t * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint.\n\t * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t * wants to perform an action between local media becoming available and calling approve().\n\t * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n\t * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n\t * @param {function} params.signalReport - Signaling action from SignalingChannel.\n\t * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n\t * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t * media renegotiation.\n\t * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t * element with the local audio and/or video attached.\n\t * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n\t * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n\t * it was ended in a graceful manner. TODO: add the hangup reason to the Event.\n\t * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t * This callback will be called when media is muted or unmuted.\n\t * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t * for the user to give permission to start getting audio or video.\n\t * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t * the approval was automatic.\n\t * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n\t * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n\t * granted by the browser without asking the user to approve it.\n\t * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local video attached to it.\n\t * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n\t * @returns {respoke.Call}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * A name to identify the type of object.\n\t     * @memberof! respoke.Call\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Call';\n\t\n\t    /**\n\t     * Whether or not the client is the caller of the call.\n\t     * @memberof! respoke.Call\n\t     * @name caller\n\t     * @type {boolean}\n\t     */\n\t    that.caller = !!that.caller;\n\t\n\t    /**\n\t     * The call ID.\n\t     * @memberof! respoke.Call\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = that.caller ? respoke.makeGUID() : that.id;\n\t\n\t    if (!that.id) {\n\t        throw new Error(\"Can't start a new call without a call id.\");\n\t    }\n\t\n\t    /**\n\t     * Promise used to trigger actions dependant upon having received media or a datachannel.\n\t     * @memberof! respoke.Call\n\t     * @name defMedia\n\t     * @private\n\t     * @type {Promise}\n\t     */\n\t    var defMedia = Q.defer();\n\t    /**\n\t     * Promise used to trigger notification of a request for renegotiating media. For the caller of the\n\t     * renegotiation (which doesn't have to be the same as the caller of the call), this is resolved\n\t     * or rejected as soon as the 'accept' or 'reject' signal is received. For the callee, it is\n\t     * resolved or rejected only after the developer or user approves or rejects the modify.\n\t     * @memberof! respoke.Call\n\t     * @name defModify\n\t     * @private\n\t     * @type {Promise}\n\t     */\n\t    var defModify;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name previewLocalMedia\n\t     * @private\n\t     * @type {respoke.Call.previewLocalMedia}\n\t     */\n\t    var previewLocalMedia = params.previewLocalMedia;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.getClient}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name signalingChannel\n\t     * @private\n\t     * @type {respoke.signalingChannel}\n\t     */\n\t    var signalingChannel = params.signalingChannel;\n\t    /**\n\t     * Informational property. Whether call debugs were enabled on the client during creation.\n\t     * Changing this value will do nothing.\n\t     * @name enableCallDebugReport\n\t     * @type {boolean}\n\t     */\n\t    that.enableCallDebugReport = params.signalingChannel.isSendingReport();\n\t    /**\n\t     * A flag indicating whether this call has audio.\n\t     *\n\t     * This becomes available after the call is accepted, for the client being called only.\n\t     *\n\t     * @name hasAudio\n\t     * @type {boolean}\n\t     */\n\t    that.hasAudio = undefined;\n\t    /**\n\t     * A flag indicating whether this call has video.\n\t     *\n\t     * This becomes available after the call is accepted, for the client being called only.\n\t     *\n\t     * @name hasVideo\n\t     * @type {boolean}\n\t     */\n\t    that.hasVideo = undefined;\n\t\n\t    /**\n\t     * Local media that we are sending to the remote party.\n\t     * @name outgoingMedia\n\t     * @type {respoke.LocalMedia}\n\t     */\n\t    that.outgoingMedia = respoke.LocalMedia({\n\t        instanceId: instanceId,\n\t        callId: that.id,\n\t        constraints: params.constraints || {\n\t            video: true,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Remote media that we are receiving from the remote party.\n\t     * @name incomingMedia\n\t     * @type {respoke.RemoteMedia}\n\t     */\n\t    that.incomingMedia = respoke.RemoteMedia({\n\t        instanceId: instanceId,\n\t        callId: that.id,\n\t        constraints: params.constraints\n\t    });\n\t\n\t    /**\n\t     * This event indicates that local video has been unmuted.\n\t     * @event respoke.Call#mute\n\t     * @property {string} name - the event name.\n\t     * @property {respoke.Call} target\n\t     * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t     * has been changed.\n\t     * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t     */\n\t    that.outgoingMedia.listen('mute', function (evt) {\n\t        that.fire('mute', {\n\t            type: evt.type,\n\t            muted: evt.muted\n\t        });\n\t    });\n\t\n\t    delete params.signalingChannel;\n\t    delete that.signalingChannel;\n\t\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name videoIsMuted\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var videoIsMuted = false;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name audioIsMuted\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var audioIsMuted = false;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name directConnection\n\t     * @private\n\t     * @type {respoke.DirectConnection}\n\t     */\n\t    var directConnection = null;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name toSendHangup\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var toSendHangup = null;\n\t\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name pc\n\t     * @private\n\t     * @type {respoke.PeerConnection}\n\t     */\n\t    var pc = respoke.PeerConnection({\n\t        instanceId: instanceId,\n\t        state: respoke.CallState({\n\t            caller: that.caller,\n\t            needDirectConnection: params.needDirectConnection,\n\t            sendOnly: params.sendOnly,\n\t            receiveOnly: params.receiveOnly,\n\t            // hasMedia is not defined yet.\n\t            hasMedia: function () {\n\t                return that.hasMedia();\n\t            }\n\t        }),\n\t        forceTurn: !!params.forceTurn,\n\t        call: that,\n\t        pcOptions: {\n\t            optional: [\n\t                { DtlsSrtpKeyAgreement: true },\n\t                { RtpDataChannels: false }\n\t            ]\n\t        },\n\t        offerOptions: params.offerOptions || null,\n\t        signalOffer: function (args) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            params.signalOffer(args);\n\t            pc.state.dispatch('sentOffer');\n\t        },\n\t        signalConnected: params.signalConnected,\n\t        signalAnswer: params.signalAnswer,\n\t        signalModify: params.signalModify,\n\t        signalHangup: params.signalHangup,\n\t        signalReport: params.signalReport,\n\t        signalCandidate: params.signalCandidate\n\t    });\n\t\n\t    /**\n\t     * Set up promises. If we're not the caller, we need to listen for approval AND the remote SDP to come in\n\t     * before we can act on the call. Save parameters sent in with the constructor, then delete them off the call.\n\t     * If this call was initiated with a DirectConnection, set it up so answer() will be the approval mechanism.\n\t     * @method respoke.Call.init\n\t     * @memberof! respoke.Call\n\t     * @fires respoke.Client#call\n\t     * @private\n\t     */\n\t    function init() {\n\t        log.debug('Call.init');\n\t\n\t        if (defModify !== undefined) {\n\t            defMedia = Q.defer();\n\t        }\n\t\n\t        pc.init(); // instantiates RTCPeerConnection, can't call on modify\n\t        if (defModify === undefined && pc.state.needDirectConnection === true) {\n\t            actuallyAddDirectConnection(params);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Register any event listeners passed in as callbacks, save other params to answer() and accept().\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.saveParameters\n\t     * @param {object} params\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n\t     * it was ended in a graceful manner. TODO: add the hangup reason to the Event.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will fire even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n\t     * user's media.  This event gets fired even if the allow process is automatic, i. e., permission and media is\n\t     * granted by the browser without asking the user to approve it.\n\t     * @param {object} [params.constraints]\n\t     * @param {boolean} [params.forceTurn]\n\t     * @param {boolean} [params.receiveOnly]\n\t     * @param {boolean} [params.sendOnly]\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local video attached to it.\n\t     * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n\t     * @private\n\t     * @fires respoke.Call#stats\n\t     */\n\t    function saveParameters(params) {\n\t        /* This happens when the call is hung up automatically, for instance due to the lack of an onCall\n\t         * handler. In this case, pc has been set to null in hangup. The call has already failed, and the\n\t         * invocation of this function is an artifact of async code not being finished yet, so we can just\n\t         * skip all of this setup.\n\t         */\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        that.listen('local-stream-received', params.onLocalMedia);\n\t        that.listen('connect', params.onConnect);\n\t        that.listen('hangup', params.onHangup);\n\t        that.listen('allow', params.onAllow);\n\t        that.listen('answer', params.onAnswer);\n\t        that.listen('approve', params.onApprove);\n\t        that.listen('mute', params.onMute);\n\t        that.listen('requesting-media', params.onRequestingMedia);\n\t\n\t        previewLocalMedia = typeof params.previewLocalMedia === 'function' ?\n\t            params.previewLocalMedia : previewLocalMedia;\n\t\n\t        pc.state.receiveOnly = typeof params.receiveOnly === 'boolean' ? params.receiveOnly : pc.state.receiveOnly;\n\t        pc.state.sendOnly = typeof params.sendOnly === 'boolean' ? params.sendOnly : pc.state.sendOnly;\n\t        pc.state.needDirectConnection = typeof params.needDirectConnection === 'boolean' ?\n\t            params.needDirectConnection : pc.state.needDirectConnection;\n\t        pc.disableTurn = params.disableTurn || pc.disableTurn;\n\t        pc.forceTurn = typeof params.forceTurn === 'boolean' ? params.forceTurn : pc.forceTurn;\n\t\n\t        that.outgoingMedia.constraints = params.constraints || that.outgoingMedia.constraints;\n\t        that.outgoingMedia.element = params.videoLocalElement || that.outgoingMedia.element;\n\t        if (pc.state.caller === true) {\n\t            // Only the person who initiated this round of media negotiation needs to estimate remote\n\t            // media based on what constraints local media is using.\n\t            that.incomingMedia.setConstraints(that.outgoingMedia.constraints);\n\t        }\n\t        that.incomingMedia.element = params.videoRemoteElement || that.incomingMedia.element;\n\t\n\t        pc.listen('stats', function fireStats(evt) {\n\t            /**\n\t             * This event is fired every time statistical information about audio and/or video on a call\n\t             * becomes available.\n\t             * @event respoke.Call#stats\n\t             * @type {respoke.Event}\n\t             * @property {respoke.MediaStats} stats - an object with stats in it.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('stats', {stats: evt.stats});\n\t        }, true);\n\t\n\t        delete that.signalOffer;\n\t        delete that.signalConnected;\n\t        delete that.signalAnswer;\n\t        delete that.signalHangup;\n\t        delete that.signalReport;\n\t        delete that.signalCandidate;\n\t    }\n\t\n\t    /**\n\t     * Answer the call and start the process of obtaining media. This method is called automatically on the caller's\n\t     * side. This method must be called on the callee's side to indicate that the endpoint does wish to accept the\n\t     * call. The app will have a later opportunity, by passing a callback named previewLocalMedia, to approve or\n\t     * reject the call based on whether audio and/or video is working and is working at an acceptable level.\n\t     *\n\t     *     client.listen('call', function (evt) {\n\t     *         if (!evt.call.caller) {\n\t     *             evt.call.answer();\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.answer\n\t     * @fires respoke.Call#answer\n\t     * @param {object} [params]\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n\t     * it was ended in a graceful manner. TODO: add the hangup reason to the Event.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n\t     * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n\t     * granted by the browser without asking the user to approve it.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n\t     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n\t     * @param {object} [params.constraints] - Information about the media for this call.\n\t     * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local video attached to it.\n\t     * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n\t     */\n\t    that.answer = function (params) {\n\t        params = params || {};\n\t        log.debug('Call.answer');\n\t\n\t        saveParameters(params);\n\t\n\t        pc.listen('connect', onRemoteStreamAdded, true);\n\t        pc.listen('remote-stream-removed', onRemoteStreamRemoved, true);\n\t\n\t        pc.state.once('approving-device-access:entry', function (evt) {\n\t            doAddVideo(params);\n\t        });\n\t        pc.state.dispatch('answer', {\n\t            previewLocalMedia: previewLocalMedia,\n\t            approve: that.approve\n\t        });\n\t        /**\n\t         * The call was answered.\n\t         * @event respoke.Call#answer\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('answer');\n\t    };\n\t\n\t    /**\n\t     * Accept a request to modify the media on the call. This method should be called within the Call#modify\n\t     * event listener, which gives the developer or website user a chance to see what changes are proposed and\n\t     * to accept or reject them.\n\t     *\n\t     *     call.listen('modify', function (evt) {\n\t     *         evt.call.accept();\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.accept\n\t     * @fires respoke.Call#accept\n\t     * @private\n\t     * @param {object} [params]\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the developer to receive the\n\t     * remote video element.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n\t     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n\t     * @param {object} [params.constraints] - Information about the media for this call.\n\t     */\n\t    that.accept = that.answer;\n\t\n\t    /**\n\t     * Start the process of network and media negotiation. If the app passes in a callback named previewLocalMedia\n\t     * in order to allow the logged-in person a chance to base their decision to continue the call on whether\n\t     * audio and/or video is working correctly,\n\t     * this method must be called on both sides in order to begin the call. If call.approve() is called, the call\n\t     * will progress as expected. If call.reject() is called, the call will be aborted.\n\t     *\n\t     *     call.listen('local-stream-received', function (evt) {\n\t     *         if (userLikesVideo()) {\n\t     *             evt.call.approve();\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.approve\n\t     * @fires respoke.Call#approve\n\t     */\n\t    that.approve = function () {\n\t        log.debug('Call.approve');\n\t        /**\n\t         * Fired when the local media access is approved.\n\t         *\n\t         * @event respoke.Call#approve\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('approve');\n\t        pc.state.dispatch('approve', {\n\t            previewLocalMedia: previewLocalMedia\n\t        });\n\t\n\t        if (defModify && defModify.promise.isPending()) {\n\t            defModify.resolve(true);\n\t            defModify = undefined;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Listen for the remote side to remove media in the middle of the call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.onRemoteStreamRemoved\n\t     * @private\n\t     * @param {object}\n\t     */\n\t    function onRemoteStreamRemoved(evt) {\n\t        log.debug('pc event: remote stream removed');\n\t    }\n\t\n\t    /**\n\t     * Listen for the remote side to add additional media in the middle of the call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.onRemoteStreamAdded\n\t     * @private\n\t     * @param {object}\n\t     * @fires respoke.Call#connect\n\t     */\n\t    function onRemoteStreamAdded(evt) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        log.debug('received remote media', evt);\n\t\n\t        that.incomingMedia.setStream(evt.stream);\n\t\n\t        /**\n\t         * Indicates that a remote media stream has been added to the call.\n\t         *\n\t         * @event respoke.Call#connect\n\t         * @event respoke.LocalMedia#connect\n\t         * @type {respoke.Event}\n\t         * @property {Element} element - The HTML5 Video element with the remote stream attached.\n\t         * @property {respoke.RemoteMedia} stream - The incomingMedia property on the call.\n\t         * @property {string} name - The event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        pc.state.dispatch('receiveRemoteMedia');\n\t        that.fire('connect', {\n\t            stream: evt.stream,\n\t            element: that.incomingMedia.element\n\t        });\n\t    }\n\t\n\t    /**\n\t     * ## The plugin `respoke.MediaStats` must be loaded before using this method.\n\t     *\n\t     * Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\n\t     * Since we have to wait for both the answer and offer to be available before starting\n\t     * statistics, the library returns a promise for the stats object. The statistics object does not contain the\n\t     * statistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\n\t     * the actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\n\t     * stream of statistics every `interval` seconds.  Returns null if stats module is not loaded.\n\t     *\n\t     *     call.getStats({\n\t     *         onStats: function (evt) {\n\t     *             console.log('Stats', evt.stats);\n\t     *         }\n\t     *     }).done(function () {\n\t     *         console.log('Stats started');\n\t     *     }, function (err) {\n\t     *         console.log('Call is already hung up.');\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getStats\n\t     * @param {object} params\n\t     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive\n\t     * the stats. If no callback is provided, the call's report will contain stats but the developer will not\n\t     * receive them on the client-side.\n\t     * @param {respoke.Call.statsSuccessHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Call.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n\t     * @returns {Promise<object>|null}\n\t     */\n\t    function getStats(params) {\n\t        if (pc && pc.getStats) {\n\t            that.listen('stats', params.onStats);\n\t            return pc.getStats(params);\n\t        }\n\t        return null;\n\t    }\n\t    if (respoke.MediaStats) {\n\t        that.getStats = getStats;\n\t    }\n\t\n\t    /**\n\t     * Return local video element with the logged-in endpoint's audio and/or video streams attached to it.\n\t     *\n\t     *     var el = call.getLocalElement();\n\t     *     container.append(el);\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getLocalElement\n\t     * @returns {Video} An HTML5 video element.\n\t     */\n\t    that.getLocalElement = function () {\n\t        return that.outgoingMedia.element;\n\t    };\n\t\n\t    /**\n\t     * Return remote video element with the remote endpoint's audio and/or video streams attached to it.\n\t     *\n\t     *     var el = call.getRemoteElement();\n\t     *     container.append(el);\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getRemoteElement\n\t     * @returns {Video} An HTML5 video element.\n\t     */\n\t    that.getRemoteElement = function () {\n\t        return that.incomingMedia.element;\n\t    };\n\t\n\t    /**\n\t     * Create the RTCPeerConnection and add handlers. Process any offer we have already received. This method is called\n\t     * after answer() so we cannot use this method to set up the DirectConnection.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.doAddVideo\n\t     * @private\n\t     * @param {object} params\n\t     * @param {object} [params.constraints] - getUserMedia constraints\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect]\n\t     * @param {respoke.Call.onHangup} [params.onHangup]\n\t     * @fires respoke.Call#requesting-media\n\t     * @fires respoke.Call#allow\n\t     * @fires respoke.Call#local-stream-received\n\t     */\n\t    function doAddVideo(params) {\n\t        log.debug('Call.doAddVideo');\n\t        saveParameters(params);\n\t        that.outgoingMedia.listen('requesting-media', function waitAllowHandler(evt) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            /**\n\t             * The browser is asking for permission to access the User's media. This would be an ideal time\n\t             * to modify the UI of the application so that the user notices the request for permissions\n\t             * and approves it.\n\t             * @event respoke.Call#requesting-media\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.fire('requesting-media');\n\t        }, true);\n\t        that.outgoingMedia.listen('allow', function allowHandler(evt) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            /**\n\t             * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n\t             * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n\t             * even if the allow process is automatic, i. e., permission and media is granted by the browser\n\t             * without asking the user to approve it.\n\t             * @event respoke.Call#allow\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.fire('allow');\n\t            pc.state.dispatch('approve', {\n\t                previewLocalMedia: previewLocalMedia\n\t            });\n\t        }, true);\n\t        that.outgoingMedia.listen('stream-received', function streamReceivedHandler(evt) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            defMedia.resolve(that.outgoingMedia);\n\t            pc.addStream(evt.stream);\n\t            pc.state.dispatch('receiveLocalMedia');\n\t            if (typeof previewLocalMedia === 'function') {\n\t                previewLocalMedia(evt.element, that);\n\t            }\n\t\n\t            /**\n\t             * @event respoke.Call#local-stream-received\n\t             * @type {respoke.Event}\n\t             * @property {Element} element\n\t             * @property {respoke.LocalMedia} stream\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.fire('local-stream-received', {\n\t                element: evt.element,\n\t                stream: that.outgoingMedia\n\t            });\n\t        }, true);\n\t        that.outgoingMedia.listen('error', function errorHandler(evt) {\n\t            pc.state.dispatch('reject', {reason: 'media stream error'});\n\t            pc.report.callStoppedReason = evt.reason;\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('error', {\n\t                reason: evt.reason\n\t            });\n\t        });\n\t\n\t        that.outgoingMedia.start();\n\t        return that.outgoingMedia;\n\t    }\n\t\n\t    /**\n\t     * Add a video and audio stream to the existing call. By default, this method adds both video AND audio.\n\t     * If audio is not desired, pass {audio: false}.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addVideo\n\t     * @private\n\t     * @param {object} params\n\t     * @param {boolean} [params.audio=true]\n\t     * @param {boolean} [params.video=true]\n\t     * @param {object} [params.constraints] - getUserMedia constraints, indicating the media being requested is\n\t     * an audio and/or video stream.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect]\n\t     * @param {respoke.Call.onHangup} [params.onHangup]\n\t     * @param {respoke.Call.mediaSuccessHandler} [params.onSuccess]\n\t     * @param {respoke.Client.errorHandler} [params.onError]\n\t     * @returns {Promise<respoke.LocalMedia>}\n\t     */\n\t    that.addVideo = function (params) {\n\t        log.debug('Call.addVideo');\n\t        params = params || {};\n\t        params.constraints = params.constraints || {video: true, audio: true};\n\t        params.constraints.audio = typeof params.audio === 'boolean' ? params.audio : params.constraints.audio;\n\t        params.constraints.video = typeof params.video === 'boolean' ? params.video : params.constraints.video;\n\t        params.instanceId = instanceId;\n\t\n\t        if (!defMedia.promise.isFulfilled()) { // we're the callee & have just accepted to modify\n\t            doAddVideo(params);\n\t        } else { // we're the caller and need to see if we can modify\n\t            pc.startModify({\n\t                constraints: params.constraints\n\t            });\n\t            defModify = Q.defer();\n\t            defModify.promise.then(function modifyAccepted() {\n\t                doAddVideo(params);\n\t            });\n\t        }\n\t        return defModify.promise;\n\t    };\n\t\n\t    /**\n\t     * Add an audio stream to the existing call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addAudio\n\t     * @private\n\t     * @param {object} params\n\t     * @param {boolean} [params.audio=true]\n\t     * @param {boolean} [params.video=false]\n\t     * @param {object} [params.constraints] - getUserMedia constraints, indicating the media being requested is\n\t     * an audio and/or video stream.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect]\n\t     * @param {respoke.Call.onHangup} [params.onHangup]\n\t     * @param {respoke.Call.mediaSuccessHandler} [params.onSuccess]\n\t     * @param {respoke.Client.errorHandler} [params.onError]\n\t     * @returns {Promise<respoke.LocalMedia>}\n\t     */\n\t    that.addAudio = function (params) {\n\t        params = params || {};\n\t        params.constraints = params.constraints || {video: false, audio: true};\n\t        params.constraints.video = typeof params.constraints.video === 'boolean' ?\n\t            params.constraints.video : false;\n\t        params.constraints.audio = typeof params.audio === 'boolean' ? params.audio : params.constraints.audio;\n\t        params.constraints.video = typeof params.video === 'boolean' ? params.video : params.constraints.video;\n\t        return that.addVideo(params);\n\t    };\n\t\n\t    /**\n\t     * Get the direct connection on this call, if it exists.\n\t     *\n\t     *     var dc = call.getDirectConnection();\n\t     *     if (!dc) {\n\t     *         console.log(\"No direct connection has been started.\");\n\t     *     } else {\n\t     *         dc.sendMessage({message: 'hi'});\n\t     *     }\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getDirectConnection\n\t     * @returns {respoke.DirectConnection}\n\t     */\n\t    that.getDirectConnection = function () {\n\t        return directConnection || null;\n\t    };\n\t\n\t    /**\n\t     * Remove a direct connection from the existing call. If there is no other media, this will hang up the call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.removeDirectConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @arg {boolean} [params.skipModify] Do not restart media negotiation.\n\t     */\n\t    that.removeDirectConnection = function (params) {\n\t        params = params || {};\n\t        log.debug('Call.removeDirectConnection');\n\t\n\t        if (directConnection && directConnection.isActive()) {\n\t            directConnection.close({skipRemove: true});\n\t        }\n\t\n\t        if (!that.hasMedia()) {\n\t            log.debug('Hanging up because there are no local streams.');\n\t            that.hangup();\n\t            return;\n\t        }\n\t\n\t        if (params.skipModify === true) {\n\t            return;\n\t        }\n\t\n\t        pc.startModify({\n\t            directConnection: false\n\t        });\n\t        defModify = Q.defer();\n\t        defModify.promise.done(function onModifySuccess() {\n\t            defMedia.resolve();\n\t            defModify = undefined;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Add a direct connection to the existing call.\n\t     *\n\t     *     call.addDirectConnection({\n\t     *         onOpen: function (evt) {\n\t     *             console.log(\"Direct connection open!\");\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addDirectConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n\t     * closing the connection.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n\t     * opening the connection.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n\t     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n\t     * respoke.Endpoint#message.\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n\t     * @param {respoke.Client.errorHandler} [params.onError]\n\t     * @returns {Promise<respoke.DirectConnection>}\n\t     */\n\t    that.addDirectConnection = function (params) {\n\t        log.debug('Call.addDirectConnection');\n\t        pc.startModify({\n\t            directConnection: true\n\t        });\n\t        defModify = Q.defer();\n\t        return defModify.promise.then(function onModifySuccess() {\n\t            return actuallyAddDirectConnection(params);\n\t        }, function onModifyError(err) {\n\t            throw err;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Add a direct connection to the existing call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.actuallyAddDirectConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n\t     * closing the connection.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n\t     * opening the connection.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n\t     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n\t     * respoke.Endpoint#message.\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n\t     * @param {respoke.Client.errorHandler} [params.onError]\n\t     * @returns {Promise<respoke.DirectConnection>}\n\t     * @fires respoke.Client#direct-connection\n\t     * @fires respoke.Call#direct-connection\n\t     */\n\t    function actuallyAddDirectConnection(params) {\n\t        log.debug('Call.actuallyAddDirectConnection', params);\n\t        params = params || {};\n\t        defMedia.promise.then(params.onSuccess, params.onError);\n\t\n\t        if (directConnection && directConnection.isActive()) {\n\t            if (defMedia.promise.isPending()) {\n\t                defMedia.resolve(directConnection);\n\t            } else {\n\t                log.warn(\"Not creating a new direct connection.\");\n\t            }\n\t            return defMedia.promise;\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t        params.pc = pc;\n\t        params.call = that;\n\t\n\t        directConnection = respoke.DirectConnection(params);\n\t\n\t        directConnection.listen('close', function closeHandler() {\n\t            if (!that.hasMedia()) {\n\t                log.debug('Hanging up because there are no local streams.');\n\t                that.hangup();\n\t            } else {\n\t                if (directConnection && directConnection.isActive()) {\n\t                    that.removeDirectConnection({skipModify: true});\n\t                }\n\t            }\n\t        }, true);\n\t\n\t        directConnection.listen('accept', function acceptHandler() {\n\t            if (pc.state.caller === false) {\n\t                log.debug('Answering as a result of approval.');\n\t            } else {\n\t                defMedia.resolve(directConnection);\n\t            }\n\t        }, true);\n\t\n\t        directConnection.listen('open', function openHandler() {\n\t            pc.state.dispatch('receiveRemoteMedia');\n\t        }, true);\n\t\n\t        directConnection.listen('error', function errorHandler(err) {\n\t            defMedia.reject(new Error(err));\n\t        }, true);\n\t\n\t        that.remoteEndpoint.directConnection = directConnection;\n\t\n\t        /**\n\t         * This event is fired when the local end of the directConnection is available. It still will not be\n\t         * ready to send and receive messages until the 'open' event fires.\n\t         * @event respoke.Call#direct-connection\n\t         * @type {respoke.Event}\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('direct-connection', {\n\t            directConnection: directConnection,\n\t            endpoint: that.remoteEndpoint\n\t        });\n\t\n\t        /**\n\t         * This event is fired when the logged-in endpoint is receiving a request to open a direct connection\n\t         * to another endpoint.  If the user wishes to allow the direct connection, calling\n\t         * evt.directConnection.accept() will allow the connection to be set up.\n\t         * @event respoke.Client#direct-connection\n\t         * @type {respoke.Event}\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         * @private\n\t         */\n\t        client.fire('direct-connection', {\n\t            directConnection: directConnection,\n\t            endpoint: that.remoteEndpoint\n\t        });\n\t\n\t        if (pc.state.caller === true) {\n\t            directConnection.accept();\n\t        }\n\t\n\t        return defMedia.promise;\n\t    }\n\t\n\t    /**\n\t     * Close the direct connection.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.closeDirectConnection\n\t     */\n\t    that.closeDirectConnection = function () {\n\t        if (directConnection) {\n\t            directConnection.close();\n\t            directConnection = null;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n\t     * signal is not false and we have not received a hangup signal from the remote party.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.hangup\n\t     * @fires respoke.Call#hangup\n\t     * @param {object} params\n\t     * @arg {boolean} params.signal Optional flag to indicate whether to send or suppress sending\n\t     * a hangup signal to the remote side.\n\t     */\n\t    that.hangup = function (params) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        params = params || {};\n\t        params.reason = params.reason || \"hangup method called.\";\n\t        pc.state.dispatch('hangup', params);\n\t    };\n\t    that.hangup = respoke.once(that.hangup);\n\t\n\t    /**\n\t     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n\t     * signal is not false and we have not received a hangup signal from the remote party. This is an event\n\t     * handler added to the state machine via `once`.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.hangup\n\t     * @fires respoke.Call#hangup\n\t     * @private\n\t     */\n\t    var doHangup = function () {\n\t        log.debug('hangup', that.caller);\n\t\n\t        that.outgoingMedia.stop();\n\t\n\t        if (directConnection && directConnection.isActive()) {\n\t            directConnection.close();\n\t            that.remoteEndpoint.directConnection = null;\n\t            directConnection.ignore();\n\t            directConnection = null;\n\t        }\n\t\n\t        if (pc) {\n\t            pc.close({signal: (pc.state.receivedBye ? false : pc.state.signalBye)});\n\t        }\n\t\n\t        /**\n\t         * This event is fired when the call has hung up.\n\t         * @event respoke.Call#hangup\n\t         * @type {respoke.Event}\n\t         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('hangup', {\n\t            reason: pc.state.hangupReason || \"No reason specified.\"\n\t        });\n\t\n\t        pc.state.ignore();\n\t        pc.ignore();\n\t        that.ignore();\n\t        pc = null;\n\t    };\n\t    doHangup = respoke.once(doHangup);\n\t\n\t    /**\n\t     * Expose hangup as reject for approve/reject workflow.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.reject\n\t     * @param {object} params\n\t     */\n\t    that.reject = function () {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        pc.state.dispatch('reject', {reason: 'call.reject() called'});\n\t    };\n\t\n\t    /**\n\t     * Indicate whether a call is being setup or is in progress.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.isActive\n\t     * @returns {boolean}\n\t     */\n\t    that.isActive = function () {\n\t        // TODO: make this look for remote streams, too. Want to make this handle one-way media calls.\n\t        return !!(pc && pc.isActive() && (\n\t            (that.outgoingMedia.hasMedia()) ||\n\t            (directConnection && directConnection.isActive())\n\t        ));\n\t    };\n\t\n\t    /**\n\t     * Save the offer so we can tell the browser about it after the PeerConnection is ready.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.listenOffer\n\t     * @param {object} evt\n\t     * @param {object} evt.signal - The offer signal including the sdp\n\t     * @private\n\t     * @fires respoke.Call#modify\n\t     */\n\t    function listenOffer(evt) {\n\t        log.debug('listenOffer', evt.signal);\n\t        var info = {};\n\t\n\t        that.sessionId = evt.signal.sessionId;\n\t        pc.state.listen('connecting:entry', function () {\n\t            if (!pc.state.caller) {\n\t                pc.processOffer(evt.signal.sessionDescription);\n\t            }\n\t        });\n\t\n\t        /*\n\t         * Always overwrite constraints for callee on every offer, since answer() and accept() will\n\t         * always be called after parsing the SDP.\n\t         */\n\t        that.outgoingMedia.constraints.video = respoke.sdpHasVideo(evt.signal.sessionDescription.sdp);\n\t        that.outgoingMedia.constraints.audio = respoke.sdpHasAudio(evt.signal.sessionDescription.sdp);\n\t\n\t        log.info(\"Setting outgoingMedia constraints to\", that.outgoingMedia.constraints);\n\t\n\t        if (pc.state.isModifying()) {\n\t            if (pc.state.needDirectConnection === true) {\n\t                info.directConnection = directConnection;\n\t            } else if (pc.state.needDirectConnection === false) {\n\t                // Nothing\n\t            } else {\n\t                info.call = that;\n\t            }\n\t            /**\n\t             * Indicates a request to add something to an existing call. If 'constraints' is set, evt.constraints\n\t             * describes the media the other side has added. In this case, call.approve() must be called in order\n\t             * to approve the new media and send the same type of media.  If directConnection exists, the other side\n\t             * wishes to to open a direct connection. In order to approve, call directConnection.accept(). In either\n\t             * case, call.reject() and directConnection.reject() can be called to decline the request to add to the\n\t             * call.\n\t             * @event respoke.Call#modify\n\t             * @type {respoke.Event}\n\t             * @property {object} [constraints]\n\t             * @property {boolean} [directConnection]\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.fire('modify', info);\n\t        }\n\t\n\t        pc.state.dispatch('receiveOffer', {\n\t            previewLocalMedia: previewLocalMedia,\n\t            approve: that.approve\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Save the answer and tell the browser about it.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.listenModify\n\t     * @private\n\t     */\n\t    function listenModify(evt) {\n\t        log.debug('Call.listenModify', evt);\n\t        if (evt.signal.action === 'initiate') {\n\t            defModify = Q.defer();\n\t            pc.state.dispatch('modify', {receive: true});\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Set up state and media for the modify.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.onModifyAccept\n\t     * @param {respoke.Event} evt\n\t     * @private\n\t     */\n\t    function onModifyAccept(evt) {\n\t        pc.state.dispatch('accept');\n\t\n\t        if (evt.signal.action !== 'initiate') {\n\t            defModify.resolve(); // resolved later for callee\n\t            defModify = undefined;\n\t            return;\n\t        }\n\t\n\t        // callee only from here down\n\t\n\t        // init the directConnection if necessary. We don't need to do anything with\n\t        // audio or video right now.\n\t        if (evt.signal.directConnection === true) {\n\t            actuallyAddDirectConnection().done(function successHandler(dc) {\n\t                directConnection = dc;\n\t                directConnection.accept();\n\t            });\n\t        } else if (evt.signal.directConnection === false) {\n\t            if (directConnection) {\n\t                that.removeDirectConnection({skipModify: true});\n\t                defMedia.resolve(false);\n\t            }\n\t        }\n\t        pc.state.needDirectConnection = typeof evt.signal.directConnection === 'boolean' ? evt.signal.directConnection : null;\n\t        that.outgoingMedia.constraints = evt.signal.constraints || that.outgoingMedia.constraints;\n\t    }\n\t\n\t    /**\n\t     * Ignore the modify.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.onModifyReject\n\t     * @param {respoke.Event} evt\n\t     * @param {Error} evt.err\n\t     * @private\n\t     */\n\t    function onModifyReject(evt) {\n\t        if (evt.signal.action !== 'initiate') {\n\t            defMedia.reject(evt.err);\n\t            defModify.reject(evt.err);\n\t            defModify = undefined;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * If video is muted, unmute. If not muted, mute.\n\t     * @deprecated\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.toggleVideo\n\t     */\n\t    that.toggleVideo = function () {\n\t        if (that.isActive()) {\n\t            if (!videoIsMuted) {\n\t                that.muteVideo();\n\t            } else {\n\t                that.unmuteVideo();\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * If audio is muted, unmute. If not muted, mute.\n\t     * @deprecated\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.toggleAudio\n\t     */\n\t    that.toggleAudio = function () {\n\t        if (that.isActive()) {\n\t            if (!audioIsMuted) {\n\t                that.muteAudio();\n\t            } else {\n\t                that.unmuteAudio();\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Indicate whether the call has media flowing.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.hasMedia\n\t     * @returns {boolean}\n\t     */\n\t    that.hasMedia = function () {\n\t        var local;\n\t        var remote;\n\t\n\t        if (!pc || !pc.getLocalStreams) {\n\t            // PeerConnection.init() has not been called yet\n\t            return false;\n\t        }\n\t\n\t        local = pc.getLocalStreams();\n\t        remote = pc.getRemoteStreams();\n\t\n\t        if (directConnection && directConnection.isActive()) {\n\t            return true;\n\t        }\n\t\n\t        return (local.length > 0 || remote.length > 0);\n\t    };\n\t\n\t    /**\n\t     * Mute all local video streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.muteVideo\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.muteVideo = function () {\n\t        if (videoIsMuted) {\n\t            return;\n\t        }\n\t        that.outgoingMedia.muteVideo();\n\t        videoIsMuted = true;\n\t    };\n\t\n\t    /**\n\t     * Unmute all local video streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.unmuteVideo\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.unmuteVideo = function () {\n\t        if (!videoIsMuted) {\n\t            return;\n\t        }\n\t        that.outgoingMedia.unmuteVideo();\n\t        videoIsMuted = false;\n\t    };\n\t\n\t    /**\n\t     * Mute all local audio streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.muteAudio\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.muteAudio = function () {\n\t        if (audioIsMuted) {\n\t            return;\n\t        }\n\t        that.outgoingMedia.muteAudio();\n\t        audioIsMuted = true;\n\t    };\n\t\n\t    /**\n\t     * Unmute all local audio streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.unmuteAudio\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.unmuteAudio = function () {\n\t        if (!audioIsMuted) {\n\t            return;\n\t        }\n\t\n\t        that.outgoingMedia.unmuteAudio();\n\t        audioIsMuted = false;\n\t    };\n\t\n\t    /**\n\t     * Save the hangup reason and hang up.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.listenHangup\n\t     * @params {object} evt\n\t     * @params {object} evt.signal - The hangup signal, including an optional hangup reason.\n\t     * @private\n\t     */\n\t    function listenHangup(evt) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        pc.report.callStoppedReason = evt.signal.reason || \"Remote side hung up\";\n\t        pc.state.receivedBye = true;\n\t        pc.state.dispatch('hangup', {signal: false, reason: pc.report.callStoppedReason});\n\t    }\n\t\n\t    pc.state.once('terminated:entry', function (evt) {\n\t        doHangup();\n\t    }, true);\n\t\n\t    that.listen('signal-offer', listenOffer, true);\n\t    that.listen('signal-hangup', listenHangup, true);\n\t    that.listen('signal-modify', listenModify, true);\n\t    pc.listen('modify-reject', onModifyReject, true);\n\t    pc.listen('modify-accept', onModifyAccept, true);\n\t    that.listen('signal-icecandidates', function onCandidateSignal(evt) {\n\t        if (!pc || !evt.signal.iceCandidates || !evt.signal.iceCandidates.length) {\n\t            return;\n\t        }\n\t        evt.signal.iceCandidates.forEach(function processCandidate(candidate) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t            pc.addRemoteCandidate({candidate: candidate});\n\t        });\n\t    }, true);\n\t\n\t    if (pc.state.needDirectConnection !== true) {\n\t        pc.state.once('preparing:entry', function () {\n\t            /**\n\t             * This event provides notification for when an incoming call is being received.  If the user wishes\n\t             * to allow the call, the app should call evt.call.answer() to answer the call.\n\t             * @event respoke.Client#call\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Call} call\n\t             * @property {respoke.Endpoint} endpoint\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            client.fire('call', {\n\t                endpoint: that.remoteEndpoint,\n\t                call: that\n\t            });\n\t        }, true);\n\t    }\n\t\n\t    pc.state.listen('idle:exit', function (evt) {\n\t        saveParameters(params);\n\t    });\n\t\n\t    pc.state.listen('preparing:entry', function (evt) {\n\t        init();\n\t\n\t        if (pc.state.caller === true) {\n\t            that.answer();\n\t        }\n\t    }, true);\n\t\n\t    signalingChannel.getTurnCredentials().then(function (result) {\n\t        if (!pc) {\n\t            throw new Error(\"Already hung up.\");\n\t            return;\n\t        }\n\t        if (!result) {\n\t            log.warn(\"Relay service not available.\");\n\t            pc.servers = {iceServers: []};\n\t        } else {\n\t            pc.servers = {iceServers: result};\n\t        }\n\t    }).fin(function () {\n\t        if (!pc) {\n\t            throw new Error(\"Already hung up.\");\n\t            return;\n\t        }\n\t        pc.state.dispatch('initiate', {\n\t            client: client,\n\t            caller: that.caller\n\t        });\n\t    }).done(null, function (err) {\n\t        if (err.message !== \"Already hung up.\") {\n\t            log.debug('Unexpected exception', err);\n\t        }\n\t    });\n\t\n\t    return that;\n\t}; // End respoke.Call\n\t\n\t/**\n\t * Handle an error that resulted from a method call.\n\t * @callback respoke.Call.errorHandler\n\t * @param {Error} err\n\t */\n\t/**\n\t * Handle the successful kick-off of stats on a call.\n\t * @callback respoke.Call.statsSuccessHandler\n\t * @param {respoke.MediaStatsParser} statsParser\n\t */\n\t/**\n\t * Handle obtaining media successfully.\n\t * @callback respoke.Call.mediaSuccessHandler\n\t * @param {respoke.LocalMedia} localMedia\n\t */\n\t/**\n\t * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n\t * to show the user their own video during a call. This callback is called every time\n\t * respoke.Call#local-stream-received is fired.\n\t * @callback respoke.Call.onLocalMedia Callback for receiving an HTML5 Video\n\t * element with the local audio and/or video attached.\n\t * @param {respoke.Event} evt\n\t * @param {Element} evt.element\n\t * @param {respoke.LocalMedia} - The outgoingMedia property on the call.\n\t * @param {string} evt.name - The event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When on a call, receive remote media when it becomes available. This is what you will need to provide if you want\n\t * to show the user the other party's video during a call. This callback is called every time\n\t * respoke.Call#connect is fired.\n\t * @callback respoke.Call.onConnect\n\t * @param {respoke.Event} evt\n\t * @param {Element} evt.element - the HTML5 Video element with the new stream attached.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When a call is in setup or media renegotiation happens. This callback will be called every time\n\t * respoke.Call#error.\n\t * @callback respoke.Call.onError\n\t * @param {respoke.Event} evt\n\t * @param {boolean} evt.reason - A human-readable description of the error.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When on a call, receive notification the call has been hung up. This callback is called every time\n\t * respoke.Call#hangup is fired.\n\t * @callback respoke.Call.onHangup\n\t * @param {respoke.Event} evt\n\t * @param {boolean} evt.sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Called when changing the mute state on any type of media. This callback will be called when media is muted or\n\t * unmuted. This callback is called every time respoke.Call#mute is fired.\n\t * @callback respoke.Call.onMute\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Called when the callee answers the call. This callback is called every time respoke.Call#answer is fired.\n\t * @callback respoke.Call.onAnswer\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Called when the user approves local media. This callback will be called whether or not the approval was based\n\t * on user feedback. I. e., it will be called even if the approval was automatic. This callback is called every time\n\t * respoke.Call#approve is fired.\n\t * @callback respoke.Call.onApprove\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When setting up a call, receive notification that the browser has granted access to media.  This callback is\n\t * called every time respoke.Call#allow is fired.\n\t * @callback respoke.Call.onAllow\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When setting up a call, receive notification that the app has asked the browser for permission to get audio or\n\t * video and is waiting on the browser to grant or reject permission. This callback will be called every time\n\t * respoke.Call#requesting-media is fired.\n\t * @callback respoke.Call.onRequestingMedia\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * The use of stats requires an additional module to Respoke. When on a call, receive periodic statistical\n\t * information about the call, including the codec, lost packets, and bandwidth being consumed. This callback is\n\t * called every time respoke.Call#stats is fired.\n\t * @callback respoke.MediaStatsParser.statsHandler\n\t * @param {respoke.Event} evt\n\t * @param {respoke.MediaStats} evt.stats - an object with stats in it.\n\t * @param {respoke.Call} evt.target\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n\t * to allow the user to preview and approve or reject their own video before a call. If this callback is provided,\n\t * Respoke will wait for call.answer() to be called before proceeding. If this callback is not provided,\n\t * Respoke will proceed without waiting for user input. This callback is called every time\n\t * respoke.Call#local-stream-received is fired.\n\t * @callback respoke.Call.previewLocalMedia\n\t * @param {object} element - the HTML5 Video element with the new stream attached.\n\t * @param {respoke.Call} call\n\t */\n\t/**\n\t * Receive the DirectConnection.\n\t * @callback respoke.Call.directConnectionSuccessHandler\n\t * @param {respoke.DirectConnection} directConnection\n\t */\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A wrapper around the stream from `getUserMedia`,\n\t * which is attached to a call at `call.outgoingMedia`.\n\t *\n\t * @class respoke.LocalMedia\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @param {string} params.callId - call id\n\t * @param {object} [params.constraints]\n\t * @param {HTMLVideoElement} params.element - Pass in an optional html video element to have local\n\t * video attached to it.\n\t * @returns {respoke.LocalMedia}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.LocalMedia';\n\t    /**\n\t     * Respoke media ID (different from a `MediaStream.id`).\n\t     * @memberof! respoke.LocalMedia\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = respoke.makeGUID();\n\t\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.getClient}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * The HTML element with video attached.\n\t     * @memberof! respoke.LocalMedia\n\t     * @name element\n\t     * @type {HTMLVideoElement}\n\t     */\n\t    that.element = params.element;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name sdpHasAudio\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasAudio = false;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name sdpHasVideo\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasVideo = false;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name sdpHasDataChannel\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasDataChannel = false;\n\t    /**\n\t     * A timer to make sure we only fire {respoke.LocalMedia#requesting-media} if the browser doesn't\n\t     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n\t     * @memberof! respoke.LocalMedia\n\t     * @name allowTimer\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var allowTimer = 0;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name mediaOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var mediaOptions = {\n\t        optional: [\n\t            { DtlsSrtpKeyAgreement: true },\n\t            { RtpDataChannels: false }\n\t        ]\n\t    };\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name pc\n\t     * @private\n\t     * @type {respoke.PeerConnection}\n\t     */\n\t    var pc = params.pc;\n\t    delete that.pc;\n\t    /**\n\t     * The local `MediaStream` from `getUserMedia()`.\n\t     * @memberof! respoke.LocalMedia\n\t     * @name stream\n\t     * @type {RTCMediaStream}\n\t     */\n\t    that.stream = null;\n\t\n\t    function getStream(theConstraints) {\n\t        for (var i = 0; i < respoke.streams.length; i++) {\n\t            var s = respoke.streams[i];\n\t            if (respoke.isEqual(s.constraints, theConstraints)) {\n\t                return s.stream;\n\t            }\n\t        }\n\t        return null;\n\t    }\n\t\n\t    function removeStream(theConstraints) {\n\t        var toRemoveIndex;\n\t        for (var i = 0; i < respoke.streams.length; i++) {\n\t            var s = respoke.streams[i];\n\t            if (respoke.isEqual(s.constraints, theConstraints)) {\n\t                toRemoveIndex = i;\n\t                break;\n\t            }\n\t        }\n\t        if (toRemoveIndex !== undefined) {\n\t            respoke.streams.splice(toRemoveIndex, 1);\n\t        }\n\t    }\n\t\n\t    function checkAndCreateElement(){\n\t\n\t        that.element = that.element || document.createElement('video');\n\t\n\t        that.element.muted = true;//need to do this with JS\n\t        that.element.autoplay = true;//gets converted\n\t\n\t\n\t        if (window.webrtcDetectedType === 'plugin' && !that.element.parentNode) {\n\t            //go and add it to the DOM in a hidden div\n\t\n\t            console.log('need to add this into the DOM');\n\t            document.body.appendChild(that.element);\n\t        }\n\t\n\t\n\t        return that.element;\n\t    }\n\t\n\t    /**\n\t     * Save the local stream. Kick off SDP creation.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.onReceiveUserMedia\n\t     * @private\n\t     * @param {RTCMediaStream} theStream\n\t     * @fires respoke.LocalMedia#stream-received\n\t     */\n\t    function onReceiveUserMedia(theStream) {\n\t        that.stream = theStream;\n\t        clearTimeout(allowTimer);\n\t        /**\n\t         * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n\t         * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n\t         * even if the allow process is automatic, i. e., permission and media is granted by the browser\n\t         * without asking the user to approve it.\n\t         * @event respoke.LocalMedia#allow\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         */\n\t        that.fire('allow');\n\t        log.debug('User gave permission to use media.');\n\t        log.debug('onReceiveUserMedia');\n\t\n\t        /**\n\t         * Expose getAudioTracks.\n\t         * @memberof! respoke.LocalMedia\n\t         * @method respoke.LocalMedia.getAudioTracks\n\t         */\n\t\n\t        that.getAudioTracks = function () {\n\t            return that.stream.getAudioTracks();\n\t        }\n\t\n\t        /**\n\t         * Expose getVideoTracks.\n\t         * @memberof! respoke.LocalMedia\n\t         * @method respoke.LocalMedia.getVideoTracks\n\t         */\n\t        that.getVideoTracks = function () {\n\t            return that.stream.getVideoTracks();\n\t        }\n\t\n\t        // This happens when we get an automatic hangup or reject from the other side.\n\t        if (pc === null) {\n\t            that.hangup({signal: false});\n\t            return;\n\t        }\n\t\n\t        that.element = checkAndCreateElement();\n\t\n\t        // This still needs some work. Using cached streams causes an unused video element to be passed\n\t        // back to the App. This is because we assume at the moment that only one local media video element\n\t        // will be needed. The first one passed back will contain media and the others will fake it. Media\n\t        // will still be sent with every peer connection. Also need to study the use of getLocalElement\n\t        // and the implications of passing back a video element with no media attached.\n\t        var aStream = getStream(that.constraints);\n\t        if (aStream) {\n\t            aStream.numPc += 1;\n\t\n\t            //testing\n\t            var documentOwner = that.element.ownerDocument;\n\t\n\t            // that.element.muted = true;//need to do this with JS\n\t            // that.element.autoplay = true;//gets converted\n\t\n\t            that.element = attachMediaStream(that.element, that.stream);\n\t\n\t            that.element.ownerDocument = documentOwner;\n\t\n\t            // // We won't want our local video outputting audio.\n\t            // that.element.muted = true;//temasys needs this changed\n\t            // that.element.autoplay = true;\n\t\n\t            /**\n\t             * @event respoke.LocalMedia#stream-received\n\t             * @type {respoke.Event}\n\t             * @property {Element} element - the HTML5 Video element with the new stream attached.\n\t             * @property {RTCMediaStream} stream - the HTML5 Video stream\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.LocalMedia} target\n\t             */\n\t            that.fire('stream-received', {\n\t                element: that.element,\n\t                stream: that.stream\n\t            });\n\t        } else {\n\t            that.stream.numPc = 1;\n\t            respoke.streams.push({stream: that.stream, constraints: that.constraints});\n\t\n\t            that.stream.id = client.endpointId;\n\t\n\t            //testing\n\t            var documentOwner = that.element.ownerDocument;\n\t\n\t            that.element = attachMediaStream(that.element, that.stream);\n\t\n\t            that.element.ownerDocument = documentOwner;\n\t\n\t\n\t            // We won't want our local video outputting audio.\n\t            // that.element.muted = true;\n\t            // that.element.autoplay = true;\n\t\n\t            /**\n\t             * @event respoke.LocalMedia#stream-received\n\t             * @type {respoke.Event}\n\t             * @property {Element} element - the HTML5 Video element with the new stream attached.\n\t             * @property {RTCMediaStream} stream - the HTML5 Video stream\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.LocalMedia} target\n\t             */\n\t            that.fire('stream-received', {\n\t                element: that.element,\n\t                stream: that.stream\n\t            });\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.requestMedia\n\t     * @private\n\t     */\n\t    function requestMedia() {\n\t        log.debug('requestMedia');\n\t\n\t        if (!that.constraints) {\n\t            throw new Error('No constraints.');\n\t        }\n\t\n\t        var theStream = getStream(that.constraints);\n\t        if (theStream) {\n\t            log.debug('using old stream');\n\t            onReceiveUserMedia(theStream);\n\t            return;\n\t        }\n\t\n\t        try {\n\t            log.debug(\"Running getUserMedia with constraints\", that.constraints);\n\t            // TODO set getStream(that.constraints) = true as a flag that we are already\n\t            // attempting to obtain this media so the race condition where gUM is called twice with\n\t            // the same constraints when calls are placed too quickly together doesn't occur.\n\t            allowTimer = setTimeout(function allowTimer() {\n\t                /**\n\t                 * The browser is asking for permission to access the User's media. This would be an ideal time\n\t                 * to modify the UI of the application so that the user notices the request for permissions\n\t                 * and approves it.\n\t                 * @event respoke.LocalMedia#requesting-media\n\t                 * @type {respoke.Event}\n\t                 * @property {string} name - the event name.\n\t                 * @property {respoke.LocalMedia} target\n\t                 */\n\t                that.fire('requesting-media');\n\t            }, 500);\n\t            if (respoke.useFakeMedia === true) {\n\t                that.constraints.fake = true;\n\t            }\n\t            getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n\t        } catch (e) {\n\t            log.error(\"Couldn't get user media: \" + e.message);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handle any error that comes up during the process of getting user media.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.onUserMediaError\n\t     * @private\n\t     * @param {object}\n\t     */\n\t    function onUserMediaError(p) {\n\t        log.debug('onUserMediaError');\n\t        if (p.code === 1) {\n\t            log.warn(\"Permission denied.\");\n\t            /**\n\t             * Indicate there has been an error obtaining media.\n\t             * @event respoke.LocalMedia#requesting-media\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.LocalMedia} target\n\t             */\n\t            that.fire('error', {error: 'Permission denied.'});\n\t        } else {\n\t            log.warn(p);\n\t            /**\n\t             * Indicate there has been an error obtaining media.\n\t             * @event respoke.LocalMedia#requesting-media\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.LocalMedia} target\n\t             */\n\t            that.fire('error', {error: p.code});\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Whether the video stream is muted.\n\t     *\n\t     * All video tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isVideoMuted = function () {\n\t        if (!that.stream) {\n\t            return false;\n\t        }\n\t        return that.stream.getVideoTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute local video stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.muteVideo\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.muteVideo = function () {\n\t        if (that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute local video stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.unmuteVideo\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.unmuteVideo = function () {\n\t        if (!that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Whether the audio stream is muted.\n\t     *\n\t     * All audio tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isAudioMuted = function () {\n\t        if (!that.stream) {\n\t            return false;\n\t        }\n\t        return that.stream.getAudioTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute local audio stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.muteAudio\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.muteAudio = function () {\n\t        if (that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute local audio stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.unmuteAudio\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.unmuteAudio = function () {\n\t        if (!that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Stop the stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.stop\n\t     * @fires respoke.LocalMedia#stop\n\t     */\n\t    that.stop = function () {\n\t        if (!that.stream) {\n\t            return;\n\t        }\n\t\n\t        that.stream.numPc -= 1;\n\t        if (that.stream.numPc === 0) {\n\t            that.stream.stop();\n\t            removeStream(that.constraints);\n\t        }\n\t        that.stream = null;\n\t        /**\n\t         * @event respoke.LocalMedia#stop\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         */\n\t        that.fire('stop');\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are sending video.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.hasVideo\n\t     * @return {boolean}\n\t     */\n\t    that.hasVideo = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getVideoTracks().length > 0);\n\t        }\n\t        return sdpHasVideo;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are sending audio.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.hasAudio\n\t     * @return {boolean}\n\t     */\n\t    that.hasAudio = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getAudioTracks().length > 0);\n\t        }\n\t        return sdpHasAudio;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we have media yet.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.hasMedia\n\t     * @return {boolean}\n\t     */\n\t    that.hasMedia = function () {\n\t        return !!that.stream;\n\t    };\n\t\n\t    /**\n\t     * Save and parse the SDP.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.setSDP\n\t     * @param {RTCSessionDescription} oSession\n\t     * @private\n\t     */\n\t    that.setSDP = function (oSession) {\n\t        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n\t        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n\t        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n\t    };\n\t\n\t    /**\n\t     * Start the stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.start\n\t     * @fires respoke.LocalMedia#start\n\t     * @private\n\t     */\n\t    that.start = function () {\n\t        requestMedia();\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.LocalMedia\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2014, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(18);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * Class for managing the remote media stream, \n\t * which is attached to a call at `call.outgoingMedia`.\n\t * \n\t * @class respoke.RemoteMedia\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @param {string} params.callId - call id\n\t * @param {object} params.constraints\n\t * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n\t * @returns {respoke.RemoteMedia}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.RemoteMedia';\n\t    /**\n\t     * Respoke media ID (different from a `MediaStream.id`).\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = respoke.makeGUID();\n\t\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.getClient}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * The HTML element with attached video.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name element\n\t     * @type {HTMLVideoElement}\n\t     */\n\t    that.element = params.videoRemoteElement;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name sdpHasAudio\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasAudio = false;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name sdpHasVideo\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasVideo = false;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name sdpHasDataChannel\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasDataChannel = false;\n\t    /**\n\t     * A timer to make sure we only fire {respoke.RemoteMedia#requesting-media} if the browser doesn't\n\t     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name allowTimer\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var allowTimer = 0;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name mediaOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var mediaOptions = {\n\t        optional: [\n\t            { DtlsSrtpKeyAgreement: true },\n\t            { RtpDataChannels: false }\n\t        ]\n\t    };\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name pc\n\t     * @private\n\t     * @type {respoke.PeerConnection}\n\t     */\n\t    var pc = params.pc;\n\t    delete that.pc;\n\t    /**\n\t     * The remote `MediaStream`.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name stream\n\t     * @type {RTCMediaStream}\n\t     */\n\t    that.stream = null;\n\t\n\t    /**\n\t     * Indicate whether we are receiving video.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.hasVideo\n\t     * @return {boolean}\n\t     */\n\t    that.hasVideo = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getVideoTracks().length > 0);\n\t        }\n\t        return sdpHasVideo;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are receiving audio.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.hasAudio\n\t     * @return {boolean}\n\t     */\n\t    that.hasAudio = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getAudioTracks().length > 0);\n\t        }\n\t        return sdpHasAudio;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we have media yet.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.hasMedia\n\t     * @return {boolean}\n\t     */\n\t    that.hasMedia = function () {\n\t        return !!that.stream;\n\t    };\n\t\n\t    /**\n\t     * Save and parse the SDP\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.setSDP\n\t     * @param {RTCSessionDescription} oSession\n\t     * @private\n\t     */\n\t    that.setSDP = function (oSession) {\n\t        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n\t        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n\t        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n\t    };\n\t\n\t    /**\n\t     * Parse the constraints.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.setConstraints\n\t     * @param {MediaConstraints} constraints\n\t     * @private\n\t     */\n\t    that.setConstraints = function (constraints) {\n\t        that.constraints = constraints;\n\t        sdpHasVideo = respoke.constraintsHasVideo(that.constraints);\n\t        sdpHasAudio = respoke.constraintsHasAudio(that.constraints);\n\t    };\n\t\n\t    function checkAndCreateElement(){\n\t\n\t        that.element = that.element || document.createElement('video');\n\t\n\t        that.element.autoplay = true;\n\t\n\t        if (window.webrtcDetectedType === 'plugin' && !that.element.parentNode) {\n\t            console.log('need to add this into the DOM');\n\t            document.body.appendChild(that.element);\n\t        }\n\t\n\t        //go and add it to the DOM in a hidden div\n\t\n\t        return that.element;\n\t    }\n\t\n\t    /**\n\t     * Save the media stream\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.setStream\n\t     * @param {MediaStream} str\n\t     * @private\n\t     */\n\t    that.setStream = function (str) {\n\t        if (str) {\n\t            that.stream = str;\n\t            /**\n\t             * Expose getAudioTracks.\n\t             */\n\t            that.getAudioTracks = function(){\n\t                return that.stream.getAudioTracks();\n\t            }\n\t            /**\n\t             * Expose getVideoTracks.\n\t             */\n\t            that.getVideoTracks = function(){\n\t                return that.stream.getVideoTracks();\n\t            }\n\t\n\t\n\t            that.element = checkAndCreateElement();\n\t            //testing\n\t            var documentOwner = that.element.ownerDocument;\n\t\n\t            that.element = attachMediaStream(that.element, that.stream);\n\t\n\t            that.element.ownerDocument = documentOwner;\n\t\n\t            //moved\n\t            // that.element.autoplay = true;\n\t            setTimeout(function(){\n\t                that.element.play();\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Stop the stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.stop\n\t     * @fires respoke.RemoteMedia#stop\n\t     */\n\t    that.stop = function () {\n\t        if (!that.stream) {\n\t            return;\n\t        }\n\t\n\t        that.stream.numPc -= 1;\n\t        if (that.stream.numPc === 0) {\n\t            that.stream.stop();\n\t            delete respoke.streams[that.constraints];\n\t        }\n\t        that.stream = null;\n\t        /**\n\t         * @event respoke.RemoteMedia#stop\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         */\n\t        that.fire('stop');\n\t    };\n\t\n\t    /**\n\t     * Whether the video stream is muted.\n\t     * \n\t     * All video tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isVideoMuted = function () {\n\t        if (!that.stream) {\n\t            return false;\n\t        }\n\t        return that.stream.getVideoTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute remote video stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.muteVideo\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.muteVideo = function () {\n\t        if (that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute remote video stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.unmuteVideo\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.unmuteVideo = function () {\n\t        if (!that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Whether the audio stream is muted.\n\t     * \n\t     * All audio tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isAudioMuted = function () {\n\t        if (!that.stream) {\n\t            return false;\n\t        }\n\t        return that.stream.getAudioTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute remote audio stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.muteAudio\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.muteAudio = function () {\n\t        if (that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute remote audio stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.unmuteAudio\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.unmuteAudio = function () {\n\t        if (!that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.RemoteMedia\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*! adapterjs - v0.10.3 - 2015-01-16 */\n\t\n\t// Adapter's interface.\n\tAdapterJS = { options:{} };\n\t\n\t// uncomment to get virtual webcams\n\t// AdapterJS.options.getAllCams = true;\n\t\n\t// uncomment to prevent the install prompt when the plugin in not yet installed\n\t// AdapterJS.options.hidePluginInstallPrompt = true;\n\t\n\t// AdapterJS version\n\tAdapterJS.VERSION = '0.10.3';\n\t\n\t// Plugin namespace\n\tAdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {};\n\t\n\t// The object to store plugin information\n\tAdapterJS.WebRTCPlugin.pluginInfo = {\n\t  prefix : 'Tem',\n\t  plugName : 'TemWebRTCPlugin',\n\t  pluginId : 'plugin0',\n\t  type : 'application/x-temwebrtcplugin',\n\t  onload : '__TemWebRTCReady0',\n\t  portalLink : 'http://temasys.atlassian.net/wiki/display/TWPP/WebRTC+Plugins',\n\t  downloadLink : null, //set below\n\t  companyName: 'Temasys'\n\t};\n\tif(!!navigator.platform.match(/^Mac/i)) {\n\t  AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = 'http://bit.ly/1n77hco';\n\t}\n\telse if(!!navigator.platform.match(/^Win/i)) {\n\t  AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = 'http://bit.ly/1kkS4FN';\n\t}\n\t\n\t// Unique identifier of each opened page\n\tAdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2);\n\t\n\t// Use this whenever you want to call the plugin.\n\tAdapterJS.WebRTCPlugin.plugin = null;\n\t\n\t// Set log level for the plugin once it is ready.\n\t// The different values are\n\t// This is an asynchronous function that will run when the plugin is ready\n\tAdapterJS.WebRTCPlugin.setLogLevel = null;\n\t\n\t// Defines webrtc's JS interface according to the plugin's implementation.\n\t// Define plugin Browsers as WebRTC Interface.\n\tAdapterJS.WebRTCPlugin.defineWebRTCInterface = null;\n\t\n\t// This function detects whether or not a plugin is installed.\n\t// Checks if Not IE (firefox, for example), else if it's IE,\n\t// we're running IE and do something. If not it is not supported.\n\tAdapterJS.WebRTCPlugin.isPluginInstalled = null;\n\t\n\t // Lets adapter.js wait until the the document is ready before injecting the plugin\n\tAdapterJS.WebRTCPlugin.pluginInjectionInterval = null;\n\t\n\t// Inject the HTML DOM object element into the page.\n\tAdapterJS.WebRTCPlugin.injectPlugin = null;\n\t\n\t// States of readiness that the plugin goes through when\n\t// being injected and stated\n\tAdapterJS.WebRTCPlugin.PLUGIN_STATES = {\n\t  NONE : 0,           // no plugin use\n\t  INITIALIZING : 1,   // Detected need for plugin\n\t  INJECTING : 2,      // Injecting plugin\n\t  INJECTED: 3,        // Plugin element injected but not usable yet\n\t  READY: 4            // Plugin ready to be used\n\t};\n\t\n\t// Current state of the plugin. You cannot use the plugin before this is\n\t// equal to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY\n\tAdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE;\n\t\n\t// Log levels for the plugin.\n\t// To be set by calling AdapterJS.WebRTCPlugin.setLogLevel\n\t/*\n\tLog outputs are prefixed in some cases.\n\t  INFO: Information reported by the plugin.\n\t  ERROR: Errors originating from within the plugin.\n\t  WEBRTC: Error originating from within the libWebRTC library\n\t*/\n\t// From the least verbose to the most verbose\n\tAdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {\n\t  NONE : 'NONE',\n\t  ERROR : 'ERROR',\n\t  WARNING : 'WARNING',\n\t  INFO: 'INFO',\n\t  VERBOSE: 'VERBOSE',\n\t  SENSITIVE: 'SENSITIVE'\n\t};\n\t\n\t// Does a waiting check before proceeding to load the plugin.\n\tAdapterJS.WebRTCPlugin.WaitForPluginReady = null;\n\t\n\t// This methid will use an interval to wait for the plugin to be ready.\n\tAdapterJS.WebRTCPlugin.callWhenPluginReady = null;\n\t\n\t// This function will be called if the plugin is needed (browser different\n\t// from Chrome or Firefox), but the plugin is not installed.\n\t// Override it according to your application logic.\n\tAdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = null;\n\t\n\t// !!!! WARNING: DO NOT OVERRIDE THIS FUNCTION. !!!\n\t// This function will be called when plugin is ready. It sends necessary\n\t// details to the plugin.\n\t// The function will wait for the document to be ready and the set the\n\t// plugin state to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,\n\t// indicating that it can start being requested.\n\t// This function is not in the IE/Safari condition brackets so that\n\t// TemPluginLoaded function might be called on Chrome/Firefox.\n\t// This function is the only private function that is not encapsulated to\n\t// allow the plugin method to be called.\n\t__TemWebRTCReady0 = function () {\n\t  if (document.readyState === 'complete') {\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n\t  } else {\n\t    AdapterJS.WebRTCPlugin.documentReadyInterval = setInterval(function () {\n\t      if (document.readyState === 'complete') {\n\t        // TODO: update comments, we wait for the document to be ready\n\t        clearInterval(AdapterJS.WebRTCPlugin.documentReadyInterval);\n\t        AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n\t      }\n\t    }, 100);\n\t  }\n\t};\n\t\n\t// The result of ice connection states.\n\t// - starting: Ice connection is starting.\n\t// - checking: Ice connection is checking.\n\t// - connected Ice connection is connected.\n\t// - completed Ice connection is connected.\n\t// - done Ice connection has been completed.\n\t// - disconnected Ice connection has been disconnected.\n\t// - failed Ice connection has failed.\n\t// - closed Ice connection is closed.\n\tAdapterJS._iceConnectionStates = {\n\t  starting : 'starting',\n\t  checking : 'checking',\n\t  connected : 'connected',\n\t  completed : 'connected',\n\t  done : 'completed',\n\t  disconnected : 'disconnected',\n\t  failed : 'failed',\n\t  closed : 'closed'\n\t};\n\t\n\t//The IceConnection states that has been fired for each peer.\n\tAdapterJS._iceConnectionFiredStates = [];\n\t\n\t\n\t// Check if WebRTC Interface is defined.\n\tAdapterJS.isDefined = null;\n\t\n\t// This function helps to retrieve the webrtc detected browser information.\n\t// This sets:\n\t// - webrtcDetectedBrowser: The browser agent name.\n\t// - webrtcDetectedVersion: The browser version.\n\t// - webrtcDetectedType: The types of webRTC support.\n\t//   - 'moz': Mozilla implementation of webRTC.\n\t//   - 'webkit': WebKit implementation of webRTC.\n\t//   - 'plugin': Using the plugin implementation.\n\tAdapterJS.parseWebrtcDetectedBrowser = function () {\n\t  var hasMatch, checkMatch = navigator.userAgent.match(\n\t    /(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || [];\n\t  if (/trident/i.test(checkMatch[1])) {\n\t    hasMatch = /\\brv[ :]+(\\d+)/g.exec(navigator.userAgent) || [];\n\t    webrtcDetectedBrowser = 'IE';\n\t    webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);\n\t  } else if (checkMatch[1] === 'Chrome') {\n\t    hasMatch = navigator.userAgent.match(/\\bOPR\\/(\\d+)/);\n\t    if (hasMatch !== null) {\n\t      webrtcDetectedBrowser = 'opera';\n\t      webrtcDetectedVersion = parseInt(hasMatch[1], 10);\n\t    }\n\t  }\n\t  if (navigator.userAgent.indexOf('Safari')) {\n\t    if (typeof InstallTrigger !== 'undefined') {\n\t      webrtcDetectedBrowser = 'firefox';\n\t    } else if (/*@cc_on!@*/ false || !!document.documentMode) {\n\t      webrtcDetectedBrowser = 'IE';\n\t    } else if (\n\t      Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) {\n\t      webrtcDetectedBrowser = 'safari';\n\t    } else if (!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {\n\t      webrtcDetectedBrowser = 'opera';\n\t    } else if (!!window.chrome) {\n\t      webrtcDetectedBrowser = 'chrome';\n\t    }\n\t  }\n\t  if (!webrtcDetectedBrowser) {\n\t    webrtcDetectedVersion = checkMatch[1];\n\t  }\n\t  if (!webrtcDetectedVersion) {\n\t    try {\n\t      checkMatch = (checkMatch[2]) ? [checkMatch[1], checkMatch[2]] :\n\t        [navigator.appName, navigator.appVersion, '-?'];\n\t      if ((hasMatch = navigator.userAgent.match(/version\\/(\\d+)/i)) !== null) {\n\t        checkMatch.splice(1, 1, hasMatch[1]);\n\t      }\n\t      webrtcDetectedVersion = parseInt(checkMatch[1], 10);\n\t    } catch (error) { }\n\t  }\n\t};\n\t\n\t// To fix configuration as some browsers does not support\n\t// the 'urls' attribute.\n\tAdapterJS.maybeFixConfiguration = function (pcConfig) {\n\t  if (pcConfig === null) {\n\t    return;\n\t  }\n\t  for (var i = 0; i < pcConfig.iceServers.length; i++) {\n\t    if (pcConfig.iceServers[i].hasOwnProperty('urls')) {\n\t      pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;\n\t      delete pcConfig.iceServers[i].urls;\n\t    }\n\t  }\n\t};\n\t\n\tAdapterJS.addEvent = function(elem, evnt, func) {\n\t   if (elem.addEventListener)  // W3C DOM\n\t      elem.addEventListener(evnt, func, false);\n\t   else if (elem.attachEvent) // OLD IE DOM\n\t      elem.attachEvent(\"on\"+evnt, func);\n\t   else // No much to do\n\t      elem[evnt] = func;\n\t}\n\t\n\t// -----------------------------------------------------------\n\t// Detected webrtc implementation. Types are:\n\t// - 'moz': Mozilla implementation of webRTC.\n\t// - 'webkit': WebKit implementation of webRTC.\n\t// - 'plugin': Using the plugin implementation.\n\twebrtcDetectedType = null;\n\t\n\t// Detected webrtc datachannel support. Types are:\n\t// - 'SCTP': SCTP datachannel support.\n\t// - 'RTP': RTP datachannel support.\n\twebrtcDetectedDCSupport = null;\n\t\n\t// Set the settings for creating DataChannels, MediaStream for\n\t// Cross-browser compability.\n\t// - This is only for SCTP based support browsers.\n\t// the 'urls' attribute.\n\tcheckMediaDataChannelSettings =\n\t  function (peerBrowserAgent, peerBrowserVersion, callback, constraints) {\n\t  if (typeof callback !== 'function') {\n\t    return;\n\t  }\n\t  var beOfferer = true;\n\t  var isLocalFirefox = webrtcDetectedBrowser === 'firefox';\n\t  // Nightly version does not require MozDontOfferDataChannel for interop\n\t  var isLocalFirefoxInterop = webrtcDetectedType === 'moz' && webrtcDetectedVersion > 30;\n\t  var isPeerFirefox = peerBrowserAgent === 'firefox';\n\t  var isPeerFirefoxInterop = peerBrowserAgent === 'firefox' &&\n\t    ((peerBrowserVersion) ? (peerBrowserVersion > 30) : false);\n\t\n\t  // Resends an updated version of constraints for MozDataChannel to work\n\t  // If other userAgent is firefox and user is firefox, remove MozDataChannel\n\t  if ((isLocalFirefox && isPeerFirefox) || (isLocalFirefoxInterop)) {\n\t    try {\n\t      delete constraints.mandatory.MozDontOfferDataChannel;\n\t    } catch (error) {\n\t      console.error('Failed deleting MozDontOfferDataChannel');\n\t      console.error(error);\n\t    }\n\t  } else if ((isLocalFirefox && !isPeerFirefox)) {\n\t    constraints.mandatory.MozDontOfferDataChannel = true;\n\t  }\n\t  if (!isLocalFirefox) {\n\t    // temporary measure to remove Moz* constraints in non Firefox browsers\n\t    for (var prop in constraints.mandatory) {\n\t      if (constraints.mandatory.hasOwnProperty(prop)) {\n\t        if (prop.indexOf('Moz') !== -1) {\n\t          delete constraints.mandatory[prop];\n\t        }\n\t      }\n\t    }\n\t  }\n\t  // Firefox (not interopable) cannot offer DataChannel as it will cause problems to the\n\t  // interopability of the media stream\n\t  if (isLocalFirefox && !isPeerFirefox && !isLocalFirefoxInterop) {\n\t    beOfferer = false;\n\t  }\n\t  callback(beOfferer, constraints);\n\t};\n\t\n\t// Handles the differences for all browsers ice connection state output.\n\t// - Tested outcomes are:\n\t//   - Chrome (offerer)  : 'checking' > 'completed' > 'completed'\n\t//   - Chrome (answerer) : 'checking' > 'connected'\n\t//   - Firefox (offerer) : 'checking' > 'connected'\n\t//   - Firefox (answerer): 'checking' > 'connected'\n\tcheckIceConnectionState = function (peerId, iceConnectionState, callback) {\n\t  if (typeof callback !== 'function') {\n\t    console.warn('No callback specified in checkIceConnectionState. Aborted.');\n\t    return;\n\t  }\n\t  peerId = (peerId) ? peerId : 'peer';\n\t\n\t  if (!AdapterJS._iceConnectionFiredStates[peerId] ||\n\t    iceConnectionState === AdapterJS._iceConnectionStates.disconnected ||\n\t    iceConnectionState === AdapterJS._iceConnectionStates.failed ||\n\t    iceConnectionState === AdapterJS._iceConnectionStates.closed) {\n\t    AdapterJS._iceConnectionFiredStates[peerId] = [];\n\t  }\n\t  iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState];\n\t  if (AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) < 0) {\n\t    AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState);\n\t    if (iceConnectionState === AdapterJS._iceConnectionStates.connected) {\n\t      setTimeout(function () {\n\t        AdapterJS._iceConnectionFiredStates[peerId]\n\t          .push(AdapterJS._iceConnectionStates.done);\n\t        callback(AdapterJS._iceConnectionStates.done);\n\t      }, 1000);\n\t    }\n\t    callback(iceConnectionState);\n\t  }\n\t  return;\n\t};\n\t\n\t// Firefox:\n\t// - Creates iceServer from the url for Firefox.\n\t// - Create iceServer with stun url.\n\t// - Create iceServer with turn url.\n\t//   - Ignore the transport parameter from TURN url for FF version <=27.\n\t//   - Return null for createIceServer if transport=tcp.\n\t// - FF 27 and above supports transport parameters in TURN url,\n\t// - So passing in the full url to create iceServer.\n\t// Chrome:\n\t// - Creates iceServer from the url for Chrome M33 and earlier.\n\t//   - Create iceServer with stun url.\n\t//   - Chrome M28 & above uses below TURN format.\n\t// Plugin:\n\t// - Creates Ice Server for Plugin Browsers\n\t//   - If Stun - Create iceServer with stun url.\n\t//   - Else - Create iceServer with turn url\n\t//   - This is a WebRTC Function\n\tcreateIceServer = null;\n\t\n\t// Firefox:\n\t// - Creates IceServers for Firefox\n\t//   - Use .url for FireFox.\n\t//   - Multiple Urls support\n\t// Chrome:\n\t// - Creates iceServers from the urls for Chrome M34 and above.\n\t//   - .urls is supported since Chrome M34.\n\t//   - Multiple Urls support\n\t// Plugin:\n\t// - Creates Ice Servers for Plugin Browsers\n\t//   - Multiple Urls support\n\t//   - This is a WebRTC Function\n\tcreateIceServers = null;\n\t//------------------------------------------------------------\n\t\n\t//The RTCPeerConnection object.\n\tRTCPeerConnection = null;\n\t\n\t// Creates RTCSessionDescription object for Plugin Browsers\n\tRTCSessionDescription = (typeof RTCSessionDescription === 'function') ?\n\t  RTCSessionDescription : null;\n\t\n\t// Creates RTCIceCandidate object for Plugin Browsers\n\tRTCIceCandidate = (typeof RTCIceCandidate === 'function') ?\n\t  RTCIceCandidate : null;\n\t\n\t// Get UserMedia (only difference is the prefix).\n\t// Code from Adam Barth.\n\tgetUserMedia = null;\n\t\n\t// Attach a media stream to an element.\n\tattachMediaStream = null;\n\t\n\t// Re-attach a media stream to an element.\n\treattachMediaStream = null;\n\t\n\t\n\t// Detected browser agent name. Types are:\n\t// - 'firefox': Firefox browser.\n\t// - 'chrome': Chrome browser.\n\t// - 'opera': Opera browser.\n\t// - 'safari': Safari browser.\n\t// - 'IE' - Internet Explorer browser.\n\twebrtcDetectedBrowser = null;\n\t\n\t// Detected browser version.\n\twebrtcDetectedVersion = null;\n\t\n\t// Check for browser types and react accordingly\n\tif (navigator.mozGetUserMedia) {\n\t  webrtcDetectedBrowser = 'firefox';\n\t  webrtcDetectedVersion = parseInt(navigator\n\t    .userAgent.match(/Firefox\\/([0-9]+)\\./)[1], 10);\n\t  webrtcDetectedType = 'moz';\n\t  webrtcDetectedDCSupport = 'SCTP';\n\t\n\t  RTCPeerConnection = function (pcConfig, pcConstraints) {\n\t    AdapterJS.maybeFixConfiguration(pcConfig);\n\t    return new mozRTCPeerConnection(pcConfig, pcConstraints);\n\t  };\n\t\n\t // The RTCSessionDescription object.\n\t  RTCSessionDescription = mozRTCSessionDescription;\n\t  window.RTCSessionDescription = RTCSessionDescription;\n\t\n\t  // The RTCIceCandidate object.\n\t  RTCIceCandidate = mozRTCIceCandidate;\n\t  window.RTCIceCandidate = RTCIceCandidate;\n\t\n\t  getUserMedia = navigator.mozGetUserMedia.bind(navigator);\n\t  navigator.getUserMedia = getUserMedia;\n\t\n\t  // Shim for MediaStreamTrack.getSources.\n\t  MediaStreamTrack.getSources = function(successCb) {\n\t    setTimeout(function() {\n\t      var infos = [\n\t        { kind: 'audio', id: 'default', label:'', facing:'' },\n\t        { kind: 'video', id: 'default', label:'', facing:'' }\n\t      ];\n\t      successCb(infos);\n\t    }, 0);\n\t  };\n\t\n\t  createIceServer = function (url, username, password) {\n\t    var iceServer = null;\n\t    var url_parts = url.split(':');\n\t    if (url_parts[0].indexOf('stun') === 0) {\n\t      iceServer = { url : url };\n\t    } else if (url_parts[0].indexOf('turn') === 0) {\n\t      if (webrtcDetectedVersion < 27) {\n\t        var turn_url_parts = url.split('?');\n\t        if (turn_url_parts.length === 1 ||\n\t          turn_url_parts[1].indexOf('transport=udp') === 0) {\n\t          iceServer = {\n\t            url : turn_url_parts[0],\n\t            credential : password,\n\t            username : username\n\t          };\n\t        }\n\t      } else {\n\t        iceServer = {\n\t          url : url,\n\t          credential : password,\n\t          username : username\n\t        };\n\t      }\n\t    }\n\t    return iceServer;\n\t  };\n\t\n\t  createIceServers = function (urls, username, password) {\n\t    var iceServers = [];\n\t    for (i = 0; i < urls.length; i++) {\n\t      var iceServer = createIceServer(urls[i], username, password);\n\t      if (iceServer !== null) {\n\t        iceServers.push(iceServer);\n\t      }\n\t    }\n\t    return iceServers;\n\t  };\n\t\n\t  attachMediaStream = function (element, stream) {\n\t    element.mozSrcObject = stream;\n\t    element.play();\n\t    return element;\n\t  };\n\t\n\t  reattachMediaStream = function (to, from) {\n\t    to.mozSrcObject = from.mozSrcObject;\n\t    to.play();\n\t    return to;\n\t  };\n\t\n\t  MediaStreamTrack.getSources = MediaStreamTrack.getSources || function (callback) {\n\t    if (!callback) {\n\t      throw new TypeError('Failed to execute \\'getSources\\' on \\'MediaStreamTrack\\'' +\n\t        ': 1 argument required, but only 0 present.');\n\t    }\n\t    return callback([]);\n\t  };\n\t\n\t  // Fake get{Video,Audio}Tracks\n\t  if (!MediaStream.prototype.getVideoTracks) {\n\t    MediaStream.prototype.getVideoTracks = function () {\n\t      return [];\n\t    };\n\t  }\n\t  if (!MediaStream.prototype.getAudioTracks) {\n\t    MediaStream.prototype.getAudioTracks = function () {\n\t      return [];\n\t    };\n\t  }\n\t} else if (navigator.webkitGetUserMedia) {\n\t  webrtcDetectedBrowser = 'chrome';\n\t  webrtcDetectedType = 'webkit';\n\t  webrtcDetectedVersion = parseInt(navigator\n\t    .userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./)[2], 10);\n\t  // check if browser is opera 20+\n\t  var checkIfOpera = navigator.userAgent.match(/\\bOPR\\/(\\d+)/);\n\t  if (checkIfOpera !== null) {\n\t    webrtcDetectedBrowser = 'opera';\n\t    webrtcDetectedVersion = parseInt(checkIfOpera[1], 10);\n\t  }\n\t  // check browser datachannel support\n\t  if ((webrtcDetectedBrowser === 'chrome' && webrtcDetectedVersion >= 31) ||\n\t    (webrtcDetectedBrowser === 'opera' && webrtcDetectedVersion >= 20)) {\n\t    webrtcDetectedDCSupport = 'SCTP';\n\t  } else if (webrtcDetectedBrowser === 'chrome' && webrtcDetectedVersion < 30 &&\n\t    webrtcDetectedVersion > 24) {\n\t    webrtcDetectedDCSupport = 'RTP';\n\t  } else {\n\t    webrtcDetectedDCSupport = '';\n\t  }\n\t\n\t  createIceServer = function (url, username, password) {\n\t    var iceServer = null;\n\t    var url_parts = url.split(':');\n\t    if (url_parts[0].indexOf('stun') === 0) {\n\t      iceServer = { 'url' : url };\n\t    } else if (url_parts[0].indexOf('turn') === 0) {\n\t      iceServer = {\n\t        'url' : url,\n\t        'credential' : password,\n\t        'username' : username\n\t      };\n\t    }\n\t    return iceServer;\n\t  };\n\t\n\t  createIceServers = function (urls, username, password) {\n\t    var iceServers = [];\n\t    if (webrtcDetectedVersion >= 34) {\n\t      iceServers = {\n\t        'urls' : urls,\n\t        'credential' : password,\n\t        'username' : username\n\t      };\n\t    } else {\n\t      for (i = 0; i < urls.length; i++) {\n\t        var iceServer = createIceServer(urls[i], username, password);\n\t        if (iceServer !== null) {\n\t          iceServers.push(iceServer);\n\t        }\n\t      }\n\t    }\n\t    return iceServers;\n\t  };\n\t\n\t  RTCPeerConnection = function (pcConfig, pcConstraints) {\n\t    if (webrtcDetectedVersion < 34) {\n\t      AdapterJS.maybeFixConfiguration(pcConfig);\n\t    }\n\t    return new webkitRTCPeerConnection(pcConfig, pcConstraints);\n\t  };\n\t\n\t  getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n\t  navigator.getUserMedia = getUserMedia;\n\t\n\t  attachMediaStream = function (element, stream) {\n\t    if (typeof element.srcObject !== 'undefined') {\n\t      element.srcObject = stream;\n\t    } else if (typeof element.mozSrcObject !== 'undefined') {\n\t      element.mozSrcObject = stream;\n\t    } else if (typeof element.src !== 'undefined') {\n\t      element.src = URL.createObjectURL(stream);\n\t    } else {\n\t      console.log('Error attaching stream to element.');\n\t    }\n\t    return element;\n\t  };\n\t\n\t  reattachMediaStream = function (to, from) {\n\t    to.src = from.src;\n\t    return to;\n\t  };\n\t} else { // TRY TO USE PLUGIN\n\t  // IE 9 is not offering an implementation of console.log until you open a console\n\t  if (typeof console !== 'object' || typeof console.log !== 'function') {\n\t    /* jshint -W020 */\n\t    console = {} || console;\n\t    // Implemented based on console specs from MDN\n\t    // You may override these functions\n\t    console.log = function (arg) {};\n\t    console.info = function (arg) {};\n\t    console.error = function (arg) {};\n\t    console.dir = function (arg) {};\n\t    console.exception = function (arg) {};\n\t    console.trace = function (arg) {};\n\t    console.warn = function (arg) {};\n\t    console.count = function (arg) {};\n\t    console.debug = function (arg) {};\n\t    console.count = function (arg) {};\n\t    console.time = function (arg) {};\n\t    console.timeEnd = function (arg) {};\n\t    console.group = function (arg) {};\n\t    console.groupCollapsed = function (arg) {};\n\t    console.groupEnd = function (arg) {};\n\t    /* jshint +W020 */\n\t  }\n\t  webrtcDetectedType = 'plugin';\n\t  webrtcDetectedDCSupport = 'plugin';\n\t  AdapterJS.parseWebrtcDetectedBrowser();\n\t  isIE = webrtcDetectedBrowser === 'IE';\n\t\n\t  /* jshint -W035 */\n\t  AdapterJS.WebRTCPlugin.WaitForPluginReady = function() {\n\t    while (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n\t      /* empty because it needs to prevent the function from running. */\n\t    }\n\t  };\n\t  /* jshint +W035 */\n\t\n\t  AdapterJS.WebRTCPlugin.callWhenPluginReady = function (callback) {\n\t    if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n\t      // Call immediately if possible\n\t      // Once the plugin is set, the code will always take this path\n\t      callback();\n\t    } else {\n\t      // otherwise start a 100ms interval\n\t      var checkPluginReadyState = setInterval(function () {\n\t        if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n\t          clearInterval(checkPluginReadyState);\n\t          callback();\n\t        }\n\t      }, 100);\n\t    }\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.setLogLevel = function(logLevel) {\n\t    AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n\t      AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);\n\t    });\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.injectPlugin = function () {\n\t    // only inject once the page is ready\n\t    if (document.readyState !== 'complete')\n\t      return;\n\t\n\t    // Prevent multiple injections\n\t    if (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING)\n\t      return;\n\t\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING;\n\t\n\t    if (webrtcDetectedBrowser === 'IE' && webrtcDetectedVersion <= 10) {\n\t      var frag = document.createDocumentFragment();\n\t      AdapterJS.WebRTCPlugin.plugin = document.createElement('div');\n\t      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" type=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.type + '\" ' + 'width=\"1\" height=\"1\">' +\n\t        '<param name=\"pluginId\" value=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" /> ' +\n\t        '<param name=\"windowless\" value=\"false\" /> ' +\n\t        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n\t        '<param name=\"onload\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.onload +\n\t        '\" />' +\n\t        // uncomment to be able to use virtual cams\n\t        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n\t\n\t        '</object>';\n\t      while (AdapterJS.WebRTCPlugin.plugin.firstChild) {\n\t        frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);\n\t      }\n\t      document.body.appendChild(frag);\n\t\n\t      // Need to re-fetch the plugin\n\t      AdapterJS.WebRTCPlugin.plugin =\n\t        document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);\n\t    } else {\n\t      // Load Plugin\n\t      AdapterJS.WebRTCPlugin.plugin = document.createElement('object');\n\t      AdapterJS.WebRTCPlugin.plugin.id =\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId;\n\t      // IE will only start the plugin if it's ACTUALLY visible\n\t      if (isIE) {\n\t        AdapterJS.WebRTCPlugin.plugin.width = '1px';\n\t        AdapterJS.WebRTCPlugin.plugin.height = '1px';\n\t      }\n\t      AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type;\n\t      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name=\"onload\" value=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.onload + '\">' +\n\t        '<param name=\"pluginId\" value=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\">' +\n\t        '<param name=\"windowless\" value=\"false\" /> ' +\n\t        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n\t        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\">';\n\t      document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);\n\t    }\n\t\n\t\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.isPluginInstalled =\n\t    function (comName, plugName, installedCb, notInstalledCb) {\n\t    if (!isIE) {\n\t      var pluginArray = navigator.plugins;\n\t      for (var i = 0; i < pluginArray.length; i++) {\n\t        if (pluginArray[i].name.indexOf(plugName) >= 0) {\n\t          installedCb();\n\t          return;\n\t        }\n\t      }\n\t      notInstalledCb();\n\t    } else {\n\t      try {\n\t        var axo = new ActiveXObject(comName + '.' + plugName);\n\t      } catch (e) {\n\t        notInstalledCb();\n\t        return;\n\t      }\n\t      installedCb();\n\t    }\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.defineWebRTCInterface = function () {\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING;\n\t\n\t    AdapterJS.isDefined = function (variable) {\n\t      return variable !== null && variable !== undefined;\n\t    };\n\t\n\t    createIceServer = function (url, username, password) {\n\t      var iceServer = null;\n\t      var url_parts = url.split(':');\n\t      if (url_parts[0].indexOf('stun') === 0) {\n\t        iceServer = {\n\t          'url' : url,\n\t          'hasCredentials' : false\n\t        };\n\t      } else if (url_parts[0].indexOf('turn') === 0) {\n\t        iceServer = {\n\t          'url' : url,\n\t          'hasCredentials' : true,\n\t          'credential' : password,\n\t          'username' : username\n\t        };\n\t      }\n\t      return iceServer;\n\t    };\n\t\n\t    createIceServers = function (urls, username, password) {\n\t      var iceServers = [];\n\t      for (var i = 0; i < urls.length; ++i) {\n\t        iceServers.push(createIceServer(urls[i], username, password));\n\t      }\n\t      return iceServers;\n\t    };\n\t\n\t    RTCSessionDescription = function (info) {\n\t      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t      return AdapterJS.WebRTCPlugin.plugin.\n\t        ConstructSessionDescription(info.type, info.sdp);\n\t    };\n\t\n\t    RTCPeerConnection = function (servers, constraints) {\n\t      var iceServers = null;\n\t      if (servers) {\n\t        iceServers = servers.iceServers;\n\t        for (var i = 0; i < iceServers.length; i++) {\n\t          if (iceServers[i].urls && !iceServers[i].url) {\n\t            iceServers[i].url = iceServers[i].urls;\n\t          }\n\t          iceServers[i].hasCredentials = AdapterJS.\n\t            isDefined(iceServers[i].username) &&\n\t            AdapterJS.isDefined(iceServers[i].credential);\n\t        }\n\t      }\n\t      var mandatory = (constraints && constraints.mandatory) ?\n\t        constraints.mandatory : null;\n\t      var optional = (constraints && constraints.optional) ?\n\t        constraints.optional : null;\n\t\n\t      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t      return AdapterJS.WebRTCPlugin.plugin.\n\t        PeerConnection(AdapterJS.WebRTCPlugin.pageId,\n\t        iceServers, mandatory, optional);\n\t    };\n\t\n\t    MediaStreamTrack = {};\n\t    MediaStreamTrack.getSources = function (callback) {\n\t      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n\t        AdapterJS.WebRTCPlugin.plugin.GetSources(callback);\n\t      });\n\t    };\n\t\n\t    getUserMedia = function (constraints, successCallback, failureCallback) {\n\t      if (!constraints.audio) {\n\t        constraints.audio = false;\n\t      }\n\t\n\t      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n\t        AdapterJS.WebRTCPlugin.plugin.\n\t          getUserMedia(constraints, successCallback, failureCallback);\n\t      });\n\t    };\n\t    navigator.getUserMedia = getUserMedia;\n\t\n\t    attachMediaStream = function (element, stream) {\n\t      stream.enableSoundTracks(true);\n\t      if (element.nodeName.toLowerCase() !== 'audio') {\n\t        var elementId = element.id.length === 0 ? Math.random().toString(36).slice(2) : element.id;\n\t        if (!element.isWebRTCPlugin || !element.isWebRTCPlugin()) {\n\t          var frag = document.createDocumentFragment();\n\t          var temp = document.createElement('div');\n\t          var classHTML = (element.className) ? 'class=\"' + element.className + '\" ' : '';\n\t          temp.innerHTML = '<object id=\"' + elementId + '\" ' + classHTML +\n\t            'type=\"' + AdapterJS.WebRTCPlugin.pluginInfo.type + '\">' +\n\t            '<param name=\"pluginId\" value=\"' + elementId + '\" /> ' +\n\t            '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n\t            '<param name=\"windowless\" value=\"true\" /> ' +\n\t            '<param name=\"streamId\" value=\"' + stream.id + '\" /> ' +\n\t            '</object>';\n\t          while (temp.firstChild) {\n\t            frag.appendChild(temp.firstChild);\n\t          }\n\t          var rectObject = element.getBoundingClientRect();\n\t          element.parentNode.insertBefore(frag, element);\n\t          frag = document.getElementById(elementId);\n\t          frag.width = rectObject.width + 'px';\n\t          frag.height = rectObject.height + 'px';\n\t          element.parentNode.removeChild(element);\n\t        } else {\n\t          var children = element.children;\n\t          for (var i = 0; i !== children.length; ++i) {\n\t            if (children[i].name === 'streamId') {\n\t              children[i].value = stream.id;\n\t              break;\n\t            }\n\t          }\n\t          element.setStreamId(stream.id);\n\t        }\n\t        var newElement = document.getElementById(elementId);\n\t        newElement.onplaying = (element.onplaying) ? element.onplaying : function (arg) {};\n\t        if (isIE) { // on IE the event needs to be plugged manually\n\t          newElement.attachEvent('onplaying', newElement.onplaying);\n\t          newElement.onclick = (element.onclick) ? element.onclick : function (arg) {};\n\t          newElement._TemOnClick = function (id) {\n\t            var arg = {\n\t              srcElement : document.getElementById(id)\n\t            };\n\t            newElement.onclick(arg);\n\t          };\n\t        }\n\t        return newElement;\n\t      } else {\n\t        return element;\n\t      }\n\t    };\n\t\n\t    reattachMediaStream = function (to, from) {\n\t      var stream = null;\n\t      var children = from.children;\n\t      for (var i = 0; i !== children.length; ++i) {\n\t        if (children[i].name === 'streamId') {\n\t          AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t          stream = AdapterJS.WebRTCPlugin.plugin\n\t            .getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);\n\t          break;\n\t        }\n\t      }\n\t      if (stream !== null) {\n\t        return attachMediaStream(to, stream);\n\t      } else {\n\t        console.log('Could not find the stream associated with this element');\n\t      }\n\t    };\n\t\n\t    RTCIceCandidate = function (candidate) {\n\t      if (!candidate.sdpMid) {\n\t        candidate.sdpMid = '';\n\t      }\n\t\n\t      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t      return AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(\n\t        candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate\n\t      );\n\t    };\n\t\n\t    // inject plugin\n\t    AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.injectPlugin);\n\t    AdapterJS.WebRTCPlugin.injectPlugin();\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = function() {\n\t    AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv);\n\t    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();\n\t  }\n\t\n\t  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function () {\n\t    if (AdapterJS.options.hidePluginInstallPrompt)\n\t      return;\n\t\n\t    var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;\n\t    if(downloadLink) { // if download link\n\t      var popupString;\n\t      if (AdapterJS.WebRTCPlugin.pluginInfo.portalLink) { // is portal link\n\t       popupString = 'This website requires you to install the ' +\n\t        ' <a href=\"' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink +\n\t        '\" target=\"_blank\">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName +\n\t        ' WebRTC Plugin</a>' +\n\t        ' to work on this browser.';\n\t      } else { // no portal link, just print a generic explanation\n\t       popupString = 'This website requires you to install a WebRTC-enabling plugin ' +\n\t        'to work on this browser.';\n\t      }\n\t\n\t      AdapterJS.WebRTCPlugin.renderNotificationBar(popupString, 'Install Now', downloadLink);\n\t    } else { // no download link, just print a generic explanation\n\t      AdapterJS.WebRTCPlugin.renderNotificationBar('Your browser does not support WebRTC.');\n\t    }\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.renderNotificationBar = function (text, buttonText, buttonLink) {\n\t    // only inject once the page is ready\n\t    if (document.readyState !== 'complete')\n\t      return;\n\t\n\t    var w = window;\n\t    var i = document.createElement('iframe');\n\t    i.style.position = 'fixed';\n\t    i.style.top = '-41px';\n\t    i.style.left = 0;\n\t    i.style.right = 0;\n\t    i.style.width = '100%';\n\t    i.style.height = '40px';\n\t    i.style.backgroundColor = '#ffffe1';\n\t    i.style.border = 'none';\n\t    i.style.borderBottom = '1px solid #888888';\n\t    i.style.zIndex = '9999999';\n\t    if(typeof i.style.webkitTransition === 'string') {\n\t      i.style.webkitTransition = 'all .5s ease-out';\n\t    } else if(typeof i.style.transition === 'string') {\n\t      i.style.transition = 'all .5s ease-out';\n\t    }\n\t    document.body.appendChild(i);\n\t    c = (i.contentWindow) ? i.contentWindow :\n\t      (i.contentDocument.document) ? i.contentDocument.document : i.contentDocument;\n\t    c.document.open();\n\t    c.document.write('<span style=\"font-family: Helvetica, Arial,' +\n\t      'sans-serif; font-size: .9rem; padding: 7px; vertical-align: ' +\n\t      'middle; cursor: default;\">' + text + '</span>');\n\t    if(buttonText && buttonLink) {\n\t      c.document.write('<button id=\"okay\">' + buttonText + '</button><button>Cancel</button>');\n\t      c.document.close();\n\t      AdapterJS.addEvent(c.document.getElementById('okay'), 'click', function(e) {\n\t        window.open(buttonLink, '_top');\n\t        e.preventDefault();\n\t        try {\n\t          event.cancelBubble = true;\n\t        } catch(error) { }\n\t      });\n\t    }\n\t    else {\n\t      c.document.close();\n\t    }\n\t    AdapterJS.addEvent(c.document, 'click', function() {\n\t      w.document.body.removeChild(i);\n\t    });\n\t    setTimeout(function() {\n\t      if(typeof i.style.webkitTransform === 'string') {\n\t        i.style.webkitTransform = 'translateY(40px)';\n\t      } else if(typeof i.style.transform === 'string') {\n\t        i.style.transform = 'translateY(40px)';\n\t      } else {\n\t        i.style.top = '0px';\n\t      }\n\t    }, 300);\n\t  };\n\t  // Try to detect the plugin and act accordingly\n\t  AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName,\n\t    AdapterJS.WebRTCPlugin.defineWebRTCInterface,\n\t    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);\n\t}\n\t\n\t\n\twindow.RTCPeerConnection = RTCPeerConnection;\n\twindow.getUserMedia = getUserMedia;\n\twindow.attachMediaStream = attachMediaStream;\n\twindow.reattachMediaStream = reattachMediaStream;\n\twindow.webrtcDetectedBrowser = webrtcDetectedBrowser;\n\twindow.webrtcDetectedVersion = webrtcDetectedVersion;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t * loglevel - https://github.com/pimterry/loglevel\r\n\t *\r\n\t * Copyright (c) 2013 Tim Perry\r\n\t * Licensed under the MIT license.\r\n\t */\r\n\t\r\n\t;(function (undefined) {\r\n\t    var undefinedType = \"undefined\";\r\n\t    \r\n\t    (function (name, definition) {\r\n\t        if (true) {\r\n\t            module.exports = definition();\r\n\t        } else if (typeof define === 'function' && typeof define.amd === 'object') {\r\n\t            define(definition);\r\n\t        } else {\r\n\t            this[name] = definition();\r\n\t        }\r\n\t    }('log', function () {\r\n\t        var self = {};\r\n\t        var noop = function() {};\r\n\t\r\n\t        function realMethod(methodName) {\r\n\t            if (typeof console === undefinedType) {\r\n\t                return noop;\r\n\t            } else if (console[methodName] === undefined) {\r\n\t                return boundToConsole(console, 'log') || noop;\r\n\t            } else {\r\n\t                return boundToConsole(console, methodName);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function boundToConsole(console, methodName) {\r\n\t            var method = console[methodName];\r\n\t            if (method.bind === undefined) {\r\n\t                if (Function.prototype.bind === undefined) {\r\n\t                    return function() {\r\n\t                        method.apply(console, arguments);\r\n\t                    };\r\n\t                } else {\r\n\t                    return Function.prototype.bind.call(console[methodName], console);\r\n\t                }\r\n\t            } else {\r\n\t                return console[methodName].bind(console);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        var logMethods = [\r\n\t            \"trace\",\r\n\t            \"debug\",\r\n\t            \"info\",\r\n\t            \"warn\",\r\n\t            \"error\"\r\n\t        ];\r\n\t\r\n\t        function clearMethods() {\r\n\t            for (var ii = 0; ii < logMethods.length; ii++) {\r\n\t                self[logMethods[ii]] = noop;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function cookiesAvailable() {\r\n\t            return (typeof window !== undefinedType &&\r\n\t                    window.document !== undefined &&\r\n\t                    window.document.cookie !== undefined);\r\n\t        }\r\n\t\r\n\t        function setLevelInCookie(levelNum) {\r\n\t            if (!cookiesAvailable()) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var levelName;\r\n\t\r\n\t            for (var key in self.levels) {\r\n\t                if (self.levels.hasOwnProperty(key) && self.levels[key] === levelNum) {\r\n\t                    levelName = key;\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (levelName !== undefined) {\r\n\t                window.document.cookie = \"loglevel=\" + levelName + \";\";\r\n\t            }\r\n\t        }\r\n\t\r\n\t        var cookieRegex = /loglevel=([^;]+)/;\r\n\t\r\n\t        function loadLevelFromCookie() {\r\n\t            var cookieLevel;\r\n\t\r\n\t            if (cookiesAvailable()) {\r\n\t                var cookieMatch = cookieRegex.exec(window.document.cookie) || [];\r\n\t                cookieLevel = cookieMatch[1];\r\n\t            }\r\n\t\r\n\t            self.setLevel(self.levels[cookieLevel] || self.levels.WARN);\r\n\t        }\r\n\t\r\n\t        /*\r\n\t         *\r\n\t         * Public API\r\n\t         *\r\n\t         */\r\n\t\r\n\t        self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n\t            \"ERROR\": 4, \"SILENT\": 5};\r\n\t\r\n\t        self.setLevel = function (level) {\r\n\t            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n\t                setLevelInCookie(level);\r\n\t\r\n\t                if (level === self.levels.SILENT) {\r\n\t                    clearMethods();\r\n\t                    return;\r\n\t                } else if (typeof console === undefinedType) {\r\n\t                    clearMethods();\r\n\t                    throw \"No console available for logging\";\r\n\t                } else {\r\n\t                    for (var ii = 0; ii < logMethods.length; ii++) {\r\n\t                        var methodName = logMethods[ii];\r\n\t\r\n\t                        if (level <= self.levels[methodName.toUpperCase()]) {\r\n\t                            self[methodName] = realMethod(methodName);\r\n\t                        } else {\r\n\t                            self[methodName] = noop;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            } else if (typeof level === \"string\") {\r\n\t                self.setLevel(self.levels[level.toUpperCase()]);\r\n\t            } else {\r\n\t                throw \"log.setLevel() called with invalid level: \" + level;\r\n\t            }\r\n\t        };\r\n\t\r\n\t        self.enableAll = function() {\r\n\t            self.setLevel(self.levels.TRACE);\r\n\t        };\r\n\t\r\n\t        self.disableAll = function() {\r\n\t            self.setLevel(self.levels.SILENT);\r\n\t        };\r\n\t\r\n\t        try {\r\n\t            loadLevelFromCookie();\r\n\t        } catch (e) {\r\n\t            self.setLevel(self.levels.SILENT);\r\n\t        }\r\n\t        return self;\r\n\t    }));\r\n\t})();\r\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// vim:ts=4:sts=4:sw=4:\n\t/*!\n\t *\n\t * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n\t * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n\t *\n\t * With parts by Tyler Close\n\t * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n\t * at http://www.opensource.org/licenses/mit-license.html\n\t * Forked at ref_send.js version: 2009-05-11\n\t *\n\t * With parts by Mark Miller\n\t * Copyright (C) 2011 Google Inc.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t */\n\t\n\t(function (definition) {\n\t    \"use strict\";\n\t\n\t    // This file will function properly as a <script> tag, or a module\n\t    // using CommonJS and NodeJS or RequireJS module formats.  In\n\t    // Common/Node/RequireJS, the module exports the Q API and when\n\t    // executed as a simple <script>, it creates a Q global instead.\n\t\n\t    // Montage Require\n\t    if (typeof bootstrap === \"function\") {\n\t        bootstrap(\"promise\", definition);\n\t\n\t    // CommonJS\n\t    } else if (true) {\n\t        module.exports = definition();\n\t\n\t    // RequireJS\n\t    } else if (typeof define === \"function\" && define.amd) {\n\t        define(definition);\n\t\n\t    // SES (Secure EcmaScript)\n\t    } else if (typeof ses !== \"undefined\") {\n\t        if (!ses.ok()) {\n\t            return;\n\t        } else {\n\t            ses.makeQ = definition;\n\t        }\n\t\n\t    // <script>\n\t    } else if (typeof self !== \"undefined\") {\n\t        self.Q = definition();\n\t\n\t    } else {\n\t        throw new Error(\"This environment was not anticiapted by Q. Please file a bug.\");\n\t    }\n\t\n\t})(function () {\n\t\"use strict\";\n\t\n\tvar hasStacks = false;\n\ttry {\n\t    throw new Error();\n\t} catch (e) {\n\t    hasStacks = !!e.stack;\n\t}\n\t\n\t// All code after this point will be filtered from stack traces reported\n\t// by Q.\n\tvar qStartingLine = captureLine();\n\tvar qFileName;\n\t\n\t// shims\n\t\n\t// used for fallback in \"allResolved\"\n\tvar noop = function () {};\n\t\n\t// Use the fastest possible means to execute a task in a future turn\n\t// of the event loop.\n\tvar nextTick =(function () {\n\t    // linked list of tasks (single, with head node)\n\t    var head = {task: void 0, next: null};\n\t    var tail = head;\n\t    var flushing = false;\n\t    var requestTick = void 0;\n\t    var isNodeJS = false;\n\t\n\t    function flush() {\n\t        /* jshint loopfunc: true */\n\t\n\t        while (head.next) {\n\t            head = head.next;\n\t            var task = head.task;\n\t            head.task = void 0;\n\t            var domain = head.domain;\n\t\n\t            if (domain) {\n\t                head.domain = void 0;\n\t                domain.enter();\n\t            }\n\t\n\t            try {\n\t                task();\n\t\n\t            } catch (e) {\n\t                if (isNodeJS) {\n\t                    // In node, uncaught exceptions are considered fatal errors.\n\t                    // Re-throw them synchronously to interrupt flushing!\n\t\n\t                    // Ensure continuation if the uncaught exception is suppressed\n\t                    // listening \"uncaughtException\" events (as domains does).\n\t                    // Continue in next event to avoid tick recursion.\n\t                    if (domain) {\n\t                        domain.exit();\n\t                    }\n\t                    setTimeout(flush, 0);\n\t                    if (domain) {\n\t                        domain.enter();\n\t                    }\n\t\n\t                    throw e;\n\t\n\t                } else {\n\t                    // In browsers, uncaught exceptions are not fatal.\n\t                    // Re-throw them asynchronously to avoid slow-downs.\n\t                    setTimeout(function() {\n\t                       throw e;\n\t                    }, 0);\n\t                }\n\t            }\n\t\n\t            if (domain) {\n\t                domain.exit();\n\t            }\n\t        }\n\t\n\t        flushing = false;\n\t    }\n\t\n\t    nextTick = function (task) {\n\t        tail = tail.next = {\n\t            task: task,\n\t            domain: isNodeJS && process.domain,\n\t            next: null\n\t        };\n\t\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t\n\t    if (typeof process !== \"undefined\" && process.nextTick) {\n\t        // Node.js before 0.9. Note that some fake-Node environments, like the\n\t        // Mocha test runner, introduce a `process` global without a `nextTick`.\n\t        isNodeJS = true;\n\t\n\t        requestTick = function () {\n\t            process.nextTick(flush);\n\t        };\n\t\n\t    } else if (typeof setImmediate === \"function\") {\n\t        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n\t        if (typeof window !== \"undefined\") {\n\t            requestTick = setImmediate.bind(window, flush);\n\t        } else {\n\t            requestTick = function () {\n\t                setImmediate(flush);\n\t            };\n\t        }\n\t\n\t    } else if (typeof MessageChannel !== \"undefined\") {\n\t        // modern browsers\n\t        // http://www.nonblocking.io/2011/06/windownexttick.html\n\t        var channel = new MessageChannel();\n\t        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n\t        // working message ports the first time a page loads.\n\t        channel.port1.onmessage = function () {\n\t            requestTick = requestPortTick;\n\t            channel.port1.onmessage = flush;\n\t            flush();\n\t        };\n\t        var requestPortTick = function () {\n\t            // Opera requires us to provide a message payload, regardless of\n\t            // whether we use it.\n\t            channel.port2.postMessage(0);\n\t        };\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t            requestPortTick();\n\t        };\n\t\n\t    } else {\n\t        // old browsers\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t        };\n\t    }\n\t\n\t    return nextTick;\n\t})();\n\t\n\t// Attempt to make generics safe in the face of downstream\n\t// modifications.\n\t// There is no situation where this is necessary.\n\t// If you need a security guarantee, these primordials need to be\n\t// deeply frozen anyway, and if you dont need a security guarantee,\n\t// this is just plain paranoid.\n\t// However, this **might** have the nice side-effect of reducing the size of\n\t// the minified code by reducing x.call() to merely x()\n\t// See Mark Millers explanation of what this does.\n\t// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n\tvar call = Function.call;\n\tfunction uncurryThis(f) {\n\t    return function () {\n\t        return call.apply(f, arguments);\n\t    };\n\t}\n\t// This is equivalent, but slower:\n\t// uncurryThis = Function_bind.bind(Function_bind.call);\n\t// http://jsperf.com/uncurrythis\n\t\n\tvar array_slice = uncurryThis(Array.prototype.slice);\n\t\n\tvar array_reduce = uncurryThis(\n\t    Array.prototype.reduce || function (callback, basis) {\n\t        var index = 0,\n\t            length = this.length;\n\t        // concerning the initial value, if one is not provided\n\t        if (arguments.length === 1) {\n\t            // seek to the first value in the array, accounting\n\t            // for the possibility that is is a sparse array\n\t            do {\n\t                if (index in this) {\n\t                    basis = this[index++];\n\t                    break;\n\t                }\n\t                if (++index >= length) {\n\t                    throw new TypeError();\n\t                }\n\t            } while (1);\n\t        }\n\t        // reduce\n\t        for (; index < length; index++) {\n\t            // account for the possibility that the array is sparse\n\t            if (index in this) {\n\t                basis = callback(basis, this[index], index);\n\t            }\n\t        }\n\t        return basis;\n\t    }\n\t);\n\t\n\tvar array_indexOf = uncurryThis(\n\t    Array.prototype.indexOf || function (value) {\n\t        // not a very good shim, but good enough for our one use of it\n\t        for (var i = 0; i < this.length; i++) {\n\t            if (this[i] === value) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t);\n\t\n\tvar array_map = uncurryThis(\n\t    Array.prototype.map || function (callback, thisp) {\n\t        var self = this;\n\t        var collect = [];\n\t        array_reduce(self, function (undefined, value, index) {\n\t            collect.push(callback.call(thisp, value, index, self));\n\t        }, void 0);\n\t        return collect;\n\t    }\n\t);\n\t\n\tvar object_create = Object.create || function (prototype) {\n\t    function Type() { }\n\t    Type.prototype = prototype;\n\t    return new Type();\n\t};\n\t\n\tvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\t\n\tvar object_keys = Object.keys || function (object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t        if (object_hasOwnProperty(object, key)) {\n\t            keys.push(key);\n\t        }\n\t    }\n\t    return keys;\n\t};\n\t\n\tvar object_toString = uncurryThis(Object.prototype.toString);\n\t\n\tfunction isObject(value) {\n\t    return value === Object(value);\n\t}\n\t\n\t// generator related shims\n\t\n\t// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n\tfunction isStopIteration(exception) {\n\t    return (\n\t        object_toString(exception) === \"[object StopIteration]\" ||\n\t        exception instanceof QReturnValue\n\t    );\n\t}\n\t\n\t// FIXME: Remove this helper and Q.return once ES6 generators are in\n\t// SpiderMonkey.\n\tvar QReturnValue;\n\tif (typeof ReturnValue !== \"undefined\") {\n\t    QReturnValue = ReturnValue;\n\t} else {\n\t    QReturnValue = function (value) {\n\t        this.value = value;\n\t    };\n\t}\n\t\n\t// long stack traces\n\t\n\tvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\t\n\tfunction makeStackTraceLong(error, promise) {\n\t    // If possible, transform the error stack trace by removing Node and Q\n\t    // cruft, then concatenating with the stack trace of `promise`. See #57.\n\t    if (hasStacks &&\n\t        promise.stack &&\n\t        typeof error === \"object\" &&\n\t        error !== null &&\n\t        error.stack &&\n\t        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n\t    ) {\n\t        var stacks = [];\n\t        for (var p = promise; !!p; p = p.source) {\n\t            if (p.stack) {\n\t                stacks.unshift(p.stack);\n\t            }\n\t        }\n\t        stacks.unshift(error.stack);\n\t\n\t        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n\t        error.stack = filterStackString(concatedStacks);\n\t    }\n\t}\n\t\n\tfunction filterStackString(stackString) {\n\t    var lines = stackString.split(\"\\n\");\n\t    var desiredLines = [];\n\t    for (var i = 0; i < lines.length; ++i) {\n\t        var line = lines[i];\n\t\n\t        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n\t            desiredLines.push(line);\n\t        }\n\t    }\n\t    return desiredLines.join(\"\\n\");\n\t}\n\t\n\tfunction isNodeFrame(stackLine) {\n\t    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n\t           stackLine.indexOf(\"(node.js:\") !== -1;\n\t}\n\t\n\tfunction getFileNameAndLineNumber(stackLine) {\n\t    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n\t    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n\t    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\t    if (attempt1) {\n\t        return [attempt1[1], Number(attempt1[2])];\n\t    }\n\t\n\t    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n\t    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\t    if (attempt2) {\n\t        return [attempt2[1], Number(attempt2[2])];\n\t    }\n\t\n\t    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n\t    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\t    if (attempt3) {\n\t        return [attempt3[1], Number(attempt3[2])];\n\t    }\n\t}\n\t\n\tfunction isInternalFrame(stackLine) {\n\t    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\t\n\t    if (!fileNameAndLineNumber) {\n\t        return false;\n\t    }\n\t\n\t    var fileName = fileNameAndLineNumber[0];\n\t    var lineNumber = fileNameAndLineNumber[1];\n\t\n\t    return fileName === qFileName &&\n\t        lineNumber >= qStartingLine &&\n\t        lineNumber <= qEndingLine;\n\t}\n\t\n\t// discover own file name and line number range for filtering stack\n\t// traces\n\tfunction captureLine() {\n\t    if (!hasStacks) {\n\t        return;\n\t    }\n\t\n\t    try {\n\t        throw new Error();\n\t    } catch (e) {\n\t        var lines = e.stack.split(\"\\n\");\n\t        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n\t        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\t        if (!fileNameAndLineNumber) {\n\t            return;\n\t        }\n\t\n\t        qFileName = fileNameAndLineNumber[0];\n\t        return fileNameAndLineNumber[1];\n\t    }\n\t}\n\t\n\tfunction deprecate(callback, name, alternative) {\n\t    return function () {\n\t        if (typeof console !== \"undefined\" &&\n\t            typeof console.warn === \"function\") {\n\t            console.warn(name + \" is deprecated, use \" + alternative +\n\t                         \" instead.\", new Error(\"\").stack);\n\t        }\n\t        return callback.apply(callback, arguments);\n\t    };\n\t}\n\t\n\t// end of shims\n\t// beginning of real work\n\t\n\t/**\n\t * Constructs a promise for an immediate reference, passes promises through, or\n\t * coerces promises from different systems.\n\t * @param value immediate reference or promise\n\t */\n\tfunction Q(value) {\n\t    // If the object is already a Promise, return it directly.  This enables\n\t    // the resolve function to both be used to created references from objects,\n\t    // but to tolerably coerce non-promises to promises.\n\t    if (value instanceof Promise) {\n\t        return value;\n\t    }\n\t\n\t    // assimilate thenables\n\t    if (isPromiseAlike(value)) {\n\t        return coerce(value);\n\t    } else {\n\t        return fulfill(value);\n\t    }\n\t}\n\tQ.resolve = Q;\n\t\n\t/**\n\t * Performs a task in a future turn of the event loop.\n\t * @param {Function} task\n\t */\n\tQ.nextTick = nextTick;\n\t\n\t/**\n\t * Controls whether or not long stack traces will be on\n\t */\n\tQ.longStackSupport = false;\n\t\n\t// enable long stacks if Q_DEBUG is set\n\tif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n\t    Q.longStackSupport = true;\n\t}\n\t\n\t/**\n\t * Constructs a {promise, resolve, reject} object.\n\t *\n\t * `resolve` is a callback to invoke with a more resolved value for the\n\t * promise. To fulfill the promise, invoke `resolve` with any value that is\n\t * not a thenable. To reject the promise, invoke `resolve` with a rejected\n\t * thenable, or invoke `reject` with the reason directly. To resolve the\n\t * promise to another thenable, thus putting it in the same state, invoke\n\t * `resolve` with that other thenable.\n\t */\n\tQ.defer = defer;\n\tfunction defer() {\n\t    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n\t    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n\t    // element of the messages array is itself an array of complete arguments to\n\t    // forward to the resolved promise.  We coerce the resolution value to a\n\t    // promise using the `resolve` function because it handles both fully\n\t    // non-thenable values and other thenables gracefully.\n\t    var messages = [], progressListeners = [], resolvedPromise;\n\t\n\t    var deferred = object_create(defer.prototype);\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, operands) {\n\t        var args = array_slice(arguments);\n\t        if (messages) {\n\t            messages.push(args);\n\t            if (op === \"when\" && operands[1]) { // progress operand\n\t                progressListeners.push(operands[1]);\n\t            }\n\t        } else {\n\t            Q.nextTick(function () {\n\t                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n\t            });\n\t        }\n\t    };\n\t\n\t    // XXX deprecated\n\t    promise.valueOf = function () {\n\t        if (messages) {\n\t            return promise;\n\t        }\n\t        var nearerValue = nearer(resolvedPromise);\n\t        if (isPromise(nearerValue)) {\n\t            resolvedPromise = nearerValue; // shorten chain\n\t        }\n\t        return nearerValue;\n\t    };\n\t\n\t    promise.inspect = function () {\n\t        if (!resolvedPromise) {\n\t            return { state: \"pending\" };\n\t        }\n\t        return resolvedPromise.inspect();\n\t    };\n\t\n\t    if (Q.longStackSupport && hasStacks) {\n\t        try {\n\t            throw new Error();\n\t        } catch (e) {\n\t            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n\t            // accessor around; that causes memory leaks as per GH-111. Just\n\t            // reify the stack trace as a string ASAP.\n\t            //\n\t            // At the same time, cut off the first line; it's always just\n\t            // \"[object Promise]\\n\", as per the `toString`.\n\t            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n\t        }\n\t    }\n\t\n\t    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n\t    // consolidating them into `become`, since otherwise we'd create new\n\t    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\t\n\t    function become(newPromise) {\n\t        resolvedPromise = newPromise;\n\t        promise.source = newPromise;\n\t\n\t        array_reduce(messages, function (undefined, message) {\n\t            Q.nextTick(function () {\n\t                newPromise.promiseDispatch.apply(newPromise, message);\n\t            });\n\t        }, void 0);\n\t\n\t        messages = void 0;\n\t        progressListeners = void 0;\n\t    }\n\t\n\t    deferred.promise = promise;\n\t    deferred.resolve = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(Q(value));\n\t    };\n\t\n\t    deferred.fulfill = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(fulfill(value));\n\t    };\n\t    deferred.reject = function (reason) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(reject(reason));\n\t    };\n\t    deferred.notify = function (progress) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        array_reduce(progressListeners, function (undefined, progressListener) {\n\t            Q.nextTick(function () {\n\t                progressListener(progress);\n\t            });\n\t        }, void 0);\n\t    };\n\t\n\t    return deferred;\n\t}\n\t\n\t/**\n\t * Creates a Node-style callback that will resolve or reject the deferred\n\t * promise.\n\t * @returns a nodeback\n\t */\n\tdefer.prototype.makeNodeResolver = function () {\n\t    var self = this;\n\t    return function (error, value) {\n\t        if (error) {\n\t            self.reject(error);\n\t        } else if (arguments.length > 2) {\n\t            self.resolve(array_slice(arguments, 1));\n\t        } else {\n\t            self.resolve(value);\n\t        }\n\t    };\n\t};\n\t\n\t/**\n\t * @param resolver {Function} a function that returns nothing and accepts\n\t * the resolve, reject, and notify functions for a deferred.\n\t * @returns a promise that may be resolved with the given resolve and reject\n\t * functions, or rejected by a thrown exception in resolver\n\t */\n\tQ.Promise = promise; // ES6\n\tQ.promise = promise;\n\tfunction promise(resolver) {\n\t    if (typeof resolver !== \"function\") {\n\t        throw new TypeError(\"resolver must be a function.\");\n\t    }\n\t    var deferred = defer();\n\t    try {\n\t        resolver(deferred.resolve, deferred.reject, deferred.notify);\n\t    } catch (reason) {\n\t        deferred.reject(reason);\n\t    }\n\t    return deferred.promise;\n\t}\n\t\n\tpromise.race = race; // ES6\n\tpromise.all = all; // ES6\n\tpromise.reject = reject; // ES6\n\tpromise.resolve = Q; // ES6\n\t\n\t// XXX experimental.  This method is a way to denote that a local value is\n\t// serializable and should be immediately dispatched to a remote upon request,\n\t// instead of passing a reference.\n\tQ.passByCopy = function (object) {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return object;\n\t};\n\t\n\tPromise.prototype.passByCopy = function () {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return this;\n\t};\n\t\n\t/**\n\t * If two promises eventually fulfill to the same value, promises that value,\n\t * but otherwise rejects.\n\t * @param x {Any*}\n\t * @param y {Any*}\n\t * @returns {Any*} a promise for x and y if they are the same, but a rejection\n\t * otherwise.\n\t *\n\t */\n\tQ.join = function (x, y) {\n\t    return Q(x).join(y);\n\t};\n\t\n\tPromise.prototype.join = function (that) {\n\t    return Q([this, that]).spread(function (x, y) {\n\t        if (x === y) {\n\t            // TODO: \"===\" should be Object.is or equiv\n\t            return x;\n\t        } else {\n\t            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Returns a promise for the first of an array of promises to become settled.\n\t * @param answers {Array[Any*]} promises to race\n\t * @returns {Any*} the first promise to be settled\n\t */\n\tQ.race = race;\n\tfunction race(answerPs) {\n\t    return promise(function(resolve, reject) {\n\t        // Switch to this once we can assume at least ES5\n\t        // answerPs.forEach(function(answerP) {\n\t        //     Q(answerP).then(resolve, reject);\n\t        // });\n\t        // Use this in the meantime\n\t        for (var i = 0, len = answerPs.length; i < len; i++) {\n\t            Q(answerPs[i]).then(resolve, reject);\n\t        }\n\t    });\n\t}\n\t\n\tPromise.prototype.race = function () {\n\t    return this.then(Q.race);\n\t};\n\t\n\t/**\n\t * Constructs a Promise with a promise descriptor object and optional fallback\n\t * function.  The descriptor contains methods like when(rejected), get(name),\n\t * set(name, value), post(name, args), and delete(name), which all\n\t * return either a value, a promise for a value, or a rejection.  The fallback\n\t * accepts the operation name, a resolver, and any further arguments that would\n\t * have been forwarded to the appropriate method above had a method been\n\t * provided with the proper name.  The API makes no guarantees about the nature\n\t * of the returned object, apart from that it is usable whereever promises are\n\t * bought and sold.\n\t */\n\tQ.makePromise = Promise;\n\tfunction Promise(descriptor, fallback, inspect) {\n\t    if (fallback === void 0) {\n\t        fallback = function (op) {\n\t            return reject(new Error(\n\t                \"Promise does not support operation: \" + op\n\t            ));\n\t        };\n\t    }\n\t    if (inspect === void 0) {\n\t        inspect = function () {\n\t            return {state: \"unknown\"};\n\t        };\n\t    }\n\t\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, args) {\n\t        var result;\n\t        try {\n\t            if (descriptor[op]) {\n\t                result = descriptor[op].apply(promise, args);\n\t            } else {\n\t                result = fallback.call(promise, op, args);\n\t            }\n\t        } catch (exception) {\n\t            result = reject(exception);\n\t        }\n\t        if (resolve) {\n\t            resolve(result);\n\t        }\n\t    };\n\t\n\t    promise.inspect = inspect;\n\t\n\t    // XXX deprecated `valueOf` and `exception` support\n\t    if (inspect) {\n\t        var inspected = inspect();\n\t        if (inspected.state === \"rejected\") {\n\t            promise.exception = inspected.reason;\n\t        }\n\t\n\t        promise.valueOf = function () {\n\t            var inspected = inspect();\n\t            if (inspected.state === \"pending\" ||\n\t                inspected.state === \"rejected\") {\n\t                return promise;\n\t            }\n\t            return inspected.value;\n\t        };\n\t    }\n\t\n\t    return promise;\n\t}\n\t\n\tPromise.prototype.toString = function () {\n\t    return \"[object Promise]\";\n\t};\n\t\n\tPromise.prototype.then = function (fulfilled, rejected, progressed) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    var done = false;   // ensure the untrusted promise makes at most a\n\t                        // single call to one of the callbacks\n\t\n\t    function _fulfilled(value) {\n\t        try {\n\t            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n\t        } catch (exception) {\n\t            return reject(exception);\n\t        }\n\t    }\n\t\n\t    function _rejected(exception) {\n\t        if (typeof rejected === \"function\") {\n\t            makeStackTraceLong(exception, self);\n\t            try {\n\t                return rejected(exception);\n\t            } catch (newException) {\n\t                return reject(newException);\n\t            }\n\t        }\n\t        return reject(exception);\n\t    }\n\t\n\t    function _progressed(value) {\n\t        return typeof progressed === \"function\" ? progressed(value) : value;\n\t    }\n\t\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(function (value) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_fulfilled(value));\n\t        }, \"when\", [function (exception) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_rejected(exception));\n\t        }]);\n\t    });\n\t\n\t    // Progress propagator need to be attached in the current tick.\n\t    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n\t        var newValue;\n\t        var threw = false;\n\t        try {\n\t            newValue = _progressed(value);\n\t        } catch (e) {\n\t            threw = true;\n\t            if (Q.onerror) {\n\t                Q.onerror(e);\n\t            } else {\n\t                throw e;\n\t            }\n\t        }\n\t\n\t        if (!threw) {\n\t            deferred.notify(newValue);\n\t        }\n\t    }]);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\tQ.tap = function (promise, callback) {\n\t    return Q(promise).tap(callback);\n\t};\n\t\n\t/**\n\t * Works almost like \"finally\", but not called for rejections.\n\t * Original resolution value is passed through callback unaffected.\n\t * Callback may return a promise that will be awaited for.\n\t * @param {Function} callback\n\t * @returns {Q.Promise}\n\t * @example\n\t * doSomething()\n\t *   .then(...)\n\t *   .tap(console.log)\n\t *   .then(...);\n\t */\n\tPromise.prototype.tap = function (callback) {\n\t    callback = Q(callback);\n\t\n\t    return this.then(function (value) {\n\t        return callback.fcall(value).thenResolve(value);\n\t    });\n\t};\n\t\n\t/**\n\t * Registers an observer on a promise.\n\t *\n\t * Guarantees:\n\t *\n\t * 1. that fulfilled and rejected will be called only once.\n\t * 2. that either the fulfilled callback or the rejected callback will be\n\t *    called, but not both.\n\t * 3. that fulfilled and rejected will not be called in this turn.\n\t *\n\t * @param value      promise or immediate reference to observe\n\t * @param fulfilled  function to be called with the fulfilled value\n\t * @param rejected   function to be called with the rejection exception\n\t * @param progressed function to be called on any progress notifications\n\t * @return promise for the return value from the invoked callback\n\t */\n\tQ.when = when;\n\tfunction when(value, fulfilled, rejected, progressed) {\n\t    return Q(value).then(fulfilled, rejected, progressed);\n\t}\n\t\n\tPromise.prototype.thenResolve = function (value) {\n\t    return this.then(function () { return value; });\n\t};\n\t\n\tQ.thenResolve = function (promise, value) {\n\t    return Q(promise).thenResolve(value);\n\t};\n\t\n\tPromise.prototype.thenReject = function (reason) {\n\t    return this.then(function () { throw reason; });\n\t};\n\t\n\tQ.thenReject = function (promise, reason) {\n\t    return Q(promise).thenReject(reason);\n\t};\n\t\n\t/**\n\t * If an object is not a promise, it is as \"near\" as possible.\n\t * If a promise is rejected, it is as \"near\" as possible too.\n\t * If its a fulfilled promise, the fulfillment value is nearer.\n\t * If its a deferred promise and the deferred has been resolved, the\n\t * resolution is \"nearer\".\n\t * @param object\n\t * @returns most resolved (nearest) form of the object\n\t */\n\t\n\t// XXX should we re-do this?\n\tQ.nearer = nearer;\n\tfunction nearer(value) {\n\t    if (isPromise(value)) {\n\t        var inspected = value.inspect();\n\t        if (inspected.state === \"fulfilled\") {\n\t            return inspected.value;\n\t        }\n\t    }\n\t    return value;\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a promise.\n\t * Otherwise it is a fulfilled value.\n\t */\n\tQ.isPromise = isPromise;\n\tfunction isPromise(object) {\n\t    return object instanceof Promise;\n\t}\n\t\n\tQ.isPromiseAlike = isPromiseAlike;\n\tfunction isPromiseAlike(object) {\n\t    return isObject(object) && typeof object.then === \"function\";\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a pending promise, meaning not\n\t * fulfilled or rejected.\n\t */\n\tQ.isPending = isPending;\n\tfunction isPending(object) {\n\t    return isPromise(object) && object.inspect().state === \"pending\";\n\t}\n\t\n\tPromise.prototype.isPending = function () {\n\t    return this.inspect().state === \"pending\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a value or fulfilled\n\t * promise.\n\t */\n\tQ.isFulfilled = isFulfilled;\n\tfunction isFulfilled(object) {\n\t    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n\t}\n\t\n\tPromise.prototype.isFulfilled = function () {\n\t    return this.inspect().state === \"fulfilled\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a rejected promise.\n\t */\n\tQ.isRejected = isRejected;\n\tfunction isRejected(object) {\n\t    return isPromise(object) && object.inspect().state === \"rejected\";\n\t}\n\t\n\tPromise.prototype.isRejected = function () {\n\t    return this.inspect().state === \"rejected\";\n\t};\n\t\n\t//// BEGIN UNHANDLED REJECTION TRACKING\n\t\n\t// This promise library consumes exceptions thrown in handlers so they can be\n\t// handled by a subsequent promise.  The exceptions get added to this array when\n\t// they are created, and removed when they are handled.  Note that in ES6 or\n\t// shimmed environments, this would naturally be a `Set`.\n\tvar unhandledReasons = [];\n\tvar unhandledRejections = [];\n\tvar trackUnhandledRejections = true;\n\t\n\tfunction resetUnhandledRejections() {\n\t    unhandledReasons.length = 0;\n\t    unhandledRejections.length = 0;\n\t\n\t    if (!trackUnhandledRejections) {\n\t        trackUnhandledRejections = true;\n\t    }\n\t}\n\t\n\tfunction trackRejection(promise, reason) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t\n\t    unhandledRejections.push(promise);\n\t    if (reason && typeof reason.stack !== \"undefined\") {\n\t        unhandledReasons.push(reason.stack);\n\t    } else {\n\t        unhandledReasons.push(\"(no stack) \" + reason);\n\t    }\n\t}\n\t\n\tfunction untrackRejection(promise) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t\n\t    var at = array_indexOf(unhandledRejections, promise);\n\t    if (at !== -1) {\n\t        unhandledRejections.splice(at, 1);\n\t        unhandledReasons.splice(at, 1);\n\t    }\n\t}\n\t\n\tQ.resetUnhandledRejections = resetUnhandledRejections;\n\t\n\tQ.getUnhandledReasons = function () {\n\t    // Make a copy so that consumers can't interfere with our internal state.\n\t    return unhandledReasons.slice();\n\t};\n\t\n\tQ.stopUnhandledRejectionTracking = function () {\n\t    resetUnhandledRejections();\n\t    trackUnhandledRejections = false;\n\t};\n\t\n\tresetUnhandledRejections();\n\t\n\t//// END UNHANDLED REJECTION TRACKING\n\t\n\t/**\n\t * Constructs a rejected promise.\n\t * @param reason value describing the failure\n\t */\n\tQ.reject = reject;\n\tfunction reject(reason) {\n\t    var rejection = Promise({\n\t        \"when\": function (rejected) {\n\t            // note that the error has been handled\n\t            if (rejected) {\n\t                untrackRejection(this);\n\t            }\n\t            return rejected ? rejected(reason) : this;\n\t        }\n\t    }, function fallback() {\n\t        return this;\n\t    }, function inspect() {\n\t        return { state: \"rejected\", reason: reason };\n\t    });\n\t\n\t    // Note that the reason has not been handled.\n\t    trackRejection(rejection, reason);\n\t\n\t    return rejection;\n\t}\n\t\n\t/**\n\t * Constructs a fulfilled promise for an immediate reference.\n\t * @param value immediate reference\n\t */\n\tQ.fulfill = fulfill;\n\tfunction fulfill(value) {\n\t    return Promise({\n\t        \"when\": function () {\n\t            return value;\n\t        },\n\t        \"get\": function (name) {\n\t            return value[name];\n\t        },\n\t        \"set\": function (name, rhs) {\n\t            value[name] = rhs;\n\t        },\n\t        \"delete\": function (name) {\n\t            delete value[name];\n\t        },\n\t        \"post\": function (name, args) {\n\t            // Mark Miller proposes that post with no name should apply a\n\t            // promised function.\n\t            if (name === null || name === void 0) {\n\t                return value.apply(void 0, args);\n\t            } else {\n\t                return value[name].apply(value, args);\n\t            }\n\t        },\n\t        \"apply\": function (thisp, args) {\n\t            return value.apply(thisp, args);\n\t        },\n\t        \"keys\": function () {\n\t            return object_keys(value);\n\t        }\n\t    }, void 0, function inspect() {\n\t        return { state: \"fulfilled\", value: value };\n\t    });\n\t}\n\t\n\t/**\n\t * Converts thenables to Q promises.\n\t * @param promise thenable promise\n\t * @returns a Q promise\n\t */\n\tfunction coerce(promise) {\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        try {\n\t            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n\t        } catch (exception) {\n\t            deferred.reject(exception);\n\t        }\n\t    });\n\t    return deferred.promise;\n\t}\n\t\n\t/**\n\t * Annotates an object such that it will never be\n\t * transferred away from this process over any promise\n\t * communication channel.\n\t * @param object\n\t * @returns promise a wrapping of that object that\n\t * additionally responds to the \"isDef\" message\n\t * without a rejection.\n\t */\n\tQ.master = master;\n\tfunction master(object) {\n\t    return Promise({\n\t        \"isDef\": function () {}\n\t    }, function fallback(op, args) {\n\t        return dispatch(object, op, args);\n\t    }, function () {\n\t        return Q(object).inspect();\n\t    });\n\t}\n\t\n\t/**\n\t * Spreads the values of a promised array of arguments into the\n\t * fulfillment callback.\n\t * @param fulfilled callback that receives variadic arguments from the\n\t * promised array\n\t * @param rejected callback that receives the exception if the promise\n\t * is rejected.\n\t * @returns a promise for the return value or thrown exception of\n\t * either callback.\n\t */\n\tQ.spread = spread;\n\tfunction spread(value, fulfilled, rejected) {\n\t    return Q(value).spread(fulfilled, rejected);\n\t}\n\t\n\tPromise.prototype.spread = function (fulfilled, rejected) {\n\t    return this.all().then(function (array) {\n\t        return fulfilled.apply(void 0, array);\n\t    }, rejected);\n\t};\n\t\n\t/**\n\t * The async function is a decorator for generator functions, turning\n\t * them into asynchronous generators.  Although generators are only part\n\t * of the newest ECMAScript 6 drafts, this code does not cause syntax\n\t * errors in older engines.  This code should continue to work and will\n\t * in fact improve over time as the language improves.\n\t *\n\t * ES6 generators are currently part of V8 version 3.19 with the\n\t * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n\t * for longer, but under an older Python-inspired form.  This function\n\t * works on both kinds of generators.\n\t *\n\t * Decorates a generator function such that:\n\t *  - it may yield promises\n\t *  - execution will continue when that promise is fulfilled\n\t *  - the value of the yield expression will be the fulfilled value\n\t *  - it returns a promise for the return value (when the generator\n\t *    stops iterating)\n\t *  - the decorated function returns a promise for the return value\n\t *    of the generator or the first rejected promise among those\n\t *    yielded.\n\t *  - if an error is thrown in the generator, it propagates through\n\t *    every following yield until it is caught, or until it escapes\n\t *    the generator function altogether, and is translated into a\n\t *    rejection for the promise returned by the decorated generator.\n\t */\n\tQ.async = async;\n\tfunction async(makeGenerator) {\n\t    return function () {\n\t        // when verb is \"send\", arg is a value\n\t        // when verb is \"throw\", arg is an exception\n\t        function continuer(verb, arg) {\n\t            var result;\n\t\n\t            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n\t            // engine that has a deployed base of browsers that support generators.\n\t            // However, SM's generators use the Python-inspired semantics of\n\t            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n\t            // like to make it possible to use generators in deployed browsers, so\n\t            // we also support Python-style generators.  At some point we can remove\n\t            // this block.\n\t\n\t            if (typeof StopIteration === \"undefined\") {\n\t                // ES6 Generators\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    return reject(exception);\n\t                }\n\t                if (result.done) {\n\t                    return Q(result.value);\n\t                } else {\n\t                    return when(result.value, callback, errback);\n\t                }\n\t            } else {\n\t                // SpiderMonkey Generators\n\t                // FIXME: Remove this case when SM does ES6 generators.\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    if (isStopIteration(exception)) {\n\t                        return Q(exception.value);\n\t                    } else {\n\t                        return reject(exception);\n\t                    }\n\t                }\n\t                return when(result, callback, errback);\n\t            }\n\t        }\n\t        var generator = makeGenerator.apply(this, arguments);\n\t        var callback = continuer.bind(continuer, \"next\");\n\t        var errback = continuer.bind(continuer, \"throw\");\n\t        return callback();\n\t    };\n\t}\n\t\n\t/**\n\t * The spawn function is a small wrapper around async that immediately\n\t * calls the generator and also ends the promise chain, so that any\n\t * unhandled errors are thrown instead of forwarded to the error\n\t * handler. This is useful because it's extremely common to run\n\t * generators at the top-level to work with libraries.\n\t */\n\tQ.spawn = spawn;\n\tfunction spawn(makeGenerator) {\n\t    Q.done(Q.async(makeGenerator)());\n\t}\n\t\n\t// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n\t/**\n\t * Throws a ReturnValue exception to stop an asynchronous generator.\n\t *\n\t * This interface is a stop-gap measure to support generator return\n\t * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n\t * generators like Chromium 29, just use \"return\" in your generator\n\t * functions.\n\t *\n\t * @param value the return value for the surrounding generator\n\t * @throws ReturnValue exception with the value.\n\t * @example\n\t * // ES6 style\n\t * Q.async(function* () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      return foo + bar;\n\t * })\n\t * // Older SpiderMonkey style\n\t * Q.async(function () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      Q.return(foo + bar);\n\t * })\n\t */\n\tQ[\"return\"] = _return;\n\tfunction _return(value) {\n\t    throw new QReturnValue(value);\n\t}\n\t\n\t/**\n\t * The promised function decorator ensures that any promise arguments\n\t * are settled and passed as values (`this` is also settled and passed\n\t * as a value).  It will also ensure that the result of a function is\n\t * always a promise.\n\t *\n\t * @example\n\t * var add = Q.promised(function (a, b) {\n\t *     return a + b;\n\t * });\n\t * add(Q(a), Q(B));\n\t *\n\t * @param {function} callback The function to decorate\n\t * @returns {function} a function that has been decorated.\n\t */\n\tQ.promised = promised;\n\tfunction promised(callback) {\n\t    return function () {\n\t        return spread([this, all(arguments)], function (self, args) {\n\t            return callback.apply(self, args);\n\t        });\n\t    };\n\t}\n\t\n\t/**\n\t * sends a message to a value in a future turn\n\t * @param object* the recipient\n\t * @param op the name of the message operation, e.g., \"when\",\n\t * @param args further arguments to be forwarded to the operation\n\t * @returns result {Promise} a promise for the result of the operation\n\t */\n\tQ.dispatch = dispatch;\n\tfunction dispatch(object, op, args) {\n\t    return Q(object).dispatch(op, args);\n\t}\n\t\n\tPromise.prototype.dispatch = function (op, args) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(deferred.resolve, op, args);\n\t    });\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Gets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to get\n\t * @return promise for the property value\n\t */\n\tQ.get = function (object, key) {\n\t    return Q(object).dispatch(\"get\", [key]);\n\t};\n\t\n\tPromise.prototype.get = function (key) {\n\t    return this.dispatch(\"get\", [key]);\n\t};\n\t\n\t/**\n\t * Sets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for object object\n\t * @param name      name of property to set\n\t * @param value     new value of property\n\t * @return promise for the return value\n\t */\n\tQ.set = function (object, key, value) {\n\t    return Q(object).dispatch(\"set\", [key, value]);\n\t};\n\t\n\tPromise.prototype.set = function (key, value) {\n\t    return this.dispatch(\"set\", [key, value]);\n\t};\n\t\n\t/**\n\t * Deletes a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to delete\n\t * @return promise for the return value\n\t */\n\tQ.del = // XXX legacy\n\tQ[\"delete\"] = function (object, key) {\n\t    return Q(object).dispatch(\"delete\", [key]);\n\t};\n\t\n\tPromise.prototype.del = // XXX legacy\n\tPromise.prototype[\"delete\"] = function (key) {\n\t    return this.dispatch(\"delete\", [key]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param value     a value to post, typically an array of\n\t *                  invocation arguments for promises that\n\t *                  are ultimately backed with `resolve` values,\n\t *                  as opposed to those backed with URLs\n\t *                  wherein the posted value can be any\n\t *                  JSON serializable object.\n\t * @return promise for the return value\n\t */\n\t// bound locally because it is used by other methods\n\tQ.mapply = // XXX As proposed by \"Redsandro\"\n\tQ.post = function (object, name, args) {\n\t    return Q(object).dispatch(\"post\", [name, args]);\n\t};\n\t\n\tPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.post = function (name, args) {\n\t    return this.dispatch(\"post\", [name, args]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param ...args   array of invocation arguments\n\t * @return promise for the return value\n\t */\n\tQ.send = // XXX Mark Miller's proposed parlance\n\tQ.mcall = // XXX As proposed by \"Redsandro\"\n\tQ.invoke = function (object, name /*...args*/) {\n\t    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n\t};\n\t\n\tPromise.prototype.send = // XXX Mark Miller's proposed parlance\n\tPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.invoke = function (name /*...args*/) {\n\t    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n\t};\n\t\n\t/**\n\t * Applies the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param args      array of application arguments\n\t */\n\tQ.fapply = function (object, args) {\n\t    return Q(object).dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\tPromise.prototype.fapply = function (args) {\n\t    return this.dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\t/**\n\t * Calls the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ[\"try\"] =\n\tQ.fcall = function (object /* ...args*/) {\n\t    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n\t};\n\t\n\tPromise.prototype.fcall = function (/*...args*/) {\n\t    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n\t};\n\t\n\t/**\n\t * Binds the promised function, transforming return values into a fulfilled\n\t * promise and thrown errors into a rejected one.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ.fbind = function (object /*...args*/) {\n\t    var promise = Q(object);\n\t    var args = array_slice(arguments, 1);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\tPromise.prototype.fbind = function (/*...args*/) {\n\t    var promise = this;\n\t    var args = array_slice(arguments);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\t\n\t/**\n\t * Requests the names of the owned properties of a promised\n\t * object in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @return promise for the keys of the eventually settled object\n\t */\n\tQ.keys = function (object) {\n\t    return Q(object).dispatch(\"keys\", []);\n\t};\n\t\n\tPromise.prototype.keys = function () {\n\t    return this.dispatch(\"keys\", []);\n\t};\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array.  If any of\n\t * the promises gets rejected, the whole array is rejected immediately.\n\t * @param {Array*} an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns a promise for an array of the corresponding values\n\t */\n\t// By Mark Miller\n\t// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n\tQ.all = all;\n\tfunction all(promises) {\n\t    return when(promises, function (promises) {\n\t        var countDown = 0;\n\t        var deferred = defer();\n\t        array_reduce(promises, function (undefined, promise, index) {\n\t            var snapshot;\n\t            if (\n\t                isPromise(promise) &&\n\t                (snapshot = promise.inspect()).state === \"fulfilled\"\n\t            ) {\n\t                promises[index] = snapshot.value;\n\t            } else {\n\t                ++countDown;\n\t                when(\n\t                    promise,\n\t                    function (value) {\n\t                        promises[index] = value;\n\t                        if (--countDown === 0) {\n\t                            deferred.resolve(promises);\n\t                        }\n\t                    },\n\t                    deferred.reject,\n\t                    function (progress) {\n\t                        deferred.notify({ index: index, value: progress });\n\t                    }\n\t                );\n\t            }\n\t        }, void 0);\n\t        if (countDown === 0) {\n\t            deferred.resolve(promises);\n\t        }\n\t        return deferred.promise;\n\t    });\n\t}\n\t\n\tPromise.prototype.all = function () {\n\t    return all(this);\n\t};\n\t\n\t/**\n\t * Waits for all promises to be settled, either fulfilled or\n\t * rejected.  This is distinct from `all` since that would stop\n\t * waiting at the first rejection.  The promise returned by\n\t * `allResolved` will never be rejected.\n\t * @param promises a promise for an array (or an array) of promises\n\t * (or values)\n\t * @return a promise for an array of promises\n\t */\n\tQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n\tfunction allResolved(promises) {\n\t    return when(promises, function (promises) {\n\t        promises = array_map(promises, Q);\n\t        return when(all(array_map(promises, function (promise) {\n\t            return when(promise, noop, noop);\n\t        })), function () {\n\t            return promises;\n\t        });\n\t    });\n\t}\n\t\n\tPromise.prototype.allResolved = function () {\n\t    return allResolved(this);\n\t};\n\t\n\t/**\n\t * @see Promise#allSettled\n\t */\n\tQ.allSettled = allSettled;\n\tfunction allSettled(promises) {\n\t    return Q(promises).allSettled();\n\t}\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array of their states (as\n\t * returned by `inspect`) when they have all settled.\n\t * @param {Array[Any*]} values an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns {Array[State]} an array of states for the respective values.\n\t */\n\tPromise.prototype.allSettled = function () {\n\t    return this.then(function (promises) {\n\t        return all(array_map(promises, function (promise) {\n\t            promise = Q(promise);\n\t            function regardless() {\n\t                return promise.inspect();\n\t            }\n\t            return promise.then(regardless, regardless);\n\t        }));\n\t    });\n\t};\n\t\n\t/**\n\t * Captures the failure of a promise, giving an oportunity to recover\n\t * with a callback.  If the given promise is fulfilled, the returned\n\t * promise is fulfilled.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to fulfill the returned promise if the\n\t * given promise is rejected\n\t * @returns a promise for the return value of the callback\n\t */\n\tQ.fail = // XXX legacy\n\tQ[\"catch\"] = function (object, rejected) {\n\t    return Q(object).then(void 0, rejected);\n\t};\n\t\n\tPromise.prototype.fail = // XXX legacy\n\tPromise.prototype[\"catch\"] = function (rejected) {\n\t    return this.then(void 0, rejected);\n\t};\n\t\n\t/**\n\t * Attaches a listener that can respond to progress notifications from a\n\t * promise's originating deferred. This listener receives the exact arguments\n\t * passed to ``deferred.notify``.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to receive any progress notifications\n\t * @returns the given promise, unchanged\n\t */\n\tQ.progress = progress;\n\tfunction progress(object, progressed) {\n\t    return Q(object).then(void 0, void 0, progressed);\n\t}\n\t\n\tPromise.prototype.progress = function (progressed) {\n\t    return this.then(void 0, void 0, progressed);\n\t};\n\t\n\t/**\n\t * Provides an opportunity to observe the settling of a promise,\n\t * regardless of whether the promise is fulfilled or rejected.  Forwards\n\t * the resolution to the returned promise when the callback is done.\n\t * The callback can return a promise to defer completion.\n\t * @param {Any*} promise\n\t * @param {Function} callback to observe the resolution of the given\n\t * promise, takes no arguments.\n\t * @returns a promise for the resolution of the given promise when\n\t * ``fin`` is done.\n\t */\n\tQ.fin = // XXX legacy\n\tQ[\"finally\"] = function (object, callback) {\n\t    return Q(object)[\"finally\"](callback);\n\t};\n\t\n\tPromise.prototype.fin = // XXX legacy\n\tPromise.prototype[\"finally\"] = function (callback) {\n\t    callback = Q(callback);\n\t    return this.then(function (value) {\n\t        return callback.fcall().then(function () {\n\t            return value;\n\t        });\n\t    }, function (reason) {\n\t        // TODO attempt to recycle the rejection with \"this\".\n\t        return callback.fcall().then(function () {\n\t            throw reason;\n\t        });\n\t    });\n\t};\n\t\n\t/**\n\t * Terminates a chain of promises, forcing rejections to be\n\t * thrown as exceptions.\n\t * @param {Any*} promise at the end of a chain of promises\n\t * @returns nothing\n\t */\n\tQ.done = function (object, fulfilled, rejected, progress) {\n\t    return Q(object).done(fulfilled, rejected, progress);\n\t};\n\t\n\tPromise.prototype.done = function (fulfilled, rejected, progress) {\n\t    var onUnhandledError = function (error) {\n\t        // forward to a future turn so that ``when``\n\t        // does not catch it and turn it into a rejection.\n\t        Q.nextTick(function () {\n\t            makeStackTraceLong(error, promise);\n\t            if (Q.onerror) {\n\t                Q.onerror(error);\n\t            } else {\n\t                throw error;\n\t            }\n\t        });\n\t    };\n\t\n\t    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n\t    var promise = fulfilled || rejected || progress ?\n\t        this.then(fulfilled, rejected, progress) :\n\t        this;\n\t\n\t    if (typeof process === \"object\" && process && process.domain) {\n\t        onUnhandledError = process.domain.bind(onUnhandledError);\n\t    }\n\t\n\t    promise.then(void 0, onUnhandledError);\n\t};\n\t\n\t/**\n\t * Causes a promise to be rejected if it does not get fulfilled before\n\t * some milliseconds time out.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds timeout\n\t * @param {Any*} custom error message or Error object (optional)\n\t * @returns a promise for the resolution of the given promise if it is\n\t * fulfilled before the timeout, otherwise rejected.\n\t */\n\tQ.timeout = function (object, ms, error) {\n\t    return Q(object).timeout(ms, error);\n\t};\n\t\n\tPromise.prototype.timeout = function (ms, error) {\n\t    var deferred = defer();\n\t    var timeoutId = setTimeout(function () {\n\t        if (!error || \"string\" === typeof error) {\n\t            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n\t            error.code = \"ETIMEDOUT\";\n\t        }\n\t        deferred.reject(error);\n\t    }, ms);\n\t\n\t    this.then(function (value) {\n\t        clearTimeout(timeoutId);\n\t        deferred.resolve(value);\n\t    }, function (exception) {\n\t        clearTimeout(timeoutId);\n\t        deferred.reject(exception);\n\t    }, deferred.notify);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Returns a promise for the given value (or promised value), some\n\t * milliseconds after it resolved. Passes rejections immediately.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds\n\t * @returns a promise for the resolution of the given promise after milliseconds\n\t * time has elapsed since the resolution of the given promise.\n\t * If the given promise rejects, that is passed immediately.\n\t */\n\tQ.delay = function (object, timeout) {\n\t    if (timeout === void 0) {\n\t        timeout = object;\n\t        object = void 0;\n\t    }\n\t    return Q(object).delay(timeout);\n\t};\n\t\n\tPromise.prototype.delay = function (timeout) {\n\t    return this.then(function (value) {\n\t        var deferred = defer();\n\t        setTimeout(function () {\n\t            deferred.resolve(value);\n\t        }, timeout);\n\t        return deferred.promise;\n\t    });\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided as an array, and returns a promise.\n\t *\n\t *      Q.nfapply(FS.readFile, [__filename])\n\t *      .then(function (content) {\n\t *      })\n\t *\n\t */\n\tQ.nfapply = function (callback, args) {\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfapply = function (args) {\n\t    var deferred = defer();\n\t    var nodeArgs = array_slice(args);\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided individually, and returns a promise.\n\t * @example\n\t * Q.nfcall(FS.readFile, __filename)\n\t * .then(function (content) {\n\t * })\n\t *\n\t */\n\tQ.nfcall = function (callback /*...args*/) {\n\t    var args = array_slice(arguments, 1);\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfcall = function (/*...args*/) {\n\t    var nodeArgs = array_slice(arguments);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Wraps a NodeJS continuation passing function and returns an equivalent\n\t * version that returns a promise.\n\t * @example\n\t * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n\t * .then(console.log)\n\t * .done()\n\t */\n\tQ.nfbind =\n\tQ.denodeify = function (callback /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 1);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nfbind =\n\tPromise.prototype.denodeify = function (/*...args*/) {\n\t    var args = array_slice(arguments);\n\t    args.unshift(this);\n\t    return Q.denodeify.apply(void 0, args);\n\t};\n\t\n\tQ.nbind = function (callback, thisp /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 2);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        function bound() {\n\t            return callback.apply(thisp, arguments);\n\t        }\n\t        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nbind = function (/*thisp, ...args*/) {\n\t    var args = array_slice(arguments, 0);\n\t    args.unshift(this);\n\t    return Q.nbind.apply(void 0, args);\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback with a given array of arguments, plus a provided callback.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param {Array} args arguments to pass to the method; the callback\n\t * will be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nmapply = // XXX As proposed by \"Redsandro\"\n\tQ.npost = function (object, name, args) {\n\t    return Q(object).npost(name, args);\n\t};\n\t\n\tPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.npost = function (name, args) {\n\t    var nodeArgs = array_slice(args || []);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback, forwarding the given variadic arguments, plus a provided\n\t * callback argument.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param ...args arguments to pass to the method; the callback will\n\t * be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tQ.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tQ.ninvoke = function (object, name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 2);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\tPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tPromise.prototype.ninvoke = function (name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 1);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * If a function would like to support both Node continuation-passing-style and\n\t * promise-returning-style, it can end its internal promise chain with\n\t * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n\t * elects to use a nodeback, the result will be sent there.  If they do not\n\t * pass a nodeback, they will receive the result promise.\n\t * @param object a result (or a promise for a result)\n\t * @param {Function} nodeback a Node.js-style callback\n\t * @returns either the promise or nothing\n\t */\n\tQ.nodeify = nodeify;\n\tfunction nodeify(object, nodeback) {\n\t    return Q(object).nodeify(nodeback);\n\t}\n\t\n\tPromise.prototype.nodeify = function (nodeback) {\n\t    if (nodeback) {\n\t        this.then(function (value) {\n\t            Q.nextTick(function () {\n\t                nodeback(null, value);\n\t            });\n\t        }, function (error) {\n\t            Q.nextTick(function () {\n\t                nodeback(error);\n\t            });\n\t        });\n\t    } else {\n\t        return this;\n\t    }\n\t};\n\t\n\t// All code before this point will be filtered from stack traces.\n\tvar qEndingLine = captureLine();\n\t\n\treturn Q;\n\t\n\t});\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*! Socket.IO.js build:0.9.17, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\n\t\n\tvar io = (false ? {} : module.exports);\n\t(function() {\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, global) {\n\t\n\t  /**\n\t   * IO namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  var io = exports;\n\t\n\t  /**\n\t   * Socket.IO version\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  io.version = '0.9.17';\n\t\n\t  /**\n\t   * Protocol implemented.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  io.protocol = 1;\n\t\n\t  /**\n\t   * Available transports, these will be populated with the available transports\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  io.transports = [];\n\t\n\t  /**\n\t   * Keep track of jsonp callbacks.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.j = [];\n\t\n\t  /**\n\t   * Keep track of our io.Sockets\n\t   *\n\t   * @api private\n\t   */\n\t  io.sockets = {};\n\t\n\t\n\t  /**\n\t   * Manages connections to hosts.\n\t   *\n\t   * @param {String} uri\n\t   * @Param {Boolean} force creation of new socket (defaults to false)\n\t   * @api public\n\t   */\n\t\n\t  io.connect = function (host, details) {\n\t    var uri = io.util.parseUri(host)\n\t      , uuri\n\t      , socket;\n\t\n\t    if (global && global.location) {\n\t      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\n\t      uri.host = uri.host || (global.document\n\t        ? global.document.domain : global.location.hostname);\n\t      uri.port = uri.port || global.location.port;\n\t    }\n\t\n\t    uuri = io.util.uniqueUri(uri);\n\t\n\t    var options = {\n\t        host: uri.host\n\t      , secure: 'https' == uri.protocol\n\t      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\n\t      , query: uri.query || ''\n\t    };\n\t\n\t    io.util.merge(options, details);\n\t\n\t    if (options['force new connection'] || !io.sockets[uuri]) {\n\t      socket = new io.Socket(options);\n\t    }\n\t\n\t    if (!options['force new connection'] && socket) {\n\t      io.sockets[uuri] = socket;\n\t    }\n\t\n\t    socket = socket || io.sockets[uuri];\n\t\n\t    // if path is different from '' or /\n\t    return socket.of(uri.path.length > 1 ? uri.path : '');\n\t  };\n\t\n\t})(true ? module.exports : (this.io = {}), this);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, global) {\n\t\n\t  /**\n\t   * Utilities namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  var util = exports.util = {};\n\t\n\t  /**\n\t   * Parses an URI\n\t   *\n\t   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n\t   * @api public\n\t   */\n\t\n\t  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\t  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\n\t               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\n\t               'anchor'];\n\t\n\t  util.parseUri = function (str) {\n\t    var m = re.exec(str || '')\n\t      , uri = {}\n\t      , i = 14;\n\t\n\t    while (i--) {\n\t      uri[parts[i]] = m[i] || '';\n\t    }\n\t\n\t    return uri;\n\t  };\n\t\n\t  /**\n\t   * Produces a unique url that identifies a Socket.IO connection.\n\t   *\n\t   * @param {Object} uri\n\t   * @api public\n\t   */\n\t\n\t  util.uniqueUri = function (uri) {\n\t    var protocol = uri.protocol\n\t      , host = uri.host\n\t      , port = uri.port;\n\t\n\t    if ('document' in global) {\n\t      host = host || document.domain;\n\t      port = port || (protocol == 'https'\n\t        && document.location.protocol !== 'https:' ? 443 : document.location.port);\n\t    } else {\n\t      host = host || 'localhost';\n\t\n\t      if (!port && protocol == 'https') {\n\t        port = 443;\n\t      }\n\t    }\n\t\n\t    return (protocol || 'http') + '://' + host + ':' + (port || 80);\n\t  };\n\t\n\t  /**\n\t   * Mergest 2 query strings in to once unique query string\n\t   *\n\t   * @param {String} base\n\t   * @param {String} addition\n\t   * @api public\n\t   */\n\t\n\t  util.query = function (base, addition) {\n\t    var query = util.chunkQuery(base || '')\n\t      , components = [];\n\t\n\t    util.merge(query, util.chunkQuery(addition || ''));\n\t    for (var part in query) {\n\t      if (query.hasOwnProperty(part)) {\n\t        components.push(part + '=' + query[part]);\n\t      }\n\t    }\n\t\n\t    return components.length ? '?' + components.join('&') : '';\n\t  };\n\t\n\t  /**\n\t   * Transforms a querystring in to an object\n\t   *\n\t   * @param {String} qs\n\t   * @api public\n\t   */\n\t\n\t  util.chunkQuery = function (qs) {\n\t    var query = {}\n\t      , params = qs.split('&')\n\t      , i = 0\n\t      , l = params.length\n\t      , kv;\n\t\n\t    for (; i < l; ++i) {\n\t      kv = params[i].split('=');\n\t      if (kv[0]) {\n\t        query[kv[0]] = kv[1];\n\t      }\n\t    }\n\t\n\t    return query;\n\t  };\n\t\n\t  /**\n\t   * Executes the given function when the page is loaded.\n\t   *\n\t   *     io.util.load(function () { console.log('page loaded'); });\n\t   *\n\t   * @param {Function} fn\n\t   * @api public\n\t   */\n\t\n\t  var pageLoaded = false;\n\t\n\t  util.load = function (fn) {\n\t    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\n\t      return fn();\n\t    }\n\t\n\t    util.on(global, 'load', fn, false);\n\t  };\n\t\n\t  /**\n\t   * Adds an event.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  util.on = function (element, event, fn, capture) {\n\t    if (element.attachEvent) {\n\t      element.attachEvent('on' + event, fn);\n\t    } else if (element.addEventListener) {\n\t      element.addEventListener(event, fn, capture);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\n\t   *\n\t   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\n\t   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\n\t   * @api private\n\t   */\n\t\n\t  util.request = function (xdomain) {\n\t\n\t    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {\n\t      return new XDomainRequest();\n\t    }\n\t\n\t    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\n\t      return new XMLHttpRequest();\n\t    }\n\t\n\t    if (!xdomain) {\n\t      try {\n\t        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');\n\t      } catch(e) { }\n\t    }\n\t\n\t    return null;\n\t  };\n\t\n\t  /**\n\t   * XHR based transport constructor.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  /**\n\t   * Change the internal pageLoaded value.\n\t   */\n\t\n\t  if ('undefined' != typeof window) {\n\t    util.load(function () {\n\t      pageLoaded = true;\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Defers a function to ensure a spinner is not displayed by the browser\n\t   *\n\t   * @param {Function} fn\n\t   * @api public\n\t   */\n\t\n\t  util.defer = function (fn) {\n\t    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\n\t      return fn();\n\t    }\n\t\n\t    util.load(function () {\n\t      setTimeout(fn, 100);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Merges two objects.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.merge = function merge (target, additional, deep, lastseen) {\n\t    var seen = lastseen || []\n\t      , depth = typeof deep == 'undefined' ? 2 : deep\n\t      , prop;\n\t\n\t    for (prop in additional) {\n\t      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\n\t        if (typeof target[prop] !== 'object' || !depth) {\n\t          target[prop] = additional[prop];\n\t          seen.push(additional[prop]);\n\t        } else {\n\t          util.merge(target[prop], additional[prop], depth - 1, seen);\n\t        }\n\t      }\n\t    }\n\t\n\t    return target;\n\t  };\n\t\n\t  /**\n\t   * Merges prototypes from objects\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.mixin = function (ctor, ctor2) {\n\t    util.merge(ctor.prototype, ctor2.prototype);\n\t  };\n\t\n\t  /**\n\t   * Shortcut for prototypical and static inheritance.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  util.inherit = function (ctor, ctor2) {\n\t    function f() {};\n\t    f.prototype = ctor2.prototype;\n\t    ctor.prototype = new f;\n\t  };\n\t\n\t  /**\n\t   * Checks if the given object is an Array.\n\t   *\n\t   *     io.util.isArray([]); // true\n\t   *     io.util.isArray({}); // false\n\t   *\n\t   * @param Object obj\n\t   * @api public\n\t   */\n\t\n\t  util.isArray = Array.isArray || function (obj) {\n\t    return Object.prototype.toString.call(obj) === '[object Array]';\n\t  };\n\t\n\t  /**\n\t   * Intersects values of two arrays into a third\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.intersect = function (arr, arr2) {\n\t    var ret = []\n\t      , longest = arr.length > arr2.length ? arr : arr2\n\t      , shortest = arr.length > arr2.length ? arr2 : arr;\n\t\n\t    for (var i = 0, l = shortest.length; i < l; i++) {\n\t      if (~util.indexOf(longest, shortest[i]))\n\t        ret.push(shortest[i]);\n\t    }\n\t\n\t    return ret;\n\t  };\n\t\n\t  /**\n\t   * Array indexOf compatibility.\n\t   *\n\t   * @see bit.ly/a5Dxa2\n\t   * @api public\n\t   */\n\t\n\t  util.indexOf = function (arr, o, i) {\n\t\n\t    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;\n\t         i < j && arr[i] !== o; i++) {}\n\t\n\t    return j <= i ? -1 : i;\n\t  };\n\t\n\t  /**\n\t   * Converts enumerables to array.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.toArray = function (enu) {\n\t    var arr = [];\n\t\n\t    for (var i = 0, l = enu.length; i < l; i++)\n\t      arr.push(enu[i]);\n\t\n\t    return arr;\n\t  };\n\t\n\t  /**\n\t   * UA / engines detection namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  util.ua = {};\n\t\n\t  /**\n\t   * Whether the UA supports CORS for XHR.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\n\t    try {\n\t      var a = new XMLHttpRequest();\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t\n\t    return a.withCredentials != undefined;\n\t  })();\n\t\n\t  /**\n\t   * Detect webkit.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.ua.webkit = 'undefined' != typeof navigator\n\t    && /webkit/i.test(navigator.userAgent);\n\t\n\t   /**\n\t   * Detect iPad/iPhone/iPod.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.ua.iDevice = 'undefined' != typeof navigator\n\t      && /iPad|iPhone|iPod/i.test(navigator.userAgent);\n\t\n\t})('undefined' != typeof io ? io : module.exports, this);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.EventEmitter = EventEmitter;\n\t\n\t  /**\n\t   * Event emitter constructor.\n\t   *\n\t   * @api public.\n\t   */\n\t\n\t  function EventEmitter () {};\n\t\n\t  /**\n\t   * Adds a listener\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.on = function (name, fn) {\n\t    if (!this.$events) {\n\t      this.$events = {};\n\t    }\n\t\n\t    if (!this.$events[name]) {\n\t      this.$events[name] = fn;\n\t    } else if (io.util.isArray(this.$events[name])) {\n\t      this.$events[name].push(fn);\n\t    } else {\n\t      this.$events[name] = [this.$events[name], fn];\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t  /**\n\t   * Adds a volatile listener.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.once = function (name, fn) {\n\t    var self = this;\n\t\n\t    function on () {\n\t      self.removeListener(name, on);\n\t      fn.apply(this, arguments);\n\t    };\n\t\n\t    on.listener = fn;\n\t    this.on(name, on);\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Removes a listener.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.removeListener = function (name, fn) {\n\t    if (this.$events && this.$events[name]) {\n\t      var list = this.$events[name];\n\t\n\t      if (io.util.isArray(list)) {\n\t        var pos = -1;\n\t\n\t        for (var i = 0, l = list.length; i < l; i++) {\n\t          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n\t            pos = i;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (pos < 0) {\n\t          return this;\n\t        }\n\t\n\t        list.splice(pos, 1);\n\t\n\t        if (!list.length) {\n\t          delete this.$events[name];\n\t        }\n\t      } else if (list === fn || (list.listener && list.listener === fn)) {\n\t        delete this.$events[name];\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Removes all listeners for an event.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.removeAllListeners = function (name) {\n\t    if (name === undefined) {\n\t      this.$events = {};\n\t      return this;\n\t    }\n\t\n\t    if (this.$events && this.$events[name]) {\n\t      this.$events[name] = null;\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Gets all listeners for a certain event.\n\t   *\n\t   * @api publci\n\t   */\n\t\n\t  EventEmitter.prototype.listeners = function (name) {\n\t    if (!this.$events) {\n\t      this.$events = {};\n\t    }\n\t\n\t    if (!this.$events[name]) {\n\t      this.$events[name] = [];\n\t    }\n\t\n\t    if (!io.util.isArray(this.$events[name])) {\n\t      this.$events[name] = [this.$events[name]];\n\t    }\n\t\n\t    return this.$events[name];\n\t  };\n\t\n\t  /**\n\t   * Emits an event.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.emit = function (name) {\n\t    if (!this.$events) {\n\t      return false;\n\t    }\n\t\n\t    var handler = this.$events[name];\n\t\n\t    if (!handler) {\n\t      return false;\n\t    }\n\t\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t\n\t    if ('function' == typeof handler) {\n\t      handler.apply(this, args);\n\t    } else if (io.util.isArray(handler)) {\n\t      var listeners = handler.slice();\n\t\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\n\t        listeners[i].apply(this, args);\n\t      }\n\t    } else {\n\t      return false;\n\t    }\n\t\n\t    return true;\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * Based on JSON2 (http://www.JSON.org/js.html).\n\t */\n\t\n\t(function (exports, nativeJSON) {\n\t  \"use strict\";\n\t\n\t  // use native JSON if it's available\n\t  if (nativeJSON && nativeJSON.parse){\n\t    return exports.JSON = {\n\t      parse: nativeJSON.parse\n\t    , stringify: nativeJSON.stringify\n\t    };\n\t  }\n\t\n\t  var JSON = exports.JSON = {};\n\t\n\t  function f(n) {\n\t      // Format integers to have at least two digits.\n\t      return n < 10 ? '0' + n : n;\n\t  }\n\t\n\t  function date(d, key) {\n\t    return isFinite(d.valueOf()) ?\n\t        d.getUTCFullYear()     + '-' +\n\t        f(d.getUTCMonth() + 1) + '-' +\n\t        f(d.getUTCDate())      + 'T' +\n\t        f(d.getUTCHours())     + ':' +\n\t        f(d.getUTCMinutes())   + ':' +\n\t        f(d.getUTCSeconds())   + 'Z' : null;\n\t  };\n\t\n\t  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t      gap,\n\t      indent,\n\t      meta = {    // table of character substitutions\n\t          '\\b': '\\\\b',\n\t          '\\t': '\\\\t',\n\t          '\\n': '\\\\n',\n\t          '\\f': '\\\\f',\n\t          '\\r': '\\\\r',\n\t          '\"' : '\\\\\"',\n\t          '\\\\': '\\\\\\\\'\n\t      },\n\t      rep;\n\t\n\t\n\t  function quote(string) {\n\t\n\t// If the string contains no control characters, no quote characters, and no\n\t// backslash characters, then we can safely slap some quotes around it.\n\t// Otherwise we must also replace the offending characters with safe escape\n\t// sequences.\n\t\n\t      escapable.lastIndex = 0;\n\t      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n\t          var c = meta[a];\n\t          return typeof c === 'string' ? c :\n\t              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t      }) + '\"' : '\"' + string + '\"';\n\t  }\n\t\n\t\n\t  function str(key, holder) {\n\t\n\t// Produce a string from holder[key].\n\t\n\t      var i,          // The loop counter.\n\t          k,          // The member key.\n\t          v,          // The member value.\n\t          length,\n\t          mind = gap,\n\t          partial,\n\t          value = holder[key];\n\t\n\t// If the value has a toJSON method, call it to obtain a replacement value.\n\t\n\t      if (value instanceof Date) {\n\t          value = date(key);\n\t      }\n\t\n\t// If we were called with a replacer function, then call the replacer to\n\t// obtain a replacement value.\n\t\n\t      if (typeof rep === 'function') {\n\t          value = rep.call(holder, key, value);\n\t      }\n\t\n\t// What happens next depends on the value's type.\n\t\n\t      switch (typeof value) {\n\t      case 'string':\n\t          return quote(value);\n\t\n\t      case 'number':\n\t\n\t// JSON numbers must be finite. Encode non-finite numbers as null.\n\t\n\t          return isFinite(value) ? String(value) : 'null';\n\t\n\t      case 'boolean':\n\t      case 'null':\n\t\n\t// If the value is a boolean or null, convert it to a string. Note:\n\t// typeof null does not produce 'null'. The case is included here in\n\t// the remote chance that this gets fixed someday.\n\t\n\t          return String(value);\n\t\n\t// If the type is 'object', we might be dealing with an object or an array or\n\t// null.\n\t\n\t      case 'object':\n\t\n\t// Due to a specification blunder in ECMAScript, typeof null is 'object',\n\t// so watch out for that case.\n\t\n\t          if (!value) {\n\t              return 'null';\n\t          }\n\t\n\t// Make an array to hold the partial results of stringifying this object value.\n\t\n\t          gap += indent;\n\t          partial = [];\n\t\n\t// Is the value an array?\n\t\n\t          if (Object.prototype.toString.apply(value) === '[object Array]') {\n\t\n\t// The value is an array. Stringify every element. Use null as a placeholder\n\t// for non-JSON values.\n\t\n\t              length = value.length;\n\t              for (i = 0; i < length; i += 1) {\n\t                  partial[i] = str(i, value) || 'null';\n\t              }\n\t\n\t// Join all of the elements together, separated with commas, and wrap them in\n\t// brackets.\n\t\n\t              v = partial.length === 0 ? '[]' : gap ?\n\t                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n\t                  '[' + partial.join(',') + ']';\n\t              gap = mind;\n\t              return v;\n\t          }\n\t\n\t// If the replacer is an array, use it to select the members to be stringified.\n\t\n\t          if (rep && typeof rep === 'object') {\n\t              length = rep.length;\n\t              for (i = 0; i < length; i += 1) {\n\t                  if (typeof rep[i] === 'string') {\n\t                      k = rep[i];\n\t                      v = str(k, value);\n\t                      if (v) {\n\t                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                      }\n\t                  }\n\t              }\n\t          } else {\n\t\n\t// Otherwise, iterate through all of the keys in the object.\n\t\n\t              for (k in value) {\n\t                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n\t                      v = str(k, value);\n\t                      if (v) {\n\t                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                      }\n\t                  }\n\t              }\n\t          }\n\t\n\t// Join all of the member texts together, separated with commas,\n\t// and wrap them in braces.\n\t\n\t          v = partial.length === 0 ? '{}' : gap ?\n\t              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n\t              '{' + partial.join(',') + '}';\n\t          gap = mind;\n\t          return v;\n\t      }\n\t  }\n\t\n\t// If the JSON object does not yet have a stringify method, give it one.\n\t\n\t  JSON.stringify = function (value, replacer, space) {\n\t\n\t// The stringify method takes a value and an optional replacer, and an optional\n\t// space parameter, and returns a JSON text. The replacer can be a function\n\t// that can replace values, or an array of strings that will select the keys.\n\t// A default replacer method can be provided. Use of the space parameter can\n\t// produce text that is more easily readable.\n\t\n\t      var i;\n\t      gap = '';\n\t      indent = '';\n\t\n\t// If the space parameter is a number, make an indent string containing that\n\t// many spaces.\n\t\n\t      if (typeof space === 'number') {\n\t          for (i = 0; i < space; i += 1) {\n\t              indent += ' ';\n\t          }\n\t\n\t// If the space parameter is a string, it will be used as the indent string.\n\t\n\t      } else if (typeof space === 'string') {\n\t          indent = space;\n\t      }\n\t\n\t// If there is a replacer, it must be a function or an array.\n\t// Otherwise, throw an error.\n\t\n\t      rep = replacer;\n\t      if (replacer && typeof replacer !== 'function' &&\n\t              (typeof replacer !== 'object' ||\n\t              typeof replacer.length !== 'number')) {\n\t          throw new Error('JSON.stringify');\n\t      }\n\t\n\t// Make a fake root object containing our value under the key of ''.\n\t// Return the result of stringifying the value.\n\t\n\t      return str('', {'': value});\n\t  };\n\t\n\t// If the JSON object does not yet have a parse method, give it one.\n\t\n\t  JSON.parse = function (text, reviver) {\n\t  // The parse method takes a text and an optional reviver function, and returns\n\t  // a JavaScript value if the text is a valid JSON text.\n\t\n\t      var j;\n\t\n\t      function walk(holder, key) {\n\t\n\t  // The walk method is used to recursively walk the resulting structure so\n\t  // that modifications can be made.\n\t\n\t          var k, v, value = holder[key];\n\t          if (value && typeof value === 'object') {\n\t              for (k in value) {\n\t                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n\t                      v = walk(value, k);\n\t                      if (v !== undefined) {\n\t                          value[k] = v;\n\t                      } else {\n\t                          delete value[k];\n\t                      }\n\t                  }\n\t              }\n\t          }\n\t          return reviver.call(holder, key, value);\n\t      }\n\t\n\t\n\t  // Parsing happens in four stages. In the first stage, we replace certain\n\t  // Unicode characters with escape sequences. JavaScript handles many characters\n\t  // incorrectly, either silently deleting them, or treating them as line endings.\n\t\n\t      text = String(text);\n\t      cx.lastIndex = 0;\n\t      if (cx.test(text)) {\n\t          text = text.replace(cx, function (a) {\n\t              return '\\\\u' +\n\t                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t          });\n\t      }\n\t\n\t  // In the second stage, we run the text against regular expressions that look\n\t  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n\t  // because they can cause invocation, and '=' because it can cause mutation.\n\t  // But just to be safe, we want to reject all unexpected forms.\n\t\n\t  // We split the second stage into 4 regexp operations in order to work around\n\t  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n\t  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n\t  // replace all simple value tokens with ']' characters. Third, we delete all\n\t  // open brackets that follow a colon or comma or that begin the text. Finally,\n\t  // we look to see that the remaining characters are only whitespace or ']' or\n\t  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\t\n\t      if (/^[\\],:{}\\s]*$/\n\t              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n\t                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n\t                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\t\n\t  // In the third stage we use the eval function to compile the text into a\n\t  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n\t  // in JavaScript: it can begin a block or an object literal. We wrap the text\n\t  // in parens to eliminate the ambiguity.\n\t\n\t          j = eval('(' + text + ')');\n\t\n\t  // In the optional fourth stage, we recursively walk the new structure, passing\n\t  // each name/value pair to a reviver function for possible transformation.\n\t\n\t          return typeof reviver === 'function' ?\n\t              walk({'': j}, '') : j;\n\t      }\n\t\n\t  // If the text is not JSON parseable, then a SyntaxError is thrown.\n\t\n\t      throw new SyntaxError('JSON.parse');\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , typeof JSON !== 'undefined' ? JSON : undefined\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Parser namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  var parser = exports.parser = {};\n\t\n\t  /**\n\t   * Packet types.\n\t   */\n\t\n\t  var packets = parser.packets = [\n\t      'disconnect'\n\t    , 'connect'\n\t    , 'heartbeat'\n\t    , 'message'\n\t    , 'json'\n\t    , 'event'\n\t    , 'ack'\n\t    , 'error'\n\t    , 'noop'\n\t  ];\n\t\n\t  /**\n\t   * Errors reasons.\n\t   */\n\t\n\t  var reasons = parser.reasons = [\n\t      'transport not supported'\n\t    , 'client not handshaken'\n\t    , 'unauthorized'\n\t  ];\n\t\n\t  /**\n\t   * Errors advice.\n\t   */\n\t\n\t  var advice = parser.advice = [\n\t      'reconnect'\n\t  ];\n\t\n\t  /**\n\t   * Shortcuts.\n\t   */\n\t\n\t  var JSON = io.JSON\n\t    , indexOf = io.util.indexOf;\n\t\n\t  /**\n\t   * Encodes a packet.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  parser.encodePacket = function (packet) {\n\t    var type = indexOf(packets, packet.type)\n\t      , id = packet.id || ''\n\t      , endpoint = packet.endpoint || ''\n\t      , ack = packet.ack\n\t      , data = null;\n\t\n\t    switch (packet.type) {\n\t      case 'error':\n\t        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\n\t          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\n\t\n\t        if (reason !== '' || adv !== '')\n\t          data = reason + (adv !== '' ? ('+' + adv) : '');\n\t\n\t        break;\n\t\n\t      case 'message':\n\t        if (packet.data !== '')\n\t          data = packet.data;\n\t        break;\n\t\n\t      case 'event':\n\t        var ev = { name: packet.name };\n\t\n\t        if (packet.args && packet.args.length) {\n\t          ev.args = packet.args;\n\t        }\n\t\n\t        data = JSON.stringify(ev);\n\t        break;\n\t\n\t      case 'json':\n\t        data = JSON.stringify(packet.data);\n\t        break;\n\t\n\t      case 'connect':\n\t        if (packet.qs)\n\t          data = packet.qs;\n\t        break;\n\t\n\t      case 'ack':\n\t        data = packet.ackId\n\t          + (packet.args && packet.args.length\n\t              ? '+' + JSON.stringify(packet.args) : '');\n\t        break;\n\t    }\n\t\n\t    // construct packet with required fragments\n\t    var encoded = [\n\t        type\n\t      , id + (ack == 'data' ? '+' : '')\n\t      , endpoint\n\t    ];\n\t\n\t    // data fragment is optional\n\t    if (data !== null && data !== undefined)\n\t      encoded.push(data);\n\t\n\t    return encoded.join(':');\n\t  };\n\t\n\t  /**\n\t   * Encodes multiple messages (payload).\n\t   *\n\t   * @param {Array} messages\n\t   * @api private\n\t   */\n\t\n\t  parser.encodePayload = function (packets) {\n\t    var decoded = '';\n\t\n\t    if (packets.length == 1)\n\t      return packets[0];\n\t\n\t    for (var i = 0, l = packets.length; i < l; i++) {\n\t      var packet = packets[i];\n\t      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\n\t    }\n\t\n\t    return decoded;\n\t  };\n\t\n\t  /**\n\t   * Decodes a packet\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\n\t\n\t  parser.decodePacket = function (data) {\n\t    var pieces = data.match(regexp);\n\t\n\t    if (!pieces) return {};\n\t\n\t    var id = pieces[2] || ''\n\t      , data = pieces[5] || ''\n\t      , packet = {\n\t            type: packets[pieces[1]]\n\t          , endpoint: pieces[4] || ''\n\t        };\n\t\n\t    // whether we need to acknowledge the packet\n\t    if (id) {\n\t      packet.id = id;\n\t      if (pieces[3])\n\t        packet.ack = 'data';\n\t      else\n\t        packet.ack = true;\n\t    }\n\t\n\t    // handle different packet types\n\t    switch (packet.type) {\n\t      case 'error':\n\t        var pieces = data.split('+');\n\t        packet.reason = reasons[pieces[0]] || '';\n\t        packet.advice = advice[pieces[1]] || '';\n\t        break;\n\t\n\t      case 'message':\n\t        packet.data = data || '';\n\t        break;\n\t\n\t      case 'event':\n\t        try {\n\t          var opts = JSON.parse(data);\n\t          packet.name = opts.name;\n\t          packet.args = opts.args;\n\t        } catch (e) { }\n\t\n\t        packet.args = packet.args || [];\n\t        break;\n\t\n\t      case 'json':\n\t        try {\n\t          packet.data = JSON.parse(data);\n\t        } catch (e) { }\n\t        break;\n\t\n\t      case 'connect':\n\t        packet.qs = data || '';\n\t        break;\n\t\n\t      case 'ack':\n\t        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\n\t        if (pieces) {\n\t          packet.ackId = pieces[1];\n\t          packet.args = [];\n\t\n\t          if (pieces[3]) {\n\t            try {\n\t              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\n\t            } catch (e) { }\n\t          }\n\t        }\n\t        break;\n\t\n\t      case 'disconnect':\n\t      case 'heartbeat':\n\t        break;\n\t    };\n\t\n\t    return packet;\n\t  };\n\t\n\t  /**\n\t   * Decodes data payload. Detects multiple messages\n\t   *\n\t   * @return {Array} messages\n\t   * @api public\n\t   */\n\t\n\t  parser.decodePayload = function (data) {\n\t    // IE doesn't like data[i] for unicode chars, charAt works fine\n\t    if (data.charAt(0) == '\\ufffd') {\n\t      var ret = [];\n\t\n\t      for (var i = 1, length = ''; i < data.length; i++) {\n\t        if (data.charAt(i) == '\\ufffd') {\n\t          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\n\t          i += Number(length) + 1;\n\t          length = '';\n\t        } else {\n\t          length += data.charAt(i);\n\t        }\n\t      }\n\t\n\t      return ret;\n\t    } else {\n\t      return [parser.decodePacket(data)];\n\t    }\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.Transport = Transport;\n\t\n\t  /**\n\t   * This is the transport template for all supported transport methods.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  function Transport (socket, sessid) {\n\t    this.socket = socket;\n\t    this.sessid = sessid;\n\t  };\n\t\n\t  /**\n\t   * Apply EventEmitter mixin.\n\t   */\n\t\n\t  io.util.mixin(Transport, io.EventEmitter);\n\t\n\t\n\t  /**\n\t   * Indicates whether heartbeats is enabled for this transport\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.heartbeats = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Handles the response from the server. When a new response is received\n\t   * it will automatically update the timeout, decode the message and\n\t   * forwards the response to the onMessage function for further processing.\n\t   *\n\t   * @param {String} data Response from the server.\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onData = function (data) {\n\t    this.clearCloseTimeout();\n\t\n\t    // If the connection in currently open (or in a reopening state) reset the close\n\t    // timeout since we have just received data. This check is necessary so\n\t    // that we don't reset the timeout on an explicitly disconnected connection.\n\t    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\n\t      this.setCloseTimeout();\n\t    }\n\t\n\t    if (data !== '') {\n\t      // todo: we should only do decodePayload for xhr transports\n\t      var msgs = io.parser.decodePayload(data);\n\t\n\t      if (msgs && msgs.length) {\n\t        for (var i = 0, l = msgs.length; i < l; i++) {\n\t          this.onPacket(msgs[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Handles packets.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onPacket = function (packet) {\n\t    this.socket.setHeartbeatTimeout();\n\t\n\t    if (packet.type == 'heartbeat') {\n\t      return this.onHeartbeat();\n\t    }\n\t\n\t    if (packet.type == 'connect' && packet.endpoint == '') {\n\t      this.onConnect();\n\t    }\n\t\n\t    if (packet.type == 'error' && packet.advice == 'reconnect') {\n\t      this.isOpen = false;\n\t    }\n\t\n\t    this.socket.onPacket(packet);\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Sets close timeout\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.setCloseTimeout = function () {\n\t    if (!this.closeTimeout) {\n\t      var self = this;\n\t\n\t      this.closeTimeout = setTimeout(function () {\n\t        self.onDisconnect();\n\t      }, this.socket.closeTimeout);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Called when transport disconnects.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onDisconnect = function () {\n\t    if (this.isOpen) this.close();\n\t    this.clearTimeouts();\n\t    this.socket.onDisconnect();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Called when transport connects\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onConnect = function () {\n\t    this.socket.onConnect();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Clears close timeout\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.clearCloseTimeout = function () {\n\t    if (this.closeTimeout) {\n\t      clearTimeout(this.closeTimeout);\n\t      this.closeTimeout = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Clear timeouts\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.clearTimeouts = function () {\n\t    this.clearCloseTimeout();\n\t\n\t    if (this.reopenTimeout) {\n\t      clearTimeout(this.reopenTimeout);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Sends a packet\n\t   *\n\t   * @param {Object} packet object.\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.packet = function (packet) {\n\t    this.send(io.parser.encodePacket(packet));\n\t  };\n\t\n\t  /**\n\t   * Send the received heartbeat message back to server. So the server\n\t   * knows we are still connected.\n\t   *\n\t   * @param {String} heartbeat Heartbeat response from the server.\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onHeartbeat = function (heartbeat) {\n\t    this.packet({ type: 'heartbeat' });\n\t  };\n\t\n\t  /**\n\t   * Called when the transport opens.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onOpen = function () {\n\t    this.isOpen = true;\n\t    this.clearCloseTimeout();\n\t    this.socket.onOpen();\n\t  };\n\t\n\t  /**\n\t   * Notifies the base when the connection with the Socket.IO server\n\t   * has been disconnected.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onClose = function () {\n\t    var self = this;\n\t\n\t    /* FIXME: reopen delay causing a infinit loop\n\t    this.reopenTimeout = setTimeout(function () {\n\t      self.open();\n\t    }, this.socket.options['reopen delay']);*/\n\t\n\t    this.isOpen = false;\n\t    this.socket.onClose();\n\t    this.onDisconnect();\n\t  };\n\t\n\t  /**\n\t   * Generates a connection url based on the Socket.IO URL Protocol.\n\t   * See <https://github.com/learnboost/socket.io-node/> for more details.\n\t   *\n\t   * @returns {String} Connection url\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.prepareUrl = function () {\n\t    var options = this.socket.options;\n\t\n\t    return this.scheme() + '://'\n\t      + options.host + ':' + options.port + '/'\n\t      + options.resource + '/' + io.protocol\n\t      + '/' + this.name + '/' + this.sessid;\n\t  };\n\t\n\t  /**\n\t   * Checks if the transport is ready to start a connection.\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.ready = function (socket, fn) {\n\t    fn.call(this);\n\t  };\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.Socket = Socket;\n\t\n\t  /**\n\t   * Create a new `Socket.IO client` which can establish a persistent\n\t   * connection with a Socket.IO enabled server.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  function Socket (options) {\n\t    this.options = {\n\t        port: 80\n\t      , secure: false\n\t      , document: 'document' in global ? document : false\n\t      , resource: 'socket.io'\n\t      , transports: io.transports\n\t      , 'connect timeout': 10000\n\t      , 'try multiple transports': true\n\t      , 'reconnect': true\n\t      , 'reconnection delay': 500\n\t      , 'reconnection limit': Infinity\n\t      , 'reopen delay': 3000\n\t      , 'max reconnection attempts': 10\n\t      , 'sync disconnect on unload': false\n\t      , 'auto connect': true\n\t      , 'flash policy port': 10843\n\t      , 'manualFlush': false\n\t    };\n\t\n\t    io.util.merge(this.options, options);\n\t\n\t    this.connected = false;\n\t    this.open = false;\n\t    this.connecting = false;\n\t    this.reconnecting = false;\n\t    this.namespaces = {};\n\t    this.buffer = [];\n\t    this.doBuffer = false;\n\t\n\t    if (this.options['sync disconnect on unload'] &&\n\t        (!this.isXDomain() || io.util.ua.hasCORS)) {\n\t      var self = this;\n\t      io.util.on(global, 'beforeunload', function () {\n\t        self.disconnectSync();\n\t      }, false);\n\t    }\n\t\n\t    if (this.options['auto connect']) {\n\t      this.connect();\n\t    }\n\t};\n\t\n\t  /**\n\t   * Apply EventEmitter mixin.\n\t   */\n\t\n\t  io.util.mixin(Socket, io.EventEmitter);\n\t\n\t  /**\n\t   * Returns a namespace listener/emitter for this socket\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.of = function (name) {\n\t    if (!this.namespaces[name]) {\n\t      this.namespaces[name] = new io.SocketNamespace(this, name);\n\t\n\t      if (name !== '') {\n\t        this.namespaces[name].packet({ type: 'connect' });\n\t      }\n\t    }\n\t\n\t    return this.namespaces[name];\n\t  };\n\t\n\t  /**\n\t   * Emits the given event to the Socket and all namespaces\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.publish = function () {\n\t    this.emit.apply(this, arguments);\n\t\n\t    var nsp;\n\t\n\t    for (var i in this.namespaces) {\n\t      if (this.namespaces.hasOwnProperty(i)) {\n\t        nsp = this.of(i);\n\t        nsp.$emit.apply(nsp, arguments);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Performs the handshake\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  function empty () { };\n\t\n\t  Socket.prototype.handshake = function (fn) {\n\t    var self = this\n\t      , options = this.options;\n\t\n\t    function complete (data) {\n\t      if (data instanceof Error) {\n\t        self.connecting = false;\n\t        self.onError(data.message);\n\t      } else {\n\t        fn.apply(null, data.split(':'));\n\t      }\n\t    };\n\t\n\t    var url = [\n\t          'http' + (options.secure ? 's' : '') + ':/'\n\t        , options.host + ':' + options.port\n\t        , options.resource\n\t        , io.protocol\n\t        , io.util.query(this.options.query, 't=' + +new Date)\n\t      ].join('/');\n\t\n\t    if (this.isXDomain() && !io.util.ua.hasCORS) {\n\t      var insertAt = document.getElementsByTagName('script')[0]\n\t        , script = document.createElement('script');\n\t\n\t      script.src = url + '&jsonp=' + io.j.length;\n\t      insertAt.parentNode.insertBefore(script, insertAt);\n\t\n\t      io.j.push(function (data) {\n\t        complete(data);\n\t        script.parentNode.removeChild(script);\n\t      });\n\t    } else {\n\t      var xhr = io.util.request();\n\t\n\t      xhr.open('GET', url, true);\n\t      if (this.isXDomain()) {\n\t        xhr.withCredentials = true;\n\t      }\n\t      xhr.onreadystatechange = function () {\n\t        if (xhr.readyState == 4) {\n\t          xhr.onreadystatechange = empty;\n\t\n\t          if (xhr.status == 200) {\n\t            complete(xhr.responseText);\n\t          } else if (xhr.status == 403) {\n\t            self.onError(xhr.responseText);\n\t          } else {\n\t            self.connecting = false;            \n\t            !self.reconnecting && self.onError(xhr.responseText);\n\t          }\n\t        }\n\t      };\n\t      xhr.send(null);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Find an available transport based on the options supplied in the constructor.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.getTransport = function (override) {\n\t    var transports = override || this.transports, match;\n\t\n\t    for (var i = 0, transport; transport = transports[i]; i++) {\n\t      if (io.Transport[transport]\n\t        && io.Transport[transport].check(this)\n\t        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {\n\t        return new io.Transport[transport](this, this.sessionid);\n\t      }\n\t    }\n\t\n\t    return null;\n\t  };\n\t\n\t  /**\n\t   * Connects to the server.\n\t   *\n\t   * @param {Function} [fn] Callback.\n\t   * @returns {io.Socket}\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.connect = function (fn) {\n\t    if (this.connecting) {\n\t      return this;\n\t    }\n\t\n\t    var self = this;\n\t    self.connecting = true;\n\t    \n\t    this.handshake(function (sid, heartbeat, close, transports) {\n\t      self.sessionid = sid;\n\t      self.closeTimeout = close * 1000;\n\t      self.heartbeatTimeout = heartbeat * 1000;\n\t      if(!self.transports)\n\t          self.transports = self.origTransports = (transports ? io.util.intersect(\n\t              transports.split(',')\n\t            , self.options.transports\n\t          ) : self.options.transports);\n\t\n\t      self.setHeartbeatTimeout();\n\t\n\t      function connect (transports){\n\t        if (self.transport) self.transport.clearTimeouts();\n\t\n\t        self.transport = self.getTransport(transports);\n\t        if (!self.transport) return self.publish('connect_failed');\n\t\n\t        // once the transport is ready\n\t        self.transport.ready(self, function () {\n\t          self.connecting = true;\n\t          self.publish('connecting', self.transport.name);\n\t          self.transport.open();\n\t\n\t          if (self.options['connect timeout']) {\n\t            self.connectTimeoutTimer = setTimeout(function () {\n\t              if (!self.connected) {\n\t                self.connecting = false;\n\t\n\t                if (self.options['try multiple transports']) {\n\t                  var remaining = self.transports;\n\t\n\t                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\n\t                         self.transport.name) {}\n\t\n\t                    if (remaining.length){\n\t                      connect(remaining);\n\t                    } else {\n\t                      self.publish('connect_failed');\n\t                    }\n\t                }\n\t              }\n\t            }, self.options['connect timeout']);\n\t          }\n\t        });\n\t      }\n\t\n\t      connect(self.transports);\n\t\n\t      self.once('connect', function (){\n\t        clearTimeout(self.connectTimeoutTimer);\n\t\n\t        fn && typeof fn == 'function' && fn();\n\t      });\n\t    });\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Clears and sets a new heartbeat timeout using the value given by the\n\t   * server during the handshake.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.setHeartbeatTimeout = function () {\n\t    clearTimeout(this.heartbeatTimeoutTimer);\n\t    if(this.transport && !this.transport.heartbeats()) return;\n\t\n\t    var self = this;\n\t    this.heartbeatTimeoutTimer = setTimeout(function () {\n\t      self.transport.onClose();\n\t    }, this.heartbeatTimeout);\n\t  };\n\t\n\t  /**\n\t   * Sends a message.\n\t   *\n\t   * @param {Object} data packet.\n\t   * @returns {io.Socket}\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.packet = function (data) {\n\t    if (this.connected && !this.doBuffer) {\n\t      this.transport.packet(data);\n\t    } else {\n\t      this.buffer.push(data);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Sets buffer state\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.setBuffer = function (v) {\n\t    this.doBuffer = v;\n\t\n\t    if (!v && this.connected && this.buffer.length) {\n\t      if (!this.options['manualFlush']) {\n\t        this.flushBuffer();\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Flushes the buffer data over the wire.\n\t   * To be invoked manually when 'manualFlush' is set to true.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.flushBuffer = function() {\n\t    this.transport.payload(this.buffer);\n\t    this.buffer = [];\n\t  };\n\t  \n\t\n\t  /**\n\t   * Disconnect the established connect.\n\t   *\n\t   * @returns {io.Socket}\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.disconnect = function () {\n\t    if (this.connected || this.connecting) {\n\t      if (this.open) {\n\t        this.of('').packet({ type: 'disconnect' });\n\t      }\n\t\n\t      // handle disconnection immediately\n\t      this.onDisconnect('booted');\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Disconnects the socket with a sync XHR.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.disconnectSync = function () {\n\t    // ensure disconnection\n\t    var xhr = io.util.request();\n\t    var uri = [\n\t        'http' + (this.options.secure ? 's' : '') + ':/'\n\t      , this.options.host + ':' + this.options.port\n\t      , this.options.resource\n\t      , io.protocol\n\t      , ''\n\t      , this.sessionid\n\t    ].join('/') + '/?disconnect=1';\n\t\n\t    xhr.open('GET', uri, false);\n\t    xhr.send(null);\n\t\n\t    // handle disconnection immediately\n\t    this.onDisconnect('booted');\n\t  };\n\t\n\t  /**\n\t   * Check if we need to use cross domain enabled transports. Cross domain would\n\t   * be a different port or different domain name.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.isXDomain = function () {\n\t\n\t    var port = global.location.port ||\n\t      ('https:' == global.location.protocol ? 443 : 80);\n\t\n\t    return this.options.host !== global.location.hostname \n\t      || this.options.port != port;\n\t  };\n\t\n\t  /**\n\t   * Called upon handshake.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onConnect = function () {\n\t    if (!this.connected) {\n\t      this.connected = true;\n\t      this.connecting = false;\n\t      if (!this.doBuffer) {\n\t        // make sure to flush the buffer\n\t        this.setBuffer(false);\n\t      }\n\t      this.emit('connect');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Called when the transport opens\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onOpen = function () {\n\t    this.open = true;\n\t  };\n\t\n\t  /**\n\t   * Called when the transport closes.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onClose = function () {\n\t    this.open = false;\n\t    clearTimeout(this.heartbeatTimeoutTimer);\n\t  };\n\t\n\t  /**\n\t   * Called when the transport first opens a connection\n\t   *\n\t   * @param text\n\t   */\n\t\n\t  Socket.prototype.onPacket = function (packet) {\n\t    this.of(packet.endpoint).onPacket(packet);\n\t  };\n\t\n\t  /**\n\t   * Handles an error.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onError = function (err) {\n\t    if (err && err.advice) {\n\t      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\n\t        this.disconnect();\n\t        if (this.options.reconnect) {\n\t          this.reconnect();\n\t        }\n\t      }\n\t    }\n\t\n\t    this.publish('error', err && err.reason ? err.reason : err);\n\t  };\n\t\n\t  /**\n\t   * Called when the transport disconnects.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onDisconnect = function (reason) {\n\t    var wasConnected = this.connected\n\t      , wasConnecting = this.connecting;\n\t\n\t    this.connected = false;\n\t    this.connecting = false;\n\t    this.open = false;\n\t\n\t    if (wasConnected || wasConnecting) {\n\t      this.transport.close();\n\t      this.transport.clearTimeouts();\n\t      if (wasConnected) {\n\t        this.publish('disconnect', reason);\n\t\n\t        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n\t          this.reconnect();\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Called upon reconnection.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.reconnect = function () {\n\t    this.reconnecting = true;\n\t    this.reconnectionAttempts = 0;\n\t    this.reconnectionDelay = this.options['reconnection delay'];\n\t\n\t    var self = this\n\t      , maxAttempts = this.options['max reconnection attempts']\n\t      , tryMultiple = this.options['try multiple transports']\n\t      , limit = this.options['reconnection limit'];\n\t\n\t    function reset () {\n\t      if (self.connected) {\n\t        for (var i in self.namespaces) {\n\t          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n\t              self.namespaces[i].packet({ type: 'connect' });\n\t          }\n\t        }\n\t        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n\t      }\n\t\n\t      clearTimeout(self.reconnectionTimer);\n\t\n\t      self.removeListener('connect_failed', maybeReconnect);\n\t      self.removeListener('connect', maybeReconnect);\n\t\n\t      self.reconnecting = false;\n\t\n\t      delete self.reconnectionAttempts;\n\t      delete self.reconnectionDelay;\n\t      delete self.reconnectionTimer;\n\t      delete self.redoTransports;\n\t\n\t      self.options['try multiple transports'] = tryMultiple;\n\t    };\n\t\n\t    function maybeReconnect () {\n\t      if (!self.reconnecting) {\n\t        return;\n\t      }\n\t\n\t      if (self.connected) {\n\t        return reset();\n\t      };\n\t\n\t      if (self.connecting && self.reconnecting) {\n\t        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n\t      }\n\t\n\t      if (self.reconnectionAttempts++ >= maxAttempts) {\n\t        if (!self.redoTransports) {\n\t          self.on('connect_failed', maybeReconnect);\n\t          self.options['try multiple transports'] = true;\n\t          self.transports = self.origTransports;\n\t          self.transport = self.getTransport();\n\t          self.redoTransports = true;\n\t          self.connect();\n\t        } else {\n\t          self.publish('reconnect_failed');\n\t          reset();\n\t        }\n\t      } else {\n\t        if (self.reconnectionDelay < limit) {\n\t          self.reconnectionDelay *= 2; // exponential back off\n\t        }\n\t\n\t        self.connect();\n\t        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n\t        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n\t      }\n\t    };\n\t\n\t    this.options['try multiple transports'] = false;\n\t    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n\t\n\t    this.on('connect', maybeReconnect);\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.SocketNamespace = SocketNamespace;\n\t\n\t  /**\n\t   * Socket namespace constructor.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  function SocketNamespace (socket, name) {\n\t    this.socket = socket;\n\t    this.name = name || '';\n\t    this.flags = {};\n\t    this.json = new Flag(this, 'json');\n\t    this.ackPackets = 0;\n\t    this.acks = {};\n\t  };\n\t\n\t  /**\n\t   * Apply EventEmitter mixin.\n\t   */\n\t\n\t  io.util.mixin(SocketNamespace, io.EventEmitter);\n\t\n\t  /**\n\t   * Copies emit since we override it\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\n\t\n\t  /**\n\t   * Creates a new namespace, by proxying the request to the socket. This\n\t   * allows us to use the synax as we do on the server.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  SocketNamespace.prototype.of = function () {\n\t    return this.socket.of.apply(this.socket, arguments);\n\t  };\n\t\n\t  /**\n\t   * Sends a packet.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.packet = function (packet) {\n\t    packet.endpoint = this.name;\n\t    this.socket.packet(packet);\n\t    this.flags = {};\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Sends a message\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  SocketNamespace.prototype.send = function (data, fn) {\n\t    var packet = {\n\t        type: this.flags.json ? 'json' : 'message'\n\t      , data: data\n\t    };\n\t\n\t    if ('function' == typeof fn) {\n\t      packet.id = ++this.ackPackets;\n\t      packet.ack = true;\n\t      this.acks[packet.id] = fn;\n\t    }\n\t\n\t    return this.packet(packet);\n\t  };\n\t\n\t  /**\n\t   * Emits an event\n\t   *\n\t   * @api public\n\t   */\n\t  \n\t  SocketNamespace.prototype.emit = function (name) {\n\t    var args = Array.prototype.slice.call(arguments, 1)\n\t      , lastArg = args[args.length - 1]\n\t      , packet = {\n\t            type: 'event'\n\t          , name: name\n\t        };\n\t\n\t    if ('function' == typeof lastArg) {\n\t      packet.id = ++this.ackPackets;\n\t      packet.ack = 'data';\n\t      this.acks[packet.id] = lastArg;\n\t      args = args.slice(0, args.length - 1);\n\t    }\n\t\n\t    packet.args = args;\n\t\n\t    return this.packet(packet);\n\t  };\n\t\n\t  /**\n\t   * Disconnects the namespace\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.disconnect = function () {\n\t    if (this.name === '') {\n\t      this.socket.disconnect();\n\t    } else {\n\t      this.packet({ type: 'disconnect' });\n\t      this.$emit('disconnect');\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Handles a packet\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.onPacket = function (packet) {\n\t    var self = this;\n\t\n\t    function ack () {\n\t      self.packet({\n\t          type: 'ack'\n\t        , args: io.util.toArray(arguments)\n\t        , ackId: packet.id\n\t      });\n\t    };\n\t\n\t    switch (packet.type) {\n\t      case 'connect':\n\t        this.$emit('connect');\n\t        break;\n\t\n\t      case 'disconnect':\n\t        if (this.name === '') {\n\t          this.socket.onDisconnect(packet.reason || 'booted');\n\t        } else {\n\t          this.$emit('disconnect', packet.reason);\n\t        }\n\t        break;\n\t\n\t      case 'message':\n\t      case 'json':\n\t        var params = ['message', packet.data];\n\t\n\t        if (packet.ack == 'data') {\n\t          params.push(ack);\n\t        } else if (packet.ack) {\n\t          this.packet({ type: 'ack', ackId: packet.id });\n\t        }\n\t\n\t        this.$emit.apply(this, params);\n\t        break;\n\t\n\t      case 'event':\n\t        var params = [packet.name].concat(packet.args);\n\t\n\t        if (packet.ack == 'data')\n\t          params.push(ack);\n\t\n\t        this.$emit.apply(this, params);\n\t        break;\n\t\n\t      case 'ack':\n\t        if (this.acks[packet.ackId]) {\n\t          this.acks[packet.ackId].apply(this, packet.args);\n\t          delete this.acks[packet.ackId];\n\t        }\n\t        break;\n\t\n\t      case 'error':\n\t        if (packet.advice){\n\t          this.socket.onError(packet);\n\t        } else {\n\t          if (packet.reason == 'unauthorized') {\n\t            this.$emit('connect_failed', packet.reason);\n\t          } else {\n\t            this.$emit('error', packet.reason);\n\t          }\n\t        }\n\t        break;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Flag interface.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  function Flag (nsp, name) {\n\t    this.namespace = nsp;\n\t    this.name = name;\n\t  };\n\t\n\t  /**\n\t   * Send a message\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Flag.prototype.send = function () {\n\t    this.namespace.flags[this.name] = true;\n\t    this.namespace.send.apply(this.namespace, arguments);\n\t  };\n\t\n\t  /**\n\t   * Emit an event\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Flag.prototype.emit = function () {\n\t    this.namespace.flags[this.name] = true;\n\t    this.namespace.emit.apply(this.namespace, arguments);\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.websocket = WS;\n\t\n\t  /**\n\t   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n\t   * persistent connection with the Socket.IO server. This transport will also\n\t   * be inherited by the FlashSocket fallback as it provides a API compatible\n\t   * polyfill for the WebSockets.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport}\n\t   * @api public\n\t   */\n\t\n\t  function WS (socket) {\n\t    io.Transport.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from Transport.\n\t   */\n\t\n\t  io.util.inherit(WS, io.Transport);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  WS.prototype.name = 'websocket';\n\t\n\t  /**\n\t   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n\t   * all the appropriate listeners to handle the responses from the server.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  WS.prototype.open = function () {\n\t    var query = io.util.query(this.socket.options.query)\n\t      , self = this\n\t      , Socket\n\t\n\t\n\t    if (!Socket) {\n\t      Socket = global.MozWebSocket || global.WebSocket;\n\t    }\n\t\n\t    this.websocket = new Socket(this.prepareUrl() + query);\n\t\n\t    this.websocket.onopen = function () {\n\t      self.onOpen();\n\t      self.socket.setBuffer(false);\n\t    };\n\t    this.websocket.onmessage = function (ev) {\n\t      self.onData(ev.data);\n\t    };\n\t    this.websocket.onclose = function () {\n\t      self.onClose();\n\t      self.socket.setBuffer(true);\n\t    };\n\t    this.websocket.onerror = function (e) {\n\t      self.onError(e);\n\t    };\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Send a message to the Socket.IO server. The message will automatically be\n\t   * encoded in the correct message format.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  // Do to a bug in the current IDevices browser, we need to wrap the send in a \n\t  // setTimeout, when they resume from sleeping the browser will crash if \n\t  // we don't allow the browser time to detect the socket has been closed\n\t  if (io.util.ua.iDevice) {\n\t    WS.prototype.send = function (data) {\n\t      var self = this;\n\t      setTimeout(function() {\n\t         self.websocket.send(data);\n\t      },0);\n\t      return this;\n\t    };\n\t  } else {\n\t    WS.prototype.send = function (data) {\n\t      this.websocket.send(data);\n\t      return this;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Payload\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  WS.prototype.payload = function (arr) {\n\t    for (var i = 0, l = arr.length; i < l; i++) {\n\t      this.packet(arr[i]);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Disconnect the established `WebSocket` connection.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  WS.prototype.close = function () {\n\t    this.websocket.close();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Handle the errors that `WebSocket` might be giving when we\n\t   * are attempting to connect or send messages.\n\t   *\n\t   * @param {Error} e The error.\n\t   * @api private\n\t   */\n\t\n\t  WS.prototype.onError = function (e) {\n\t    this.socket.onError(e);\n\t  };\n\t\n\t  /**\n\t   * Returns the appropriate scheme for the URI generation.\n\t   *\n\t   * @api private\n\t   */\n\t  WS.prototype.scheme = function () {\n\t    return this.socket.options.secure ? 'wss' : 'ws';\n\t  };\n\t\n\t  /**\n\t   * Checks if the browser has support for native `WebSockets` and that\n\t   * it's not the polyfill created for the FlashSocket transport.\n\t   *\n\t   * @return {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  WS.check = function () {\n\t    return ('WebSocket' in global && !('__addTask' in WebSocket))\n\t          || 'MozWebSocket' in global;\n\t  };\n\t\n\t  /**\n\t   * Check if the `WebSocket` transport support cross domain communications.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  WS.xdomainCheck = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('websocket');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.flashsocket = Flashsocket;\n\t\n\t  /**\n\t   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n\t   * specification. It uses a .swf file to communicate with the server. If you want\n\t   * to serve the .swf file from a other server than where the Socket.IO script is\n\t   * coming from you need to use the insecure version of the .swf. More information\n\t   * about this can be found on the github page.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport.websocket}\n\t   * @api public\n\t   */\n\t\n\t  function Flashsocket () {\n\t    io.Transport.websocket.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from Transport.\n\t   */\n\t\n\t  io.util.inherit(Flashsocket, io.Transport.websocket);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.name = 'flashsocket';\n\t\n\t  /**\n\t   * Disconnect the established `FlashSocket` connection. This is done by adding a \n\t   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n\t   * transport.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.open = function () {\n\t    var self = this\n\t      , args = arguments;\n\t\n\t    WebSocket.__addTask(function () {\n\t      io.Transport.websocket.prototype.open.apply(self, args);\n\t    });\n\t    return this;\n\t  };\n\t  \n\t  /**\n\t   * Sends a message to the Socket.IO server. This is done by adding a new\n\t   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n\t   * transport.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.send = function () {\n\t    var self = this, args = arguments;\n\t    WebSocket.__addTask(function () {\n\t      io.Transport.websocket.prototype.send.apply(self, args);\n\t    });\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Disconnects the established `FlashSocket` connection.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.close = function () {\n\t    WebSocket.__tasks.length = 0;\n\t    io.Transport.websocket.prototype.close.call(this);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * The WebSocket fall back needs to append the flash container to the body\n\t   * element, so we need to make sure we have access to it. Or defer the call\n\t   * until we are sure there is a body element.\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  Flashsocket.prototype.ready = function (socket, fn) {\n\t    function init () {\n\t      var options = socket.options\n\t        , port = options['flash policy port']\n\t        , path = [\n\t              'http' + (options.secure ? 's' : '') + ':/'\n\t            , options.host + ':' + options.port\n\t            , options.resource\n\t            , 'static/flashsocket'\n\t            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\n\t          ];\n\t\n\t      // Only start downloading the swf file when the checked that this browser\n\t      // actually supports it\n\t      if (!Flashsocket.loaded) {\n\t        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n\t          // Set the correct file based on the XDomain settings\n\t          WEB_SOCKET_SWF_LOCATION = path.join('/');\n\t        }\n\t\n\t        if (port !== 843) {\n\t          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n\t        }\n\t\n\t        WebSocket.__initialize();\n\t        Flashsocket.loaded = true;\n\t      }\n\t\n\t      fn.call(self);\n\t    }\n\t\n\t    var self = this;\n\t    if (document.body) return init();\n\t\n\t    io.util.load(init);\n\t  };\n\t\n\t  /**\n\t   * Check if the FlashSocket transport is supported as it requires that the Adobe\n\t   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n\t   * the polyfill is correctly loaded.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.check = function () {\n\t    if (\n\t        typeof WebSocket == 'undefined'\n\t      || !('__initialize' in WebSocket) || !swfobject\n\t    ) return false;\n\t\n\t    return swfobject.getFlashPlayerVersion().major >= 10;\n\t  };\n\t\n\t  /**\n\t   * Check if the FlashSocket transport can be used as cross domain / cross origin \n\t   * transport. Because we can't see which type (secure or insecure) of .swf is used\n\t   * we will just return true.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.xdomainCheck = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Disable AUTO_INITIALIZATION\n\t   */\n\t\n\t  if (typeof window != 'undefined') {\n\t    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n\t  }\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('flashsocket');\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t/*\tSWFObject v2.2 <http://code.google.com/p/swfobject/> \n\t\tis released under the MIT License <http://www.opensource.org/licenses/mit-license.php> \n\t*/\n\tif ('undefined' != typeof window) {\n\tvar swfobject=function(){var D=\"undefined\",r=\"object\",S=\"Shockwave Flash\",W=\"ShockwaveFlash.ShockwaveFlash\",q=\"application/x-shockwave-flash\",R=\"SWFObjectExprInst\",x=\"onreadystatechange\",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):false,X=!+\"\\v1\",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\");ag[0]=parseInt(ab.replace(/^(.*)\\..*$/,\"$1\"),10);ag[1]=parseInt(ab.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable(\"$version\");if(ab){X=true;ab=ab.split(\" \")[1].split(\",\");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState==\"complete\")||(typeof j.readyState==D&&(j.getElementsByTagName(\"body\")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(\"DOMContentLoaded\",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState==\"complete\"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(\"left\")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(\"body\")[0].appendChild(C(\"span\"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(\"load\",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(\"load\",Y,false)}else{if(typeof O.attachEvent!=D){i(O,\"onload\",Y)}else{if(typeof O.onload==\"function\"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(\"body\")[0];var aa=C(r);aa.setAttribute(\"type\",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(\"$version\");if(ab){ab=ab.split(\" \")[1].split(\",\");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(\"width\")||\"0\";ai.height=ae.getAttribute(\"height\")||\"0\";if(ae.getAttribute(\"class\")){ai.styleclass=ae.getAttribute(\"class\")}if(ae.getAttribute(\"align\")){ai.align=ae.getAttribute(\"align\")}var ah={};var X=ae.getElementsByTagName(\"param\");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute(\"name\").toLowerCase()!=\"movie\"){ah[X[ad].getAttribute(\"name\")]=X[ad].getAttribute(\"value\")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName==\"OBJECT\"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F(\"6.0.65\")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==\"OBJECT\"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width=\"310\"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height=\"137\"}j.title=j.title.slice(0,47)+\" - Flash Player Installation\";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):\"PlugIn\",ac=\"MMredirectURL=\"+O.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+ad+\"&MMdoctitle=\"+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=\"&\"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C(\"div\");X+=\"SWFObjectNew\";Y.setAttribute(\"id\",X);ae.parentNode.insertBefore(Y,ae);ae.style.display=\"none\";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C(\"div\");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=\"none\";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(\"div\");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName==\"PARAM\")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah=\"\";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==\"data\"){ag.movie=ai[ae]}else{if(ae.toLowerCase()==\"styleclass\"){ah+=' class=\"'+ai[ae]+'\"'}else{if(ae.toLowerCase()!=\"classid\"){ah+=\" \"+ae+'=\"'+ai[ae]+'\"'}}}}}var af=\"\";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name=\"'+ad+'\" value=\"'+ag[ad]+'\" />'}}aa.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+ah+\">\"+af+\"</object>\";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(\"type\",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==\"styleclass\"){Z.setAttribute(\"class\",ai[ac])}else{if(ac.toLowerCase()!=\"classid\"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!=\"movie\"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(\"param\");aa.setAttribute(\"name\",X);aa.setAttribute(\"value\",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName==\"OBJECT\"){if(M.ie&&M.win){X.style.display=\"none\";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==\"function\"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(\".\");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName(\"head\")[0];if(!aa){return}var X=(ad&&typeof ad==\"string\")?ad:\"screen\";if(ab){n=null;G=null}if(!n||G!=X){var Z=C(\"style\");Z.setAttribute(\"type\",\"text/css\");Z.setAttribute(\"media\",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+\" {\"+Y+\"}\"))}}}function w(Z,X){if(!m){return}var Y=X?\"visible\":\"hidden\";if(J&&c(Z)){c(Z).style.visibility=Y}else{v(\"#\"+Z,\"visibility:\"+Y)}}function L(Y){var Z=/[\\\\\\\"<>\\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent(\"onunload\",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+=\"\";ag+=\"\";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=\"&\"+ai+\"=\"+Z[ai]}else{am.flashvars=ai+\"=\"+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\\?/.test(Z)){Z=Z.split(\"?\")[1]}if(aa==null){return L(Z)}var Y=Z.split(\"&\");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(\"=\"))==aa){return L(Y[X].substring((Y[X].indexOf(\"=\")+1)))}}}return\"\"},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display=\"block\"}}if(E){E(B)}}a=false}}}}();\n\t}\n\t// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>\n\t// License: New BSD License\n\t// Reference: http://dev.w3.org/html5/websockets/\n\t// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\n\t\n\t(function() {\n\t  \n\t  if ('undefined' == typeof window || window.WebSocket) return;\n\t\n\t  var console = window.console;\n\t  if (!console || !console.log || !console.error) {\n\t    console = {log: function(){ }, error: function(){ }};\n\t  }\n\t  \n\t  if (!swfobject.hasFlashPlayerVersion(\"10.0.0\")) {\n\t    console.error(\"Flash Player >= 10.0.0 is required.\");\n\t    return;\n\t  }\n\t  if (location.protocol == \"file:\") {\n\t    console.error(\n\t      \"WARNING: web-socket-js doesn't work in file:///... URL \" +\n\t      \"unless you set Flash Security Settings properly. \" +\n\t      \"Open the page via Web server i.e. http://...\");\n\t  }\n\t\n\t  /**\n\t   * This class represents a faux web socket.\n\t   * @param {string} url\n\t   * @param {array or string} protocols\n\t   * @param {string} proxyHost\n\t   * @param {int} proxyPort\n\t   * @param {string} headers\n\t   */\n\t  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {\n\t    var self = this;\n\t    self.__id = WebSocket.__nextId++;\n\t    WebSocket.__instances[self.__id] = self;\n\t    self.readyState = WebSocket.CONNECTING;\n\t    self.bufferedAmount = 0;\n\t    self.__events = {};\n\t    if (!protocols) {\n\t      protocols = [];\n\t    } else if (typeof protocols == \"string\") {\n\t      protocols = [protocols];\n\t    }\n\t    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.\n\t    // Otherwise, when onopen fires immediately, onopen is called before it is set.\n\t    setTimeout(function() {\n\t      WebSocket.__addTask(function() {\n\t        WebSocket.__flash.create(\n\t            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);\n\t      });\n\t    }, 0);\n\t  };\n\t\n\t  /**\n\t   * Send data to the web socket.\n\t   * @param {string} data  The data to send to the socket.\n\t   * @return {boolean}  True for success, false for failure.\n\t   */\n\t  WebSocket.prototype.send = function(data) {\n\t    if (this.readyState == WebSocket.CONNECTING) {\n\t      throw \"INVALID_STATE_ERR: Web Socket connection has not been established\";\n\t    }\n\t    // We use encodeURIComponent() here, because FABridge doesn't work if\n\t    // the argument includes some characters. We don't use escape() here\n\t    // because of this:\n\t    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions\n\t    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't\n\t    // preserve all Unicode characters either e.g. \"\\uffff\" in Firefox.\n\t    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require\n\t    // additional testing.\n\t    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));\n\t    if (result < 0) { // success\n\t      return true;\n\t    } else {\n\t      this.bufferedAmount += result;\n\t      return false;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Close this web socket gracefully.\n\t   */\n\t  WebSocket.prototype.close = function() {\n\t    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {\n\t      return;\n\t    }\n\t    this.readyState = WebSocket.CLOSING;\n\t    WebSocket.__flash.close(this.__id);\n\t  };\n\t\n\t  /**\n\t   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n\t   *\n\t   * @param {string} type\n\t   * @param {function} listener\n\t   * @param {boolean} useCapture\n\t   * @return void\n\t   */\n\t  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {\n\t    if (!(type in this.__events)) {\n\t      this.__events[type] = [];\n\t    }\n\t    this.__events[type].push(listener);\n\t  };\n\t\n\t  /**\n\t   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n\t   *\n\t   * @param {string} type\n\t   * @param {function} listener\n\t   * @param {boolean} useCapture\n\t   * @return void\n\t   */\n\t  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {\n\t    if (!(type in this.__events)) return;\n\t    var events = this.__events[type];\n\t    for (var i = events.length - 1; i >= 0; --i) {\n\t      if (events[i] === listener) {\n\t        events.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n\t   *\n\t   * @param {Event} event\n\t   * @return void\n\t   */\n\t  WebSocket.prototype.dispatchEvent = function(event) {\n\t    var events = this.__events[event.type] || [];\n\t    for (var i = 0; i < events.length; ++i) {\n\t      events[i](event);\n\t    }\n\t    var handler = this[\"on\" + event.type];\n\t    if (handler) handler(event);\n\t  };\n\t\n\t  /**\n\t   * Handles an event from Flash.\n\t   * @param {Object} flashEvent\n\t   */\n\t  WebSocket.prototype.__handleEvent = function(flashEvent) {\n\t    if (\"readyState\" in flashEvent) {\n\t      this.readyState = flashEvent.readyState;\n\t    }\n\t    if (\"protocol\" in flashEvent) {\n\t      this.protocol = flashEvent.protocol;\n\t    }\n\t    \n\t    var jsEvent;\n\t    if (flashEvent.type == \"open\" || flashEvent.type == \"error\") {\n\t      jsEvent = this.__createSimpleEvent(flashEvent.type);\n\t    } else if (flashEvent.type == \"close\") {\n\t      // TODO implement jsEvent.wasClean\n\t      jsEvent = this.__createSimpleEvent(\"close\");\n\t    } else if (flashEvent.type == \"message\") {\n\t      var data = decodeURIComponent(flashEvent.message);\n\t      jsEvent = this.__createMessageEvent(\"message\", data);\n\t    } else {\n\t      throw \"unknown event type: \" + flashEvent.type;\n\t    }\n\t    \n\t    this.dispatchEvent(jsEvent);\n\t  };\n\t  \n\t  WebSocket.prototype.__createSimpleEvent = function(type) {\n\t    if (document.createEvent && window.Event) {\n\t      var event = document.createEvent(\"Event\");\n\t      event.initEvent(type, false, false);\n\t      return event;\n\t    } else {\n\t      return {type: type, bubbles: false, cancelable: false};\n\t    }\n\t  };\n\t  \n\t  WebSocket.prototype.__createMessageEvent = function(type, data) {\n\t    if (document.createEvent && window.MessageEvent && !window.opera) {\n\t      var event = document.createEvent(\"MessageEvent\");\n\t      event.initMessageEvent(\"message\", false, false, data, null, null, window, null);\n\t      return event;\n\t    } else {\n\t      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.\n\t      return {type: type, data: data, bubbles: false, cancelable: false};\n\t    }\n\t  };\n\t  \n\t  /**\n\t   * Define the WebSocket readyState enumeration.\n\t   */\n\t  WebSocket.CONNECTING = 0;\n\t  WebSocket.OPEN = 1;\n\t  WebSocket.CLOSING = 2;\n\t  WebSocket.CLOSED = 3;\n\t\n\t  WebSocket.__flash = null;\n\t  WebSocket.__instances = {};\n\t  WebSocket.__tasks = [];\n\t  WebSocket.__nextId = 0;\n\t  \n\t  /**\n\t   * Load a new flash security policy file.\n\t   * @param {string} url\n\t   */\n\t  WebSocket.loadFlashPolicyFile = function(url){\n\t    WebSocket.__addTask(function() {\n\t      WebSocket.__flash.loadManualPolicyFile(url);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.\n\t   */\n\t  WebSocket.__initialize = function() {\n\t    if (WebSocket.__flash) return;\n\t    \n\t    if (WebSocket.__swfLocation) {\n\t      // For backword compatibility.\n\t      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;\n\t    }\n\t    if (!window.WEB_SOCKET_SWF_LOCATION) {\n\t      console.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");\n\t      return;\n\t    }\n\t    var container = document.createElement(\"div\");\n\t    container.id = \"webSocketContainer\";\n\t    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents\n\t    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).\n\t    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash\n\t    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is\n\t    // the best we can do as far as we know now.\n\t    container.style.position = \"absolute\";\n\t    if (WebSocket.__isFlashLite()) {\n\t      container.style.left = \"0px\";\n\t      container.style.top = \"0px\";\n\t    } else {\n\t      container.style.left = \"-100px\";\n\t      container.style.top = \"-100px\";\n\t    }\n\t    var holder = document.createElement(\"div\");\n\t    holder.id = \"webSocketFlash\";\n\t    container.appendChild(holder);\n\t    document.body.appendChild(container);\n\t    // See this article for hasPriority:\n\t    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\n\t    swfobject.embedSWF(\n\t      WEB_SOCKET_SWF_LOCATION,\n\t      \"webSocketFlash\",\n\t      \"1\" /* width */,\n\t      \"1\" /* height */,\n\t      \"10.0.0\" /* SWF version */,\n\t      null,\n\t      null,\n\t      {hasPriority: true, swliveconnect : true, allowScriptAccess: \"always\"},\n\t      null,\n\t      function(e) {\n\t        if (!e.success) {\n\t          console.error(\"[WebSocket] swfobject.embedSWF failed\");\n\t        }\n\t      });\n\t  };\n\t  \n\t  /**\n\t   * Called by Flash to notify JS that it's fully loaded and ready\n\t   * for communication.\n\t   */\n\t  WebSocket.__onFlashInitialized = function() {\n\t    // We need to set a timeout here to avoid round-trip calls\n\t    // to flash during the initialization process.\n\t    setTimeout(function() {\n\t      WebSocket.__flash = document.getElementById(\"webSocketFlash\");\n\t      WebSocket.__flash.setCallerUrl(location.href);\n\t      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);\n\t      for (var i = 0; i < WebSocket.__tasks.length; ++i) {\n\t        WebSocket.__tasks[i]();\n\t      }\n\t      WebSocket.__tasks = [];\n\t    }, 0);\n\t  };\n\t  \n\t  /**\n\t   * Called by Flash to notify WebSockets events are fired.\n\t   */\n\t  WebSocket.__onFlashEvent = function() {\n\t    setTimeout(function() {\n\t      try {\n\t        // Gets events using receiveEvents() instead of getting it from event object\n\t        // of Flash event. This is to make sure to keep message order.\n\t        // It seems sometimes Flash events don't arrive in the same order as they are sent.\n\t        var events = WebSocket.__flash.receiveEvents();\n\t        for (var i = 0; i < events.length; ++i) {\n\t          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);\n\t        }\n\t      } catch (e) {\n\t        console.error(e);\n\t      }\n\t    }, 0);\n\t    return true;\n\t  };\n\t  \n\t  // Called by Flash.\n\t  WebSocket.__log = function(message) {\n\t    console.log(decodeURIComponent(message));\n\t  };\n\t  \n\t  // Called by Flash.\n\t  WebSocket.__error = function(message) {\n\t    console.error(decodeURIComponent(message));\n\t  };\n\t  \n\t  WebSocket.__addTask = function(task) {\n\t    if (WebSocket.__flash) {\n\t      task();\n\t    } else {\n\t      WebSocket.__tasks.push(task);\n\t    }\n\t  };\n\t  \n\t  /**\n\t   * Test if the browser is running flash lite.\n\t   * @return {boolean} True if flash lite is running, false otherwise.\n\t   */\n\t  WebSocket.__isFlashLite = function() {\n\t    if (!window.navigator || !window.navigator.mimeTypes) {\n\t      return false;\n\t    }\n\t    var mimeType = window.navigator.mimeTypes[\"application/x-shockwave-flash\"];\n\t    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {\n\t      return false;\n\t    }\n\t    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;\n\t  };\n\t  \n\t  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {\n\t    if (window.addEventListener) {\n\t      window.addEventListener(\"load\", function(){\n\t        WebSocket.__initialize();\n\t      }, false);\n\t    } else {\n\t      window.attachEvent(\"onload\", function(){\n\t        WebSocket.__initialize();\n\t      });\n\t    }\n\t  }\n\t  \n\t})();\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  exports.XHR = XHR;\n\t\n\t  /**\n\t   * XHR constructor\n\t   *\n\t   * @costructor\n\t   * @api public\n\t   */\n\t\n\t  function XHR (socket) {\n\t    if (!socket) return;\n\t\n\t    io.Transport.apply(this, arguments);\n\t    this.sendBuffer = [];\n\t  };\n\t\n\t  /**\n\t   * Inherits from Transport.\n\t   */\n\t\n\t  io.util.inherit(XHR, io.Transport);\n\t\n\t  /**\n\t   * Establish a connection\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  XHR.prototype.open = function () {\n\t    this.socket.setBuffer(false);\n\t    this.onOpen();\n\t    this.get();\n\t\n\t    // we need to make sure the request succeeds since we have no indication\n\t    // whether the request opened or not until it succeeded.\n\t    this.setCloseTimeout();\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Check if we need to send data to the Socket.IO server, if we have data in our\n\t   * buffer we encode it and forward it to the `post` method.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHR.prototype.payload = function (payload) {\n\t    var msgs = [];\n\t\n\t    for (var i = 0, l = payload.length; i < l; i++) {\n\t      msgs.push(io.parser.encodePacket(payload[i]));\n\t    }\n\t\n\t    this.send(io.parser.encodePayload(msgs));\n\t  };\n\t\n\t  /**\n\t   * Send data to the Socket.IO server.\n\t   *\n\t   * @param data The message\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  XHR.prototype.send = function (data) {\n\t    this.post(data);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Posts a encoded message to the Socket.IO server.\n\t   *\n\t   * @param {String} data A encoded message.\n\t   * @api private\n\t   */\n\t\n\t  function empty () { };\n\t\n\t  XHR.prototype.post = function (data) {\n\t    var self = this;\n\t    this.socket.setBuffer(true);\n\t\n\t    function stateChange () {\n\t      if (this.readyState == 4) {\n\t        this.onreadystatechange = empty;\n\t        self.posting = false;\n\t\n\t        if (this.status == 200){\n\t          self.socket.setBuffer(false);\n\t        } else {\n\t          self.onClose();\n\t        }\n\t      }\n\t    }\n\t\n\t    function onload () {\n\t      this.onload = empty;\n\t      self.socket.setBuffer(false);\n\t    };\n\t\n\t    this.sendXHR = this.request('POST');\n\t\n\t    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\n\t      this.sendXHR.onload = this.sendXHR.onerror = onload;\n\t    } else {\n\t      this.sendXHR.onreadystatechange = stateChange;\n\t    }\n\t\n\t    this.sendXHR.send(data);\n\t  };\n\t\n\t  /**\n\t   * Disconnects the established `XHR` connection.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  XHR.prototype.close = function () {\n\t    this.onClose();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Generates a configured XHR request\n\t   *\n\t   * @param {String} url The url that needs to be requested.\n\t   * @param {String} method The method the request should use.\n\t   * @returns {XMLHttpRequest}\n\t   * @api private\n\t   */\n\t\n\t  XHR.prototype.request = function (method) {\n\t    var req = io.util.request(this.socket.isXDomain())\n\t      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\n\t\n\t    req.open(method || 'GET', this.prepareUrl() + query, true);\n\t\n\t    if (method == 'POST') {\n\t      try {\n\t        if (req.setRequestHeader) {\n\t          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n\t        } else {\n\t          // XDomainRequest\n\t          req.contentType = 'text/plain';\n\t        }\n\t      } catch (e) {}\n\t    }\n\t\n\t    return req;\n\t  };\n\t\n\t  /**\n\t   * Returns the scheme to use for the transport URLs.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHR.prototype.scheme = function () {\n\t    return this.socket.options.secure ? 'https' : 'http';\n\t  };\n\t\n\t  /**\n\t   * Check if the XHR transports are supported\n\t   *\n\t   * @param {Boolean} xdomain Check if we support cross domain requests.\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  XHR.check = function (socket, xdomain) {\n\t    try {\n\t      var request = io.util.request(xdomain),\n\t          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),\n\t          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),\n\t          isXProtocol = (global.location && socketProtocol != global.location.protocol);\n\t      if (request && !(usesXDomReq && isXProtocol)) {\n\t        return true;\n\t      }\n\t    } catch(e) {}\n\t\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Check if the XHR transport supports cross domain requests.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  XHR.xdomainCheck = function (socket) {\n\t    return XHR.check(socket, true);\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.htmlfile = HTMLFile;\n\t\n\t  /**\n\t   * The HTMLFile transport creates a `forever iframe` based transport\n\t   * for Internet Explorer. Regular forever iframe implementations will \n\t   * continuously trigger the browsers buzy indicators. If the forever iframe\n\t   * is created inside a `htmlfile` these indicators will not be trigged.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport.XHR}\n\t   * @api public\n\t   */\n\t\n\t  function HTMLFile (socket) {\n\t    io.Transport.XHR.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from XHR transport.\n\t   */\n\t\n\t  io.util.inherit(HTMLFile, io.Transport.XHR);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.prototype.name = 'htmlfile';\n\t\n\t  /**\n\t   * Creates a new Ac...eX `htmlfile` with a forever loading iframe\n\t   * that can be used to listen to messages. Inside the generated\n\t   * `htmlfile` a reference will be made to the HTMLFile transport.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  HTMLFile.prototype.get = function () {\n\t    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n\t    this.doc.open();\n\t    this.doc.write('<html></html>');\n\t    this.doc.close();\n\t    this.doc.parentWindow.s = this;\n\t\n\t    var iframeC = this.doc.createElement('div');\n\t    iframeC.className = 'socketio';\n\t\n\t    this.doc.body.appendChild(iframeC);\n\t    this.iframe = this.doc.createElement('iframe');\n\t\n\t    iframeC.appendChild(this.iframe);\n\t\n\t    var self = this\n\t      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\n\t\n\t    this.iframe.src = this.prepareUrl() + query;\n\t\n\t    io.util.on(window, 'unload', function () {\n\t      self.destroy();\n\t    });\n\t  };\n\t\n\t  /**\n\t   * The Socket.IO server will write script tags inside the forever\n\t   * iframe, this function will be used as callback for the incoming\n\t   * information.\n\t   *\n\t   * @param {String} data The message\n\t   * @param {document} doc Reference to the context\n\t   * @api private\n\t   */\n\t\n\t  HTMLFile.prototype._ = function (data, doc) {\n\t    // unescape all forward slashes. see GH-1251\n\t    data = data.replace(/\\\\\\//g, '/');\n\t    this.onData(data);\n\t    try {\n\t      var script = doc.getElementsByTagName('script')[0];\n\t      script.parentNode.removeChild(script);\n\t    } catch (e) { }\n\t  };\n\t\n\t  /**\n\t   * Destroy the established connection, iframe and `htmlfile`.\n\t   * And calls the `CollectGarbage` function of Internet Explorer\n\t   * to release the memory.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  HTMLFile.prototype.destroy = function () {\n\t    if (this.iframe){\n\t      try {\n\t        this.iframe.src = 'about:blank';\n\t      } catch(e){}\n\t\n\t      this.doc = null;\n\t      this.iframe.parentNode.removeChild(this.iframe);\n\t      this.iframe = null;\n\t\n\t      CollectGarbage();\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Disconnects the established connection.\n\t   *\n\t   * @returns {Transport} Chaining.\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.prototype.close = function () {\n\t    this.destroy();\n\t    return io.Transport.XHR.prototype.close.call(this);\n\t  };\n\t\n\t  /**\n\t   * Checks if the browser supports this transport. The browser\n\t   * must have an `Ac...eXObject` implementation.\n\t   *\n\t   * @return {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.check = function (socket) {\n\t    if (typeof window != \"undefined\" && (['Active'].concat('Object').join('X')) in window){\n\t      try {\n\t        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n\t        return a && io.Transport.XHR.check(socket);\n\t      } catch(e){}\n\t    }\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Check if cross domain requests are supported.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.xdomainCheck = function () {\n\t    // we can probably do handling for sub-domains, we should\n\t    // test that it's cross domain but a subdomain here\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('htmlfile');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports['xhr-polling'] = XHRPolling;\n\t\n\t  /**\n\t   * The XHR-polling transport uses long polling XHR requests to create a\n\t   * \"persistent\" connection with the server.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  function XHRPolling () {\n\t    io.Transport.XHR.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from XHR transport.\n\t   */\n\t\n\t  io.util.inherit(XHRPolling, io.Transport.XHR);\n\t\n\t  /**\n\t   * Merge the properties from XHR transport\n\t   */\n\t\n\t  io.util.merge(XHRPolling, io.Transport.XHR);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  XHRPolling.prototype.name = 'xhr-polling';\n\t\n\t  /**\n\t   * Indicates whether heartbeats is enabled for this transport\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHRPolling.prototype.heartbeats = function () {\n\t    return false;\n\t  };\n\t\n\t  /** \n\t   * Establish a connection, for iPhone and Android this will be done once the page\n\t   * is loaded.\n\t   *\n\t   * @returns {Transport} Chaining.\n\t   * @api public\n\t   */\n\t\n\t  XHRPolling.prototype.open = function () {\n\t    var self = this;\n\t\n\t    io.Transport.XHR.prototype.open.call(self);\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Starts a XHR request to wait for incoming messages.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  function empty () {};\n\t\n\t  XHRPolling.prototype.get = function () {\n\t    if (!this.isOpen) return;\n\t\n\t    var self = this;\n\t\n\t    function stateChange () {\n\t      if (this.readyState == 4) {\n\t        this.onreadystatechange = empty;\n\t\n\t        if (this.status == 200) {\n\t          self.onData(this.responseText);\n\t          self.get();\n\t        } else {\n\t          self.onClose();\n\t        }\n\t      }\n\t    };\n\t\n\t    function onload () {\n\t      this.onload = empty;\n\t      this.onerror = empty;\n\t      self.retryCounter = 1;\n\t      self.onData(this.responseText);\n\t      self.get();\n\t    };\n\t\n\t    function onerror () {\n\t      self.retryCounter ++;\n\t      if(!self.retryCounter || self.retryCounter > 3) {\n\t        self.onClose();  \n\t      } else {\n\t        self.get();\n\t      }\n\t    };\n\t\n\t    this.xhr = this.request();\n\t\n\t    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n\t      this.xhr.onload = onload;\n\t      this.xhr.onerror = onerror;\n\t    } else {\n\t      this.xhr.onreadystatechange = stateChange;\n\t    }\n\t\n\t    this.xhr.send(null);\n\t  };\n\t\n\t  /**\n\t   * Handle the unclean close behavior.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHRPolling.prototype.onClose = function () {\n\t    io.Transport.XHR.prototype.onClose.call(this);\n\t\n\t    if (this.xhr) {\n\t      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\n\t      try {\n\t        this.xhr.abort();\n\t      } catch(e){}\n\t      this.xhr = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Webkit based browsers show a infinit spinner when you start a XHR request\n\t   * before the browsers onload event is called so we need to defer opening of\n\t   * the transport until the onload event is called. Wrapping the cb in our\n\t   * defer method solve this.\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  XHRPolling.prototype.ready = function (socket, fn) {\n\t    var self = this;\n\t\n\t    io.util.defer(function () {\n\t      fn.call(self);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('xhr-polling');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t  /**\n\t   * There is a way to hide the loading indicator in Firefox. If you create and\n\t   * remove a iframe it will stop showing the current loading indicator.\n\t   * Unfortunately we can't feature detect that and UA sniffing is evil.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  var indicator = global.document && \"MozAppearance\" in\n\t    global.document.documentElement.style;\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports['jsonp-polling'] = JSONPPolling;\n\t\n\t  /**\n\t   * The JSONP transport creates an persistent connection by dynamically\n\t   * inserting a script tag in the page. This script tag will receive the\n\t   * information of the Socket.IO server. When new information is received\n\t   * it creates a new script tag for the new data stream.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport.xhr-polling}\n\t   * @api public\n\t   */\n\t\n\t  function JSONPPolling (socket) {\n\t    io.Transport['xhr-polling'].apply(this, arguments);\n\t\n\t    this.index = io.j.length;\n\t\n\t    var self = this;\n\t\n\t    io.j.push(function (msg) {\n\t      self._(msg);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Inherits from XHR polling transport.\n\t   */\n\t\n\t  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  JSONPPolling.prototype.name = 'jsonp-polling';\n\t\n\t  /**\n\t   * Posts a encoded message to the Socket.IO server using an iframe.\n\t   * The iframe is used because script tags can create POST based requests.\n\t   * The iframe is positioned outside of the view so the user does not\n\t   * notice it's existence.\n\t   *\n\t   * @param {String} data A encoded message.\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype.post = function (data) {\n\t    var self = this\n\t      , query = io.util.query(\n\t             this.socket.options.query\n\t          , 't='+ (+new Date) + '&i=' + this.index\n\t        );\n\t\n\t    if (!this.form) {\n\t      var form = document.createElement('form')\n\t        , area = document.createElement('textarea')\n\t        , id = this.iframeId = 'socketio_iframe_' + this.index\n\t        , iframe;\n\t\n\t      form.className = 'socketio';\n\t      form.style.position = 'absolute';\n\t      form.style.top = '0px';\n\t      form.style.left = '0px';\n\t      form.style.display = 'none';\n\t      form.target = id;\n\t      form.method = 'POST';\n\t      form.setAttribute('accept-charset', 'utf-8');\n\t      area.name = 'd';\n\t      form.appendChild(area);\n\t      document.body.appendChild(form);\n\t\n\t      this.form = form;\n\t      this.area = area;\n\t    }\n\t\n\t    this.form.action = this.prepareUrl() + query;\n\t\n\t    function complete () {\n\t      initIframe();\n\t      self.socket.setBuffer(false);\n\t    };\n\t\n\t    function initIframe () {\n\t      if (self.iframe) {\n\t        self.form.removeChild(self.iframe);\n\t      }\n\t\n\t      try {\n\t        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n\t        iframe = document.createElement('<iframe name=\"'+ self.iframeId +'\">');\n\t      } catch (e) {\n\t        iframe = document.createElement('iframe');\n\t        iframe.name = self.iframeId;\n\t      }\n\t\n\t      iframe.id = self.iframeId;\n\t\n\t      self.form.appendChild(iframe);\n\t      self.iframe = iframe;\n\t    };\n\t\n\t    initIframe();\n\t\n\t    // we temporarily stringify until we figure out how to prevent\n\t    // browsers from turning `\\n` into `\\r\\n` in form inputs\n\t    this.area.value = io.JSON.stringify(data);\n\t\n\t    try {\n\t      this.form.submit();\n\t    } catch(e) {}\n\t\n\t    if (this.iframe.attachEvent) {\n\t      iframe.onreadystatechange = function () {\n\t        if (self.iframe.readyState == 'complete') {\n\t          complete();\n\t        }\n\t      };\n\t    } else {\n\t      this.iframe.onload = complete;\n\t    }\n\t\n\t    this.socket.setBuffer(true);\n\t  };\n\t\n\t  /**\n\t   * Creates a new JSONP poll that can be used to listen\n\t   * for messages from the Socket.IO server.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype.get = function () {\n\t    var self = this\n\t      , script = document.createElement('script')\n\t      , query = io.util.query(\n\t             this.socket.options.query\n\t          , 't='+ (+new Date) + '&i=' + this.index\n\t        );\n\t\n\t    if (this.script) {\n\t      this.script.parentNode.removeChild(this.script);\n\t      this.script = null;\n\t    }\n\t\n\t    script.async = true;\n\t    script.src = this.prepareUrl() + query;\n\t    script.onerror = function () {\n\t      self.onClose();\n\t    };\n\t\n\t    var insertAt = document.getElementsByTagName('script')[0];\n\t    insertAt.parentNode.insertBefore(script, insertAt);\n\t    this.script = script;\n\t\n\t    if (indicator) {\n\t      setTimeout(function () {\n\t        var iframe = document.createElement('iframe');\n\t        document.body.appendChild(iframe);\n\t        document.body.removeChild(iframe);\n\t      }, 100);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Callback function for the incoming message stream from the Socket.IO server.\n\t   *\n\t   * @param {String} data The message\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype._ = function (msg) {\n\t    this.onData(msg);\n\t    if (this.isOpen) {\n\t      this.get();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * The indicator hack only works after onload\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype.ready = function (socket, fn) {\n\t    var self = this;\n\t    if (!indicator) return fn.call(this);\n\t\n\t    io.util.load(function () {\n\t      fn.call(self);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Checks if browser supports this transport.\n\t   *\n\t   * @return {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  JSONPPolling.check = function () {\n\t    return 'document' in global;\n\t  };\n\t\n\t  /**\n\t   * Check if cross domain requests are supported\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  JSONPPolling.xdomainCheck = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('jsonp-polling');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t\n\tif (true) {\n\t  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return io; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)(module)))\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright (c) 2010 David Durman\n\t//\n\t// The contents of this file are subject to the MIT License (the \"License\");\n\t// you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\t// http://opensource.org/licenses/MIT.\n\t//\n\t// This hierarchical state machine implementation has been inspired\n\t// by the QP active object framework, see http://www.state-machine.com/\n\t\n\t\n\t(function(root, factory){\n\t    \"use strict\";\n\t\n\t    if (true) {\n\t\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like enviroments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t\n\t    } else if (typeof define === 'function' && define.amd) {\n\t\n\t        // AMD. Register as an anonymous module.\n\t        define(factory);\n\t\n\t    } else {\n\t\n\t        // Browser globals (root is window)\n\t        root.Statechart = factory();\n\t    }\n\t\n\t}(this, function(){\n\t\n\t    \"use strict\";\n\t\n\t    var assert = function(assertion){\n\t        if (!assertion) {\n\t            throw new Error(\"Assertion failed.\");\n\t        }\n\t    };\n\t\n\t\n\t    // Statechart.\n\t    // -----------\n\t\n\t    // `myState` - the current state\n\t    // `mySource` - the source of the current transition\n\t\n\t    var Statechart = {\n\t\n\t        run: function(opt){\n\t            opt = opt || {};\n\t            this.debug = opt.debug ? opt.debug : function(){};\n\t            this.construct(this.initialState);\n\t            this.init(null);\n\t        },\n\t\n\t        construct: function(initialState){\n\t            this.myState = this.top();\n\t            this.mySource = this.state(\"Initial\");\n\t\n\t            // Initial pseudo-state\n\t            this.states.Initial = {\n\t                empty: function(){\n\t                    this.newInitialState(initialState);\n\t                }\n\t            };\n\t            var handled = function(){ return null; };\n\t\n\t            // TOP state\n\t            this.states.TOP = {\n\t                entry: handled,\n\t                exit:  handled,\n\t                init:  handled,\n\t                empty: handled\n\t            };\n\t            this.flatten();\n\t        },\n\t\n\t        // Trigger the initial transition and recursively enter the submachine of the top state.\n\t        // Must be called only once for a given Statechart before dispatching any events to it.\n\t        init: function(anEventOrNull){\n\t            assert(this.myState === this.top() && this.mySource !== null);\n\t            var s = this.myState;    // save top in temp\n\t            this.mySource.trigger(anEventOrNull);    // topmost initial transition\n\t            assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n\t            s = this.myState;\n\t            s.enter();\n\t            while (s.init() === null) {    // while init is handled (i.e. till we reach a leaf node)\n\t                assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n\t                s = this.myState;\n\t                s.enter();\n\t            }\n\t        },\n\t\n\t        state: function(stateOrName){\n\t            return (stateOrName && stateOrName instanceof QState) ? stateOrName : new QState(this, stateOrName);\n\t        },\n\t\n\t        top: function(stateOrName){\n\t            // create the top state only once and store it to an auxiliary property\n\t            return (this._topState || (this._topState = new QState(this, \"TOP\")));\n\t        },\n\t\n\t        currentState: function(){\n\t            return this.myState;\n\t        },\n\t\n\t        flatten: function(){\n\t            this.statesTable = this.statesTable || {};\n\t            this._flatten(this.states, this.top().name);\n\t        },\n\t\n\t        _flatten: function(states, parent){\n\t            if (!states) {\n\t                return;\n\t            }\n\t\n\t            for (var state in states) {\n\t                if (states.hasOwnProperty(state)) {\n\t                    this.statesTable[state] = states[state];\n\t                    this.statesTable[state].parent = parent;\n\t                    this._flatten(states[state].states, state);\n\t                }\n\t            }\n\t        },\n\t\n\t        selectState: function(stateName){\n\t            return this.statesTable[stateName];\n\t        },\n\t\n\t        dispatchEvent: function(anEvent, state, act){\n\t            act = act || state[anEvent.type];\n\t\n\t            // Action might also be an array in which case it is assumed that evaluating guards decides\n\t            // which target to enter.\n\t            if (act instanceof Array) {\n\t                for (var i = 0; i < act.length; i++) {\n\t                    this.dispatchEvent(anEvent, state, act[i]);\n\t                }\n\t            }\n\t\n\t            // @todo This is terrible edge case used just for more fancy Statechart representation\n\t            // It allows using \"MyState\": { init: \"MySubState\", ... } intead of\n\t            // \"MyState\": { init: function(){ this.newInitialState(\"MySubState\"); }, ... }\n\t            // In some cases the latter form can be useful for better control of the Statechart\n\t            if (anEvent.type === \"init\" && typeof act === \"string\") {\n\t                this.newInitialState(act);\n\t                return null; // handled\n\t            }\n\t\n\t            if (act instanceof Function){\n\t                act.call(this, anEvent.args);\n\t                return null;  // handled\n\t            } else if (act) {\n\t                // no guard at all or the guard condition is met\n\t                if (!act.guard || (act.guard && act.guard.call(this, anEvent.args))){\n\t                    if (act.action) {\n\t                        act.action.call(this, anEvent.args);\n\t                    }\n\t                    if (act.target) {\n\t                        this.newState(act.target);\n\t                    }\n\t                    return null;  // handled\n\t                }\n\t            } else {        // act is undefined (no handler in state for anEvent)\n\t                if (state === this.selectState(\"TOP\")) {\n\t                    this.handleUnhandledEvent(anEvent); // not-handled\n\t                    return null;    // handled (TOP state handles all events)\n\t                }\n\t            }\n\t            return this.state(state.parent); // not-handled\n\t        },\n\t\n\t        // Override this when needed.\n\t        handleUnhandledEvent: function(anEvent){\n\t            this.debug(\"Unhandled event: \" + anEvent.type);\n\t            return null;\n\t        },\n\t\n\t        // Traverse the state hierarchy starting from the currently active state myState.\n\t        // Advance up the state hierarchy (i.e., from substates to superstates), invoking all\n\t        // the state handlers in succession. At each level of state nesting, it intercepts the value\n\t        // returned from a state handler to obtain the superstate needed to advance to the next level.\n\t        dispatch: function(anEvent, args){\n\t            if (!anEvent || !(anEvent instanceof QEvent)) {\n\t                anEvent = new QEvent(anEvent, args);\n\t            }\n\t            this.mySource = this.myState;\n\t            while (this.mySource) {\n\t                this.mySource = this.mySource.trigger(anEvent);\n\t            }\n\t        },\n\t\n\t        // Performs dynamic transition. (macro Q_TRAN_DYN())\n\t        newState: function(aStateName){\n\t            this.transition(this.state(aStateName));\n\t        },\n\t\n\t        // Used by handlers only in response to the #init event. (macro Q_INIT())\n\t        // USAGE: return this.newInitialState(\"whatever\");\n\t        // @return null for convenience\n\t\n\t        newInitialState: function(aStateOrName){\n\t            this.myState = this.state(aStateOrName);\n\t            return null;\n\t        },\n\t\n\t        // Dynamic transition. (Q_TRAN_DYN())\n\t        transition: function(target){\n\t            assert(!target.equals(this.top()));\n\t\n\t            var entry = [];\n\t            var mySource = this.mySource;\n\t            var s = this.myState;\n\t\n\t            // exit all the nested states between myState and mySource\n\t            assert(s !== null);\n\t            assert(mySource !== null);\n\t            while (!s.equals(mySource)) {\n\t                s = s.exit() || s.superstate();\n\t            }\n\t\n\t            // check all seven possible source/target state combinations\n\t\n\t\t    entry.push(target);\n\t\n\t            // (a) mySource == target (self transition)\n\t            if (mySource.equals(target)) {\n\t                mySource.exit();\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            // (b) mySource == target.superstate (one level deep)\n\t            var p = target.superstate();\n\t            if (mySource.equals(p)) {\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            assert(mySource !== null);\n\t\n\t            // (c) mySource.superstate == target.superstate (most common - fsa)\n\t            var q = mySource.superstate();\n\t            if (q.equals(p)) {\n\t                mySource.exit();\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            // (d) mySource.superstate == target (one level up)\n\t            if (q.equals(target)) {\n\t                mySource.exit();\n\t                entry.pop();    // do not enter the LCA\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            // (e) mySource == target.superstate.superstate... hierarchy (many levels deep)\n\t\t    entry.push(p);\n\t            s = p.superstate();\n\t            while (s !== null) {\n\t                if (mySource.equals(s)) {\n\t                    return this.enterVia(target, entry);\n\t                }\n\t\n\t\t\tentry.push(s);\n\t                s = s.superstate();\n\t            }\n\t\n\t            // otherwise we're definitely exiting mySource\n\t            mySource.exit();\n\t\n\t            // entry array is complete, save its length to avoid computing it repeatedly\n\t            var entryLength = entry.length;\n\t\n\t            // (f) mySource.superstate == target.superstate.superstate... hierarchy\n\t            var lca;\n\t            for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n\t                if (q.equals(entry[lca])) {\n\t                    return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n\t                }\n\t            }\n\t\n\t            // (g) each mySource.superstate.superstate... for each target.superstate.superstate...\n\t            s = q;\n\t            while (s !== null) {\n\t                for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n\t                    if (s.equals(entry[lca])) {\n\t                        return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n\t                    }\n\t                }\n\t                s.exit();\n\t                s = s.superstate();\n\t            }\n\t        },\n\t\n\t        // tail of transition()\n\t        // We are in the LCA of mySource and target.\n\t        enterVia: function(target, entry){\n\t\n\t            // retrace the entry path in reverse order\n\t            var idx = entry.length;\n\t            while (idx > 0) {\n\t                idx--;\n\t                entry[idx].enter();\n\t            }\n\t\n\t            this.myState = target;\n\t            while (target.init() === null) {\n\t                // initial transition must go one level deep\n\t                assert(target.equals(this.myState.superstate()));\n\t                target = this.myState;\n\t                target.enter();\n\t            }\n\t        }\n\t    };\n\t\n\t    // QState.\n\t    // -------\n\t\n\t    function QState(fsm, name){\n\t        this.fsm = fsm;\n\t        this.name = name;\n\t    }\n\t\n\t    QState.prototype = {\n\t        equals: function(state){\n\t            return (this.name === state.name && this.fsm === state.fsm);\n\t        },\n\t\n\t        dispatchEvent: function(anEvent, state){\n\t            return this.fsm.dispatchEvent(anEvent, state);\n\t        },\n\t\n\t        trigger: function(anEvent){\n\t            var evt = anEvent || QEventEmpty;\n\t            var state = this.fsm.selectState(this.name);\n\t            return this.dispatchEvent(evt, state);\n\t        },\n\t\n\t        enter: function(){\n\t            this.fsm.debug(\"[\" + this.name + \"] enter\");\n\t            return this.trigger(QEventEntry);\n\t        },\n\t\n\t        exit: function(){\n\t            this.fsm.debug(\"[\" + this.name + \"] exit\");\n\t            return this.trigger(QEventExit);\n\t        },\n\t\n\t        init: function(){\n\t            this.fsm.debug(\"[\" + this.name + \"] init\");\n\t            return this.trigger(QEventInit);\n\t        },\n\t\n\t        // Answer my superstate. Default is to return fsm top state.\n\t        superstate: function(){\n\t            var superstate = this.trigger(QEventEmpty);\n\t            if (superstate && superstate instanceof QState) {\n\t                return superstate;\n\t            }\n\t            superstate = this.fsm.top();\n\t            if (this.name === superstate.name) {\n\t                return null;\n\t            }\n\t            return superstate;\n\t        }\n\t    };\n\t\n\t    // QEvent\n\t    // ------\n\t\n\t    function QEvent(type, args){\n\t        this.type = type;\n\t        this.args = args;\n\t    }\n\t\n\t    // these events are static, they do not carry any arguments\n\t    // -> create them only once\n\t    // moreover, they don't have to be exposed to the outer world\n\t    var QEventEntry = new QEvent(\"entry\");\n\t    var QEventExit = new QEvent(\"exit\");\n\t    var QEventInit = new QEvent(\"init\");\n\t    var QEventEmpty = new QEvent(\"empty\");\n\t\n\t\n\t    return Statechart;\n\t}));\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** respoke.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6c0b87596ac27ac556d9\n **/","module.exports = require('./respoke/respoke');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\n/*global Bugsnag: true*/\n/*jshint bitwise: false*/\n\n/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nlog.setLevel('warn');\n\nvar Q = require('q');\nQ.longStackSupport = true;\nQ.stackJumpLimit = 5;\nQ.longStackJumpLimit = 20;\nQ.stopUnhandledRejectionTracking();\n\nrequire('./deps/adapter');\n\n/**\n * `respoke` is a global static class.\n *\n *\n * Include the [latest version](https://cdn.respoke.io/respoke.min.js) or\n * [choose a previous release](http://cdn.respoke.io/list.html).\n *\n * Or use `npm install --save respoke`.\n *\n * Interact with Respoke primarily via [`respoke.Client`](respoke.Client.html):\n *\n *      var client = respoke.createClient();\n *\n *\n * **Development mode without brokered auth**\n *\n *      var client = respoke.createClient({\n *          appId: \"XXXXXXX-my-app-id-XXXXXX\",\n *          developmentMode: true,\n *          endpointId: \"billy\"\n *      });\n *\n *      client.listen('connect', function () {\n *          console.log('connected to respoke!');\n *      });\n *\n *      client.listen('error', function (err) {\n *          console.error('Connection to Respoke failed.', err);\n *      });\n *\n *      client.connect();\n *\n *\n * **Production mode with brokered auth**\n *\n *      var client = respoke.createClient();\n *\n *      client.listen('connect', function () {\n *          console.log('connected to respoke!');\n *      });\n *\n *      client.listen('error', function (err) {\n *          console.error('Connection to Respoke failed.', err);\n *      });\n *\n *      // Respoke auth token obtained by your server.\n *      // This is how you control who can connect to Respoke app.\n *      // See API docs for POST [base]/tokens\n *      var tokenId = \"XXXX-XXXX-brokered-auth-token-XXXXX\";\n *\n *      // connect to respoke with the token\n *      client.connect({\n *          token: tokenId\n *      });\n *\n *      // fetch a new token from your server if it expires\n *      client.listen('disconnect', function (evt) {\n *          // fetch another token from your server.\n *          var newTokenId = \"XXXX-XXXX-brokered-auth-token2-XXXXX\";\n *          client.connect({\n *              token: newTokenId\n *          });\n *      });\n *\n *\n *\n * ### Event listeners vs callback handlers\n *\n * There are two ways to attach listeners. It is highly recommended that you choose one pattern\n * and stick to it throughout your app.\n *\n * For every `event-name`, there is a corresponding callback `onEventName`.\n *\n * **With a listener**\n *\n *      var client = respoke.createClient();\n *      client.listen('connect', function () { });\n *\n * **or with a callback**\n *\n *      var client = respoke.createClient({\n *          // other options go here\n *\n *          onConnect: function () { }\n *      });\n *\n *\n * @namespace respoke\n * @class respoke\n * @global\n * @link https://cdn.respoke.io/respoke.min.js\n */\nvar respoke = module.exports = {\n    buildNumber: 'NO BUILD NUMBER',\n    streams: [],\n    instances: {}\n};\n\n/**\n * `\"v0.0.0\"`\n *\n * The respoke.min.js version.\n *\n * Past versions can be found at [cdn.respoke.io/list.html](http://cdn.respoke.io/list.html)\n * @type {string}\n */\nrespoke.version = respoke.buildNumber + \"\";\n\nrespoke.EventEmitter = require('./event');\nrespoke.Client = require('./client');\nrespoke.Presentable = require('./presentable');\nrespoke.Connection = require('./connection');\nrespoke.Endpoint = require('./endpoint');\nrespoke.TextMessage = require('./textMessage');\nrespoke.SignalingMessage = require('./signalingMessage');\nrespoke.Group = require('./group');\nrespoke.SignalingChannel = require('./signalingChannel');\nrespoke.DirectConnection = require('./directConnection');\nrespoke.PeerConnection = require('./peerConnection');\nrespoke.CallState = require('./callState');\nrespoke.Call = require('./call');\nrespoke.LocalMedia = require('./localMedia');\nrespoke.RemoteMedia = require('./remoteMedia');\nrespoke.log = log;\nrespoke.Q = Q;\n\nif (!window.skipBugsnag) {\n    // Use airbrake.\n    var airbrake = document.createElement('script');\n    var first = document.getElementsByTagName('script')[0];\n    first.parentNode.insertBefore(airbrake, first);\n\n    airbrake.src = \"https://ssljscdn.airbrake.io/0.3/airbrake.min.js\";\n    airbrake.setAttribute('data-airbrake-project-id', '98133');\n    airbrake.setAttribute('data-airbrake-project-key', 'cd3e085acc5e554658ebcdabd112a6f4');\n    airbrake.setAttribute('data-airbrake-project-environment-name', 'production');\n\n    airbrake.onload = function () {\n        window.onerror = function (message, file, line) {\n            //Only send errors from the respoke.js file to Airbrake\n            if (file.match(/respoke/)) {\n                Airbrake.push({error: {message: message, fileName: file, lineNumber: line}});\n            }\n        };\n    };\n}\n\n/**\n * This is one of two possible entry points for interating with the library.\n *\n * This method creates a new Client object\n * which represents your user's connection to your Respoke app.\n *\n * This method **automatically calls client.connect(params)** after the client is created.\n *\n * @static\n * @memberof respoke\n * @param {object} params Parameters to the respoke.Client constructor.\n * @param {string} [params.appId]\n * @param {string} [params.baseURL]\n * @param {string} [params.token]\n * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n * operation and will limit the services you will be able to use.\n * @param {boolean} [params.reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n * when a disconnect occurs.\n * @param {function} [params.onSuccess] - Success handler for this invocation of this method only.\n * @param {function} [params.onError] - Error handler for this invocation of this method only.\n * @param {function} [params.onJoin] - Callback for when this client's endpoint joins a group.\n * @param {function} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n * @param {function} [params.onMessage] - Callback for when any message is received from anywhere on the system.\n * @param {function} [params.onDisconnect] - Callback for Client disconnect.\n * @param {function} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n * @param {function} [params.onCall] - Callback for when this client's user receives a call.\n * @param {function} [params.onDirectConnection] - Callback for when this client's user receives a request for a\n * direct connection.\n * @param {boolean} [params.enableCallDebugReport=true] - Optional flag defaulting to true which allows sending\n * debugging information.\n * @returns {respoke.Client}\n */\nrespoke.connect = function (params) {\n    var client = respoke.Client(params);\n    client.connect(params);\n    return client;\n};\n\n/**\n * Getter for the respoke client.\n *\n * You can have more than one active client, so this method provides a way to retrieve a specific instance.\n *\n * @static\n * @memberof respoke\n * @param {number} id The Client ID.\n * @returns {respoke.Client}\n */\nrespoke.getClient = function (id) {\n    if (id === undefined) {\n        log.debug(\"Can't call getClient with no client ID.\", new Error().stack);\n    }\n    if (!respoke.instances[id]) {\n        log.debug(\"No client instance with id\", id);\n    }\n    return respoke.instances[id];\n};\n\n/**\n * This is one of two possible entry points for interating with the library.\n *\n * This method creates a new Client object which represents your user's connection to your Respoke app.\n *\n * It **does NOT automatically call the client.connect() method** after the client is created.\n *\n * The `params` argument is the same as `respoke.connect(params)`.\n *\n * @static\n * @memberof respoke\n * @param {object} params Parameters to respoke.Client - same as respoke.connect()\n * @returns {respoke.Client}\n */\nrespoke.createClient = function (params) {\n    var client;\n    params = params || {};\n    if (params.instanceId) {\n        client = respoke.getClient(params.instanceId);\n        if (client) {\n            return client;\n        }\n    }\n    return respoke.Client(params);\n};\n\n/**\n * Build a closure from a listener that will ensure the listener can only be called once.\n * @static\n * @private\n * @memberof respoke\n * @param {function} func\n * @return {function}\n */\nrespoke.once = function (func) {\n    return (function () {\n        var called = false;\n        return function () {\n            if (called === false) {\n                func.apply(null, arguments);\n                called = true;\n            }\n        };\n    })();\n};\n\n/**\n * @static\n * @private\n * @memberof respoke\n * @returns {number}\n */\nrespoke.makeGUID = function () {\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = new Array(36);\n    var rnd = 0;\n    var r;\n    for (var i = 0; i < 36; i += 1) {\n        if (i === 8 || i === 13 ||  i === 18 || i === 23) {\n            uuid[i] = '-';\n        } else if (i === 14) {\n            uuid[i] = '4';\n        } else {\n            if (rnd <= 0x02) {\n                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\n            }\n            r = rnd & 0xf;\n            rnd = rnd >> 4;\n            uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n        }\n    }\n    return uuid.join('');\n};\n\n/**\n * This method is used internally to attach handlers to promises that are returned by many methods in the library.\n * It's not recommended that this method be used by developers and apps.\n * @private\n * @static\n * @memberof respoke\n * @param {Promise} promise\n * @param {function} onSuccess\n * @param {function} onError\n * @returns {Promise|undefined}\n */\nrespoke.handlePromise = function (promise, onSuccess, onError) {\n    var returnUndef = false;\n    if (onSuccess || onError) {\n        returnUndef = true;\n    }\n\n    onSuccess = typeof onSuccess === 'function' ? onSuccess : function () {};\n    onError = typeof onError === 'function' ? onError : function () {};\n    promise.done(onSuccess, onError);\n    return (returnUndef ? undefined : promise);\n};\n\n/**\n * Empty base class. Use params.that (if exists) for the base object, but delete it from the instance.  Copy all\n * params that were passed in onto the base object. Add the class name.\n * @class respoke.Class\n * @classdesc Empty base class.\n * @constructor\n * @private\n */\nrespoke.Class = function (params) {\n    params = params || {};\n    var that = params.that || {};\n    var client = params.client;\n\n    that.className = 'respoke.Class';\n    delete params.that;\n    delete that.client;\n\n    Object.keys(params).forEach(function copyParam(name) {\n        that[name] = params[name];\n    });\n\n    return that;\n}; // end of respoke.Class\n\n/**\n * Does the browser support `UserMedia`?\n * @static\n * @memberof respoke\n * @returns {boolean}\n */\nrespoke.hasUserMedia = function () {\n    return (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) instanceof Function;\n};\n\n/**\n * Does the browser support `RTCPeerConnection`?\n * @static\n * @memberof respoke\n * @returns {boolean}\n */\nrespoke.hasRTCPeerConnection = function () {\n    return (window.RTCPeerConnection || window.webkitRTCPeerConnection ||\n            window.mozRTCPeerConnection) instanceof Function;\n};\n\n/**\n * Does the browser support `WebSocket`?\n * @static\n * @memberof respoke\n * @returns {boolean}\n */\nrespoke.hasWebsocket = function () {\n    return (window.WebSocket || window.webkitWebSocket || window.MozWebSocket) instanceof Function;\n};\n\n/**\n * Clone an object.\n * @static\n * @memberof respoke\n * @param {Object} source - The object to clone\n * @returns {Object}\n */\nrespoke.clone = function (source) {\n    if (source) {\n        return JSON.parse(JSON.stringify(source));\n    }\n    return source;\n};\n\n/**\n * Compares two objects for equality\n * @static\n * @memberof respoke\n * @param {Object} a\n * @param {Object} b\n * @returns {boolean}\n */\nrespoke.isEqual = function (a, b) {\n    var aKeys;\n\n    //check if arrays\n    if (a.hasOwnProperty('length') && b.hasOwnProperty('length') && a.splice && b.splice) {\n        if (a.length !== b.length) {\n            //short circuit if arrays are different length\n            return false;\n        }\n\n        for (var i = 0; i < a.length; i += 1) {\n            if (!respoke.isEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    if (typeof a === 'object' && typeof b === 'object') {\n        aKeys = Object.keys(a);\n        for (var i = 0; i < aKeys.length; i += 1) {\n            if (!respoke.isEqual(a[aKeys[i]], b[aKeys[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return a === b;\n};\n\n/*\n * Does the sdp indicate an audio stream?\n * @static\n * @memberof respoke\n * @params {RTCSessionDescription}\n * @returns {boolean}\n */\nrespoke.sdpHasAudio = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasAudio called with no parameters.\");\n    }\n    return sdp.indexOf('m=audio') !== -1;\n};\n\n/**\n * Does the sdp indicate a video stream?\n * @static\n * @memberof respoke\n * @params {RTCSessionDescription}\n * @returns {boolean}\n */\nrespoke.sdpHasVideo = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasVideo called with no parameters.\");\n    }\n    return sdp.indexOf('m=video') !== -1;\n};\n\n/**\n * Does the sdp indicate a data channel?\n * @static\n * @memberof respoke\n * @params {RTCSessionDescription}\n * @returns {boolean}\n */\nrespoke.sdpHasDataChannel = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasDataChannel called with no parameters.\");\n    }\n    return sdp.indexOf('m=application') !== -1;\n};\n\n/**\n * Does the sdp indicate an audio stream?\n * @static\n * @memberof respoke\n * @params {MediaConstraints}\n * @returns {boolean}\n */\nrespoke.constraintsHasAudio = function (constraints) {\n    if (!constraints) {\n        throw new Error(\"respoke.constraintsHasAudio called with no parameters.\");\n    }\n    return (constraints.audio === true);\n};\n\n/**\n * Does the constraints indicate a video stream?\n * @static\n * @memberof respoke\n * @params {MediaConstraints}\n * @returns {boolean}\n */\nrespoke.constraintsHasVideo = function (constraints) {\n    if (!constraints) {\n        throw new Error(\"respoke.constraintsHasVideo called with no parameters.\");\n    }\n    return (constraints.video === true || typeof constraints.video === 'object');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/respoke.js\n ** module id = 1\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar respoke = require('./respoke');\nvar log = require('loglevel');\n\n/**\n * A generic class for emitting and listening to events.\n *\n * @class respoke.EventEmitter\n * @inherits respoke.Class\n * @constructor\n * @param {object} params\n * @param {string} params.instanceId\n * @returns {respoke.EventEmitter}\n */\nvar EventEmitter = module.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = respoke.Class(params);\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.EventEmitter\n     * @name className\n     * @type {string}\n     * @private\n     */\n    that.className = 'respoke.EventEmitter';\n\n    /**\n     * @memberof! respoke.EventEmitter\n     * @name eventList\n     * @private\n     * @type {object}\n     */\n    var eventList = {};\n\n    /**\n     * Add a listener that will only be called once to an object.  This method adds the given listener to the given\n     * event in the case that the same\n     * listener is not already registered to this event and the listener is a function.  The third argument 'isInternal'\n     * is used only internally by the library to indicate that this listener is a library-used listener and should not\n     * count when we are trying to determine if an event has listeners placed by the developer.\n     *\n     *     client.once('connect', function (evt) {\n     *         console.log(\"This is the first time we connected.\");\n     *     });\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.listen\n     * @param {string} eventType - A developer-specified string identifying the event.\n     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is fire.\n     * @param {boolean} [isInternal] - A flag to indicate this listener was added by the library. This parameter should\n     * not be used by developers who are using the library, only by developers who are working on the library itself.\n     */\n    that.once = function (eventType, listener, isInternal) {\n        var string = listener.toString();\n        listener = respoke.once(listener);\n        listener.toString = function () { return string; }\n        listener.once = true;\n        that.listen(eventType, listener, isInternal);\n    };\n\n    /**\n     * Add a `listener` function to an object.\n     * \n     * This method adds the `listener` to the event `eventName`.\n     * \n     * If an identical listener already registered to this event, it will **not** be added.\n     * \n     * ##### Example of adding an event listener.\n     *\n     *     client.listen('connect', function (evt) {\n     *         console.log(\"We've connected!\", evt);\n     *     });\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.listen\n     * @param {string} eventType - The name of the event.\n     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is\n     * fired.\n     * @arg {boolean} isInternal - Internal use only. A flag to indicate this listener was \n     * added by the library. This parameter should not be used by developers who are using\n     * the library, only by developers who are working on the library itself.\n     */\n    that.listen = function (eventType, listener, isInternal) {\n        if (listener === undefined) {\n            return;\n        }\n        var invalidEventType = typeof eventType !== 'string' || !eventType;\n        var invalidListener = typeof listener !== 'function';\n        if (invalidEventType || invalidListener) {\n            log.error(\"Invalid request to add event listener to\", eventType, listener);\n            return;\n        }\n\n        eventList[eventType] = eventList[eventType] || [];\n        listener.isInternal = !!isInternal; // boolify\n\n        var toString = function (fn) {\n            return fn.toString();\n        };\n        var isNotAlreadyAdded = eventList[eventType].map(toString).indexOf(listener.toString()) === -1;\n\n        if (isNotAlreadyAdded) {\n            eventList[eventType].push(listener);\n        } else {\n            log.warn(\"Not adding duplicate listener to\", eventType, listener);\n        }\n    };\n\n    /**\n     * Remove a listener from an object. If no eventType is specified, all eventTypes will be\n     * cleared. If an eventType is specified but no listener is specified, all listeners will be\n     * removed from the specified eventType.  If a listener is also specified, only that listener\n     * will be removed.\n     *\n     *     client.ignore('connect', connectHandler);\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.ignore\n     * @param {string} [eventType] - An optional developer-specified string identifying the event.\n     * @param {function} [listener] - An optional function to remove from the specified event.\n     */\n    that.ignore = function (eventType, listener) {\n        // Remove all events from this object\n        if (eventType === undefined) {\n            eventList = {};\n            return;\n        }\n\n        // Remove all listeners from this event.\n        if (listener === undefined || !eventList[eventType]) {\n            eventList[eventType] = [];\n            return;\n        }\n\n        // Remove only one listener from this event.\n        for (var i = eventList[eventType].length - 1; i >= 0; i -= 1) {\n            if (listener === eventList[eventType][i]) {\n                eventList[eventType].splice(i, 1);\n                return;\n            }\n        }\n    };\n\n    /**\n     * Trigger an event on an object. All listeners for the specified eventType will be called.\n     * Listeners will be bound to the object ('this' will refer to the object), and additional\n     * arguments to fire() will be passed into each listener.\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.fire\n     * @param {string} eventType - A developer-specified string identifying the event to fire.\n     * @param {string|number|object|array} evt - Any number of optional parameters to be passed to\n     * the listener\n     * @private\n     */\n    that.fire = function (eventType, evt) {\n        var args = null;\n        var count = 0;\n        var toRemove = [];\n\n        evt = evt || {};\n        evt.name = eventType;\n        evt.target = that;\n\n        if (!eventType) {\n            return;\n        }\n\n        if (!eventList[eventType]) {\n            log.debug(\"fired \" + that.className + \"#\" + eventType + \" 0 listeners called with params\", evt);\n            return;\n        }\n\n        for (var i = 0; i < eventList[eventType].length; i += 1) {\n            var listener = eventList[eventType][i];\n            if (typeof listener === 'function') {\n                setTimeout(listenerBuilder(listener, evt, eventType));\n\n                count += 1;\n                if (listener.once === true) {\n                    toRemove.push(i);\n                }\n            }\n        }\n\n        for (var i = (toRemove.length - 1); i >= 0; i -= 1) {\n            eventList[eventType].splice(toRemove[i], 1);\n        }\n\n        log.debug(\"fired \" + that.className + \"#\" + eventType + \" \" + count + \" listeners called with params\", evt);\n    };\n\n    function listenerBuilder(listener, evt, eventType) {\n        return function () {\n            try {\n                listener.call(that, evt);\n            } catch (e) {\n                log.error('Error in ' + that.className + \"#\" + eventType, e.message, e.stack);\n            }\n        };\n    }\n\n    /**\n     * Determine if an object has had any listeners registered for a given event outside the library. This method\n     * checks for the isInternal flag on each listener and doesn't count it toward an event being listened to. This\n     * method is used in the library to handle situations where an action is needed if an event won't be acted on.\n     * For instance, if a call comes in for the logged-in user, but the developer isn't listening to\n     * {respoke.Client#call}, we'll need to reject the call immediately.\n     *\n     *     if (client.hasListeners('call')) {\n     *         // already handled!\n     *     }\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.hasListeners\n     * @param {string} eventType - The name of the event\n     * @returns {boolean} Whether this event has any listeners that are external to this library.\n     */\n    that.hasListeners = function (eventType) {\n        if (eventType === undefined) {\n            throw new Error(\"Missing required parameter event type.\");\n        }\n\n        if (!eventList[eventType]) {\n            return false;\n        }\n\n        return !eventList[eventType].every(function eachListener(listener) {\n            return listener.isInternal;\n        });\n    };\n\n    return that;\n}; // End respoke.EventEmitter\n/**\n * @callback respoke.EventEmitter.eventListener\n * @param {respoke.Event} evt\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/event.js\n ** module id = 2\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');\n\n/**\n * `respoke.Client` is the top-level interface to the API. Interacting with Respoke should be done using\n * a `respoke.Client` instance.\n *\n * There are two ways to get a client:\n *\n *      var client = respoke.createClient(clientParams);\n *      // . . . set stuff up, then . . .\n *      client.connect(connectParams);\n *\n * or\n *\n *      // creates client and connects to Respoke all at once\n *      var client = respoke.connect(allParams);\n *\n * A client does the following things:\n *\n * 1. authentication with the Respoke API\n * 1. receives server-side app-specific information\n * 1. tracks connections and presence\n * 1. provides methods to get and interact with tracked entities (like groups and endpoints)\n * 1. stores default settings for calls and direct connections\n * 1. automatically reconnects to the API when network activity is lost*\n *\n * *If `developmentMode` is set to true. If not using `developmentMode`, disable automatic\n * reconnect by sending `reconnect: false` and listening to the Client's disconnect event\n * to fetch a new brokered auth token, then call `client.connect()` with the new token.\n *\n * @class respoke.Client\n * @constructor\n * @augments respoke.Presentable\n * @param {object} params\n * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n * respoke.connect, respoke.createClient, or to client.connect.\n * @param {string} [params.token] - The endpoint's authentication token.\n * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n * endpoint. This is only used when `developmentMode` is set to `true`.\n * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n * operation and will limit the services you will be able to use.\n * @param {string|number|object|Array} [params.presence=unavailable] The initial presence to set once connected.\n * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n * when a disconnect occurs.\n * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is received\n * from anywhere on the system.\n * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect.\n * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client's user receives a call.\n * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this client's user\n * receives a request for a direct connection.\n * @returns {respoke.Client}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Client\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId || respoke.makeGUID();\n    params.instanceId = instanceId;\n    var that = respoke.Presentable(params);\n    respoke.instances[instanceId] = that;\n    delete that.instanceId;\n    that.connectTries = 0;\n    /**\n     * A name to identify this class\n     * @memberof! respoke.Client\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Client';\n    /**\n     * @memberof! respoke.Client\n     * @name host\n     * @type {string}\n     * @private\n     */\n    var host = window.location.hostname;\n    /**\n     * @memberof! respoke.Client\n     * @name port\n     * @type {number}\n     * @private\n     */\n    var port = window.location.port;\n    /**\n     * A simple POJO to store some methods we will want to override but reference later.\n     * @memberof! respoke.Client\n     * @name superClass\n     * @private\n     * @type {object}\n     */\n    var superClass = {\n        setPresence: that.setPresence\n    };\n    /**\n     * A container for baseURL, token, and appId so they won't be accidentally viewable in any JavaScript debugger.\n     * @memberof! respoke.Client\n     * @name clientSettings\n     * @type {object}\n     * @private\n     * @property {string} [baseURL] - the URL of the cloud infrastructure's REST API.\n     * @property {string} [token] - The endpoint's authentication token.\n     * @property {string} [appId] - The id of your Respoke app.\n     * @property {string} [endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @property {boolean} [developmentMode=false] - Indication to obtain an authentication token from the service.\n     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n     * operation and will limit the services you will be able to use.\n     * @property {boolean} [reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n     * when a disconnect occurs.\n     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n     * @property {respoke.Client.onClientMessage} [onMessage] - Callback for when any message is received\n     * from anywhere on the system.\n     * @property {respoke.Client.onConnect} [onConnect] - Callback for Client connect.\n     * @property {respoke.Client.onDisconnect} [onDisconnect] - Callback for Client disconnect.\n     * @property {respoke.Client.onReconnect} [onReconnect] - Callback for Client reconnect. Not Implemented.\n     * @property {respoke.Client.onCall} [onCall] - Callback for when this client receives a call.\n     * @property {respoke.Client.onDirectConnection} [onDirectConnection] - Callback for when this client\n     * receives a request for a direct connection.\n     * @property {boolean} enableCallDebugReport=true - Upon finishing a call, should the client send debugging\n     * information to the API? Defaults to `true`.\n     */\n    var clientSettings = {};\n\n    delete that.appId;\n    delete that.baseURL;\n    delete that.developmentMode;\n    delete that.token;\n    delete that.resolveEndpointPresence;\n\n    /**\n     * Internal list of known groups.\n     * @memberof! respoke.Client\n     * @name groups\n     * @type {Array<respoke.Group>}\n     * @private\n     */\n    var groups = [];\n    /**\n     * Internal list of known endpoints.\n     * @memberof! respoke.Client\n     * @name endpoints\n     * @type {Array<respoke.Endpoint>}\n     * @private\n     */\n    var endpoints = [];\n    /**\n     * Array of calls in progress, made accessible for informational purposes only.\n     * **Never modify this array directly.**\n     *\n     * @memberof! respoke.Client\n     * @name calls\n     * @type {array}\n     */\n    that.calls = [];\n    log.debug(\"Client ID is \", instanceId);\n\n    /**\n     * @memberof! respoke.Client\n     * @name signalingChannel\n     * @type {respoke.SignalingChannel}\n     * @private\n     */\n    var signalingChannel = respoke.SignalingChannel({\n        instanceId: instanceId,\n        clientSettings: clientSettings\n    });\n\n    /**\n     * Save parameters of the constructor or client.connect() onto the clientSettings object\n     * @memberof! respoke.Client\n     * @method respoke.saveParameters\n     * @param {object} params\n     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n     * respoke.connect, respoke.createClient, or to client.connect.\n     * @param {string} [params.token] - The endpoint's authentication token.\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n     * to decide which Connection's presence gets precedence for the Endpoint.\n     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n     * operation and will limit the services you will be able to use.\n     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n     * when a disconnect occurs.\n     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n     * a group.\n     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n     * received from anywhere on the system.\n     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n     * client receives a request for a direct connection.\n     * @private\n     */\n    function saveParameters(params) {\n        Object.keys(params).forEach(function eachParam(key) {\n            if (['onSuccess', 'onError', 'reconnect'].indexOf(key) === -1 && params[key] !== undefined) {\n                clientSettings[key] = params[key];\n            }\n        });\n\n        clientSettings.developmentMode = !!clientSettings.developmentMode;\n        clientSettings.enableCallDebugReport = typeof clientSettings.enableCallDebugReport === 'boolean' ?\n            clientSettings.enableCallDebugReport : true;\n\n        if (typeof params.reconnect !== 'boolean') {\n            clientSettings.reconnect = typeof params.developmentMode === 'boolean' ? params.developmentMode : false;\n        } else {\n            clientSettings.reconnect = !!params.reconnect;\n        }\n    }\n    saveParameters(params);\n\n    /**\n     * Connect to the Respoke infrastructure and authenticate using `params.token`.\n     *\n     * After `connect`, the app auth session token is stored so it can be used in API requests.\n     *\n     * This method attaches quite a few event listeners for things like group joining and connection status changes.\n     *\n     * #### Usage\n     *\n     *      client.connect({\n     *          appId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\",\n     *          token: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\", // if not developmentMode\n     *          developmentMode: false || true,\n     *          // if developmentMode, otherwise your server will set endpointId\n     *          endpointId: \"billy\"\n     *      });\n     *      client.listen(\"connect\", function () { } );\n     *\n     *\n     * If no `params.token` is given and `developmentMode` is set to true, it will attempt to obtain a token\n     * automatically. You must set an `endpointId`.\n     *\n     *\n     * #### App auth session token expiration\n     *\n     * If `params.reconnect` is set to true (which it is by default for `developmentMode`), the `client`\n     * will attempt to keep reconnecting each time the app auth session expires.\n     *\n     * If not using `developmentMode`, automatic reconnect will be disabled. You will need to\n     * listen to the Client's `disconnect` event to fetch a new brokered auth token and call\n     * `client.connect()` with the new token.\n     *\n     *      client.listen('disconnect', function () {\n     *\n     *          // example method you implemented to get a new token from your server\n     *          myServer.getNewRespokeAccessToken(function (newToken) {\n     *              // reconnect with respoke.Client\n     *              client.connect({ token: newToken });\n     *          });\n     *\n     *      });\n     *\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.connect\n     * @param {object} params\n     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n     * respoke.connect, respoke.createClient, or to client.connect.\n     * @param {string} [params.token] - The endpoint's authentication token.\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n     * to decide which Connection's presence gets precedence for the Endpoint.\n     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n     * operation and will limit the services you will be able to use.\n     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n     * when a disconnect occurs.\n     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n     * a group.\n     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n     * received from anywhere on the system.\n     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n     * client receives a request for a direct connection.\n     * @returns {Promise|undefined}\n     * @fires respoke.Client#connect\n     */\n    that.connect = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n        log.debug('Client.connect');\n        that.connectTries += 1;\n\n        saveParameters(params);\n\n        that.endpointId = clientSettings.endpointId;\n        promise = actuallyConnect(params);\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        promise.then(function successHandler() {\n            /**\n             * This event is fired the first time the library connects to the cloud infrastructure.\n             * @event respoke.Client#connect\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            that.fire('connect');\n\n            /**\n             * This event fires only when the initial `connect` fails.\n             *\n             * @ignore **This comment is for documentation purposes**, since #error bubbles\n             * up from other classes, but it should show on `respoke.Client` docs.\n             *\n             * @event respoke.Client#error\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n        });\n        return retVal;\n    };\n\n    /**\n     * This function contains the meat of the connection, the portions which can be repeated again on reconnect.\n     *\n     * When `reconnect` is true, this function will be added in an event listener to the Client#disconnect event.\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.Client\n     * @method respoke.Client.actuallyConnect\n     * @private\n     * @param {object} params\n     * @param {connectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    function actuallyConnect(params) {\n        params = params || {};\n        var deferred = Q.defer();\n\n        if (!clientSettings.token &&\n                (!clientSettings.appId || !clientSettings.endpointId || clientSettings.developmentMode !== true)) {\n            deferred.reject(new Error(\"Must pass either endpointID & appId & developmentMode=true, or a token, \" +\n                \"to client.connect().\"));\n            return deferred.promise;\n        }\n\n        signalingChannel.open({\n            actuallyConnect: actuallyConnect,\n            endpointId: that.endpointId,\n            token: clientSettings.token\n        }).then(function successHandler() {\n            return signalingChannel.authenticate();\n        }).done(function successHandler() {\n            // set initial presence for the connection\n            if (clientSettings.presence) {\n                that.setPresence({presence: clientSettings.presence});\n            }\n\n            /*\n             * These rely on the EventEmitter checking for duplicate event listeners in order for these\n             * not to be duplicated on reconnect.\n             */\n\n            /**\n             * This event provides notification for when an incoming call is being received.  If the user wishes\n             * to allow the call, `evt.call.answer()`.\n             * @event respoke.Client#call\n             * @type {respoke.Event}\n             * @property {respoke.Call} call\n             * @property {respoke.Endpoint} endpoint\n             * @property {string} name - The event name.\n             * @property {respoke.Client} target\n             */\n            that.listen('call', clientSettings.onCall);\n            /**\n             * This event is fired when the local end of the directConnection is available. It still will not be\n             * ready to send and receive messages until the 'open' event fires.\n             * @event respoke.Client#direct-connection\n             * @type {respoke.Event}\n             * @property {respoke.DirectConnection} directConnection\n             * @property {respoke.Endpoint} endpoint\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.listen('direct-connection', clientSettings.onDirectConnection);\n            that.listen('join', clientSettings.onJoin);\n            /**\n             * This event is fired every time the client leaves a group.\n             * @event respoke.Client#leave\n             * @type {respoke.Event}\n             * @property {respoke.Group} group\n             * @property {string} name - the event name.\n             */\n            that.listen('leave', clientSettings.onLeave);\n            /**\n             * A generic message handler when a message was received by the client.\n             *\n             * @event respoke.Client#message\n             * @type {respoke.Event}\n             * @property {string} name - The event name.\n             * @property {respoke.Endpoint} endpoint - If the message was private, this is the Endpoint who sent it.\n             * @property {respoke.Group} group - If the message was to a group, this is the group.\n             * @property {respoke.TextMessage} message - The generic message object.\n             * @property {string} message.connectionId\n             * @property {string} message.endpointId\n             * @property {string} message.message - Message body text.\n             * @property {respoke.Client} target\n             */\n            that.listen('message', clientSettings.onMessage);\n            that.listen('connect', clientSettings.onConnect);\n            /**\n             * Client has disconnected from Respoke.\n             *\n             * @event respoke.Client#disconnect\n             * @type {respoke.Event}\n             * @property {string} name - The event name.\n             * @property {respoke.Client} target\n             */\n            that.listen('disconnect', clientSettings.onDisconnect);\n            that.listen('disconnect', function () {\n                that.calls.forEach(function (call) {\n                    call.hangup({signal: false});\n                });\n            }, true);\n            /**\n             * Client has reconnected to Respoke.\n             *\n             * @event respoke.Client#reconnect\n             * @type {respoke.Event}\n             * @property {string} name - The event name.\n             * @property {respoke.Client} target\n             */\n            that.listen('reconnect', clientSettings.onReconnect);\n\n            log.info('logged in as ' + that.endpointId, that);\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n            log.error(err.message, err.stack);\n        });\n\n        return deferred.promise;\n    }\n\n    /**\n     * Disconnect from the Respoke infrastructure, leave all groups, invalidate the token, and disconnect the websocket.\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.Client\n     * @method respoke.Client.disconnect\n     * @returns {Promise|undefined}\n     * @param {object} params\n     * @param {disconnectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @fires respoke.Client#disconnect\n     */\n    that.disconnect = function (params) {\n        // TODO: also call this on socket disconnect\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            deferred.reject(e);\n            return retVal;\n        }\n\n        var leaveGroups = groups.map(function eachGroup(group) {\n            group.leave();\n        });\n\n        Q.all(leaveGroups).fin(function successHandler() {\n            return signalingChannel.close();\n        }).fin(function finallyHandler() {\n            that.presence = 'unavailable';\n            endpoints = [];\n            groups = [];\n            /**\n             * This event is fired when the library has disconnected from the cloud infrastructure.\n             * @event respoke.Client#disconnect\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            that.fire('disconnect');\n            deferred.resolve();\n        }).done();\n\n        return retVal;\n    };\n\n    /**\n     * Set the presence for this client.\n     *\n     * The value of presence can be a string, number, object, or array - in any format -\n     * depending on the needs of your application. The only requirement is that\n     * `JSON.stringify()` must work (no circular references).\n     *\n     *      var myPresence = 'At lunch'\n     *                      || 4\n     *                      || { status: 'Away', message: 'At lunch' }\n     *                      || ['Away', 'At lunch'];\n     *\n     *      client.setPresence({\n     *          presence: myPresence,\n     *          onSuccess: function (evt) {\n     *              // successfully updated my presence\n     *          }\n     *      });\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.setPresence\n     * @param {object} params\n     * @param {string|number|object|array} params.presence\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @overrides Presentable.setPresence\n     * @return {Promise|undefined}\n     */\n    that.setPresence = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        log.info('sending my presence update ' + params.presence);\n\n        promise = signalingChannel.sendPresence({\n            presence: params.presence\n        });\n\n        promise.then(function successHandler(p) {\n            superClass.setPresence(params);\n            clientSettings.presence = params.presence;\n        });\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };\n\n    /**\n     * Get the Call with the endpoint specified.\n     *\n     *     // hang up on chad\n     *     var call = client.getCall({\n     *         endpointId: 'chad'\n     *     });\n     *\n     *     if (call) {\n     *         call.hangup()\n     *     }\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getCall\n     * @param {object} params\n     * @param {string} [params.id] - Call ID.\n     * @param {string} [params.endpointId] - Endpoint ID. Warning: If you pass only the endpointId, this method\n     * will just return the first call that matches. If you are placing multiple calls to the same endpoint,\n     * pass in the call ID, too.\n     * @param {boolean} params.create - whether or not to create a new call if the specified endpointId isn't found\n     * @returns {respoke.Call}\n     */\n    that.getCall = function (params) {\n        var call = null;\n        var endpoint = null;\n        var methods = {\n            did: \"startPhoneCall\",\n            web: \"startCall\",\n            sip: \"startSIPCall\"\n        };\n        params.fromType = params.fromType || \"web\";\n\n        that.calls.every(function findCall(one) {\n            if (params.id && one.id === params.id) {\n                call = one;\n                return false;\n            }\n\n            if (!params.id && params.endpointId && one.remoteEndpoint.id === params.endpointId) {\n                call = one;\n                return false;\n            }\n            return true;\n        });\n\n        if (call === null && params.create === true) {\n            try {\n                call = that[methods[params.fromType]]({\n                    id: params.id,\n                    number: params.fromType === \"did\" ? params.endpointId : undefined,\n                    uri: params.fromType === \"sip\" ? params.endpointId : undefined,\n                    endpointId: params.fromType === \"web\" ? params.endpointId : undefined,\n                    caller: false,\n                    toType: params.fromType,\n                    fromType: \"web\"\n                });\n            } catch (e) {\n                log.error(\"Couldn't create Call.\", e.message, e.stack);\n            }\n        }\n        return call;\n    };\n\n    /**\n     * Add the call to internal record-keeping.\n     * @memberof! respoke.Client\n     * @method respoke.Client.addCall\n     * @param {object} evt\n     * @param {respoke.Call} evt.call\n     * @param {respoke.Endpoint} evt.endpoint\n     * @private\n     */\n    function addCall(evt) {\n        log.debug('addCall');\n        if (!evt.call) {\n            throw new Error(\"Can't add call without a call parameter.\");\n        }\n        if (that.calls.indexOf(evt.call) === -1) {\n            that.calls.push(evt.call);\n        }\n\n        evt.call.listen('hangup', function () {\n            removeCall({call: evt.call});\n        });\n    }\n\n    /**\n     * Remove the call or direct connection from internal record-keeping.\n     * @memberof! respoke.Client\n     * @method respoke.Client.removeCall\n     * @param {object} evt\n     * @param {respoke.Call} evt.target\n     * @private\n     */\n    function removeCall(evt) {\n        var match = 0;\n        if (!evt.call) {\n            throw new Error(\"Can't remove call without a call parameter.\");\n        }\n\n        // Loop backward since we're modifying the array in place.\n        for (var i = that.calls.length - 1; i >= 0; i -= 1) {\n            if (that.calls[i].id === evt.call.id) {\n                that.calls.splice(i, 1);\n                match += 1;\n            }\n        }\n\n        if (match !== 1) {\n            log.warn(\"Something went wrong.\", match, \"calls were removed!\");\n        }\n    }\n\n    /**\n     * Convenience method for setting presence to `\"available\"`.\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.setOnline\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=available] - The presence to set.\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.setOnline = function (params) {\n        var promise;\n\n        params = params || {};\n        params.presence = params.presence || 'available';\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        return that.setPresence(params);\n    };\n\n    /**\n     * Convenience method for setting presence to `\"unavailable\"`.\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.setOffline\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=unavailable] - The presence to set.\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.setOffline = function (params) {\n        var promise;\n\n        params = params || {};\n        params.presence = params.presence || 'unavailable';\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        return that.setPresence(params);\n    };\n\n    /**\n     * Send a message to an endpoint.\n     *\n     *     client.sendMessage({\n     *         endpointId: 'dan',\n     *         message: \"Jolly good.\"\n     *     });\n     *\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.Client\n     * @method respoke.Client.sendMessage\n     * @param {object} params\n     * @param {string} params.endpointId - The endpoint id of the recipient.\n     * @param {string} [params.connectionId] - The optional connection id of the receipient. If not set, message will be\n     * broadcast to all connections for this endpoint.\n     * @param {string} params.message - a string message.\n     * @param {sendHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        var promise;\n        var retVal;\n        var endpoint;\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n        endpoint = that.getEndpoint({\n            skipPresence: true,\n            id: params.endpointId\n        });\n        delete params.endpointId;\n        return endpoint.sendMessage(params);\n    };\n\n    /**\n     * Place an audio and/or video call to an endpoint.\n     *\n     *     // defaults to video when no constraints are supplied\n     *     client.startCall({\n     *         endpointId: 'erin',\n     *         onConnect: function (evt) { },\n     *         onLocalMedia: function (evt) { }\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.startCall\n     * @param {object} params\n     * @param {string} params.endpointId - The id of the endpoint that should be called.\n     * @param {RTCConstraints} [params.constraints]\n     * @param {string} [params.connectionId]\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote video attached to it.\n     * @return {respoke.Call}\n     */\n    that.startCall = function (params) {\n        var promise;\n        var retVal;\n        var endpoint;\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        endpoint = that.getEndpoint({\n            skipPresence: true,\n            id: params.endpointId\n        });\n        delete params.endpointId;\n        return endpoint.startCall(params);\n    };\n\n    /**\n     * Place an audio only call to an endpoint.\n     *\n     *     client.startAudioCall({\n     *         endpointId: 'erin',\n     *         onConnect: function (evt) { },\n     *         onLocalMedia: function (evt) { }\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.startAudioCall\n     * @param {object} params\n     * @param {string} params.endpointId - The id of the endpoint that should be called.\n     * @param {string} [params.connectionId]\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n     * video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n     * video attached to it.\n     * @return {respoke.Call}\n     */\n    that.startAudioCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video: false,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };\n\n    /**\n     * Place a video call to an endpoint.\n     *\n     *     client.startVideoCall({\n     *         endpointId: 'erin',\n     *         onConnect: function (evt) { },\n     *         onLocalMedia: function (evt) { }\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.startVideoCall\n     * @param {object} params\n     * @param {string} params.endpointId - The id of the endpoint that should be called.\n     * @param {string} [params.connectionId]\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n     * video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n     * video attached to it.\n     * @return {respoke.Call}\n     */\n    that.startVideoCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video: true,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };\n\n    /**\n     * Place an audio call with a phone number.\n     * @memberof! respoke.Client\n     * @method respoke.Client.startPhoneCall\n     * @param {object} params\n     * @param {string} params.number - The phone number that should be called.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @return {respoke.Call}\n     */\n    that.startPhoneCall = function (params) {\n        var promise;\n        var retVal;\n        var call = null;\n        var recipient = {};\n        params = params || {};\n        params.constraints = {\n            video: false,\n            audio: true,\n            mandatory: {},\n            optional: []\n        };\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        if (!params.number) {\n            log.error(\"Can't start a phone call without a number.\");\n            promise = Q.reject(new Error(\"Can't start a phone call without a number.\"));\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        recipient.id = params.number;\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = recipient;\n\n        params.toType = params.toType || 'did';\n        params.fromType = params.fromType || 'web';\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.connectionId = signalParams.connectionId;\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            signalingChannel.sendReport(signalParams);\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        return call;\n    };\n\n    /**\n     * Place an audio call to a SIP URI.\n     * @memberof! respoke.Client\n     * @method respoke.Client.startSIPCall\n     * @param {object} params\n     * @param {string} params.uri - The SIP URI to call.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @return {respoke.Call}\n     */\n    that.startSIPCall = function (params) {\n        var promise;\n        var retVal;\n        var call = null;\n        var recipient = {};\n        params = params || {};\n        params.constraints = {\n            video: false,\n            audio: true,\n            mandatory: {},\n            optional: []\n        };\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        if (!params.uri) {\n            log.error(\"Can't start a phone call without a SIP URI.\");\n            promise = Q.reject(new Error(\"Can't start a phone call without a SIP URI.\"));\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        recipient.id = params.uri;\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = recipient;\n\n        params.toType = params.toType || 'sip';\n        params.fromType = params.fromType || 'web';\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.connectionId = signalParams.connectionId;\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            signalingChannel.sendReport(signalParams);\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        return call;\n    };\n\n    /**\n     * Assert that we are connected to the backend infrastructure.\n     * @memberof! respoke.Client\n     * @method respoke.Client.verifyConnected\n     * @throws {Error}\n     * @private\n     */\n    that.verifyConnected = function () {\n        if (!signalingChannel.isConnected()) {\n            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n        }\n    };\n\n    /**\n     * Check whether this client is connected to the Respoke API.\n     * @memberof! respoke.Client\n     * @method respoke.Client.isConnected\n     * @returns boolean\n     */\n    that.isConnected = function () {\n        return signalingChannel.isConnected();\n    };\n\n    /**\n     * Join a group and begin keeping track of it. If this method is called multiple times synchronously, it will\n     * batch requests and only make one API call to Respoke.\n     *\n     * You can leave the group by calling `group.leave()`;\n     *\n     * ##### Joining and leaving a group\n     *\n     *      var group;\n     *\n     *      client.join({\n     *          id: \"book-club\",\n     *          onSuccess: function (evt) {\n     *              console.log('I joined', evt.group.id);\n     *              // \"I joined book-club\"\n     *              group = evt.group;\n     *              group.sendMessage({\n     *                  message: 'sup'\n     *              });\n     *          }\n     *      });\n     *\n     *      // . . .\n     *      // Some time later, leave the group.\n     *      // . . .\n     *      group.leave({\n     *          onSuccess: function (evt) {\n     *              console.log('I left', evt.group.id);\n     *              // \"I left book-club\"\n     *          }\n     *      });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.join\n     * @param {object} params\n     * @param {string} params.id - The name of the group.\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {respoke.Group.onMessage} [params.onMessage] - Message handler for messages from this group only.\n     * @param {respoke.Group.onJoin} [params.onJoin] - Join event listener for endpoints who join this group only.\n     * @param {respoke.Group.onLeave} [params.onLeave] - Leave event listener for endpoints who leave\n     * this group only.\n     * @returns {Promise<respoke.Group>|undefined} The instance of the respoke.Group which the client joined.\n     * @fires respoke.Client#join\n     */\n    that.join = function (params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            deferred.reject(e);\n            return retVal;\n        }\n\n        if (!params.id) {\n            deferred.reject(new Error(\"Can't join a group with no group id.\"));\n            return retVal;\n        }\n\n        signalingChannel.joinGroup({\n            groupList: [params.id]\n        }).done(function successHandler() {\n            var group;\n            params.signalingChannel = signalingChannel;\n            params.instanceId = instanceId;\n\n            group = that.getGroup({id: params.id});\n\n            if (!group) {\n                group = respoke.Group(params);\n                that.addGroup(group);\n            }\n\n            group.listen('join', params.onJoin);\n            group.listen('leave', params.onLeave);\n            group.listen('message', params.onMessage);\n\n            group.addMember({\n                connection: that.getConnection({\n                    endpointId: that.endpointId,\n                    connectionId: that.connectionId\n                })\n            });\n\n            /**\n             * This event is fired every time the client joins a group. If the client leaves\n             * a group, this event will be fired again on the next time the client joins the group.\n             * @event respoke.Client#join\n             * @type {respoke.Event}\n             * @property {respoke.Group} group\n             * @property {string} name - the event name.\n             */\n            that.fire('join', {\n                group: group\n            });\n            deferred.resolve(group);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return retVal;\n    };\n\n    /**\n     * Add a Group. This is called when we join a group and need to begin keeping track of it.\n     * @memberof! respoke.Client\n     * @method respoke.Client.addGroup\n     * @param {respoke.Group}\n     * @private\n     */\n    that.addGroup = function (newGroup) {\n        if (!newGroup || newGroup.className !== 'respoke.Group') {\n            throw new Error(\"Can't add group to internal tracking without a group.\");\n        }\n\n        newGroup.listen('leave', function leaveHandler(evt) {\n            newGroup.removeMember({connectionId: evt.connection.id});\n            var endpt = evt.connection.getEndpoint();\n            if (!endpt.hasListeners('presence')) {\n                checkEndpointForRemoval(endpt);\n            }\n        }, true);\n\n        groups.push(newGroup);\n    };\n\n    /**\n     * Get a list of all the groups the client is currently a member of.\n     * @memberof! respoke.Client\n     * @method respoke.Client.getGroups\n     * @returns {Array<respoke.Group>} All of the groups the library is aware of.\n     */\n    that.getGroups = function () {\n        return groups;\n    };\n\n    /**\n     * Find a group by id and return it.\n     *\n     *     var group = client.getGroup({\n     *         id: \"resistance\"\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getGroup\n     * @param {object} params\n     * @param {string} params.id\n     * @param {respoke.Group.onJoin} [params.onJoin] - Receive notification that an endpoint has joined this group.\n     * @param {respoke.Group.onLeave} [params.onLeave] - Receive notification that an endpoint has left this group.\n     * @param {respoke.Group.onMessage} [params.onMessage] - Receive notification that a message has been\n     * received to a group.\n     * @returns {respoke.Group|undefined} The group whose ID was specified.\n     */\n    that.getGroup = function (params) {\n        var group;\n        if (!params || !params.id) {\n            throw new Error(\"Can't get a group without group id.\");\n        }\n\n        groups.every(function eachGroup(grp) {\n            if (grp.id === params.id) {\n                group = grp;\n                return false;\n            }\n            return true;\n        });\n\n        if (group) {\n            group.listen('join', params.onJoin);\n            group.listen('leave', params.onLeave);\n            group.listen('message', params.onMessage);\n        }\n\n        return group;\n    };\n\n    /**\n     * Remove an Endpoint. Since an endpoint can be a member of multiple groups, we can't just remove it from\n     * our list on respoke.Endpoint#leave. We must see if it's a member of any more groups. If it's not\n     * a member of any other groups, we can stop keeping track of it.\n     * @todo TODO Need to account for Endpoints not created as part of a group. These do not need to be\n     * deleted based on group membership.\n     * @memberof! respoke.Client\n     * @method respoke.Client.checkEndpointForRemoval\n     * @param {object} params\n     * @param {string} params.id - The ID of the Endpoint to check for removal.\n     * @private\n     */\n    function checkEndpointForRemoval(params) {\n        params = params || {};\n        if (!params.id) {\n            throw new Error(\"Can't remove endpoint from internal tracking without group id.\");\n        }\n\n        Q.all(groups.map(function eachGroup(group) {\n            return group.getMembers();\n        })).done(function successHandler(connectionsByGroup) {\n            // connectionsByGroup is a two-dimensional array where the first dimension is a group\n            // and the second dimension is a connection.\n            var absent = connectionsByGroup.every(function eachConnectionList(connectionList) {\n                return connectionList.every(function eachConnection(conn) {\n                    return (conn.endpointId !== params.id);\n                });\n            });\n            if (absent) {\n                endpoints.every(function eachEndpoint(ept, index) {\n                    if (ept.id === params.id) {\n                        endpoints.splice(index, 1);\n                        return false;\n                    }\n                    return true;\n                });\n            }\n        });\n    }\n\n    /**\n     * Find an endpoint by id and return the `respoke.Endpoint` object.\n     *\n     * If it is not already cached locally, will be added to the local cache of tracked endpoints,\n     * its presence will be determined, and will be available in `client.getEndpoints()`.\n     *\n     *     var endpoint = client.getEndpoint({\n     *         id: \"dlee\"\n     *     });\n     *\n     * @ignore If the endpoint is not found in the local cache of endpoint objects (see `client.getEndpoints()`),\n     * it will be created. This is useful, for example, in the case of dynamic endpoints where groups are\n     * not in use. Override dynamic endpoint creation by setting `params.skipCreate = true`.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getEndpoint\n     * @param {object} params\n     * @param {string} params.id\n     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n     * from this one Endpoint.\n     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n     * Endpoint.\n     * @arg {boolean} [params.skipCreate] - Skip the creation step and return undefined if we don't yet\n     * @arg {boolean} [params.skipPresence] - Skip registering for this endpoint's presence.\n     * @returns {respoke.Endpoint} The endpoint whose ID was specified.\n     */\n    that.getEndpoint = function (params) {\n        var endpoint;\n        if (!params || !params.id) {\n            throw new Error(\"Can't get an endpoint without endpoint id.\");\n        }\n\n        endpoints.every(function eachEndpoint(ept) {\n            if (ept.id === params.id) {\n                endpoint = ept;\n                return false;\n            }\n            return true;\n        });\n\n        if (!endpoint && params && !params.skipCreate) {\n            params.instanceId = instanceId;\n            params.signalingChannel = signalingChannel;\n            params.resolveEndpointPresence = clientSettings.resolveEndpointPresence;\n            params.addCall = addCall;\n\n            endpoint = respoke.Endpoint(params);\n            endpoints.push(endpoint);\n        }\n\n        if (!endpoint) {\n            return;\n        }\n\n        if (params.skipPresence !== true) {\n            signalingChannel.registerPresence({\n                endpointList: [endpoint.id]\n            }).done(null, function (err) {\n                log.error(\"Couldn't register for presence on\", endpoint.id, err.message);\n            });\n        }\n        endpoint.listen('presence', params.onPresence);\n        endpoint.listen('message', params.onMessage);\n\n        return endpoint;\n    };\n\n    /**\n     * Find a Connection by id and return it.\n     *\n     *     var connection = client.getConnection({\n     *         id: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n     *     });\n     *\n     * @ignore In most cases, if we don't find it we will create it. This is useful\n     * in the case of dynamic endpoints where groups are not in use. Set skipCreate=true\n     * to return undefined if the Connection is not already known.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getConnection\n     * @param {object} params\n     * @param {string} params.connectionId\n     * @param {string} [params.endpointId] - An endpointId to use in the creation of this connection.\n     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n     * from this one Connection.\n     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n     * Connection.\n     * @returns {respoke.Connection} The connection whose ID was specified.\n     */\n    that.getConnection = function (params) {\n        var connection;\n        var endpoint;\n        var endpointsToSearch = endpoints;\n\n        params = params || {};\n        if (!params.connectionId) {\n            throw new Error(\"Can't get a connection without connection id.\");\n        }\n        if (!params.endpointId && !params.skipCreate) {\n            throw new Error(\"Can't create a connection without endpoint id.\");\n        }\n\n        if (params.endpointId) {\n            endpoint = that.getEndpoint({\n                id: params.endpointId,\n                skipPresence: true,\n                skipCreate: params.skipCreate\n            });\n\n            endpointsToSearch = [];\n            if (endpoint) {\n                endpointsToSearch = [endpoint];\n            }\n        }\n\n        endpointsToSearch.every(function eachEndpoint(ept) {\n            connection = ept.getConnection(params);\n            return !connection;\n        });\n\n        if (!connection && !params.skipCreate) {\n            params.instanceId = instanceId;\n            connection = respoke.Connection(params);\n            endpoint.connections.push(connection);\n        }\n\n        return connection;\n    };\n\n    /**\n     * Get the list of **all endpoints** that the library has knowledge of.\n     * These are `respoke.Endpoint` objects, not just the endpointIds.\n     *\n     * The library gains knowledge of an endpoint in two ways:\n     * 1. when an endpoint joins a group that the user (currently logged-in endpoint) is a member of (if group presence is enabled)\n     * 2. when an endpoint that the user (currently logged-in endpoint) is watching*\n     *\n     * *If an endpoint that the library does not know about sends a message to the client, you\n     * can immediately call the `client.getEndpoint()` method on the sender of the message to enable\n     * watching of the sender's endpoint.\n     *\n     *      client.on('message', function (data) {\n     *          if (data.endpoint) {\n     *              // start tracking this endpoint.\n     *              client.getEndpoint({ id: data.endpoint.id });\n     *          }\n     *      });\n     *\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getEndpoints\n     * @returns {Array<respoke.Endpoint>}\n     */\n    that.getEndpoints = function () {\n        return endpoints;\n    };\n\n    return that;\n}; // End respoke.Client\n\n/**\n * Handle sending successfully.\n * @callback respoke.Client.successHandler\n */\n/**\n * Handle joining a group successfully. This callback is called only once when Client.join() is called.\n * @callback respoke.Client.joinHandler\n * @param {respoke.Group} group\n */\n/**\n * Receive notification that the client has joined a group. This callback is called everytime\n * respoke.Client#join is fired.\n * @callback respoke.Client.onJoin\n * @param {respoke.Event} evt\n * @param {respoke.Group} evt.group\n * @param {string} evt.name - the event name.\n */\n/**\n * Receive notification that the client has left a group. This callback is called everytime\n * respoke.Client#leave is fired.\n * @callback respoke.Client.onLeave\n * @param {respoke.Event} evt\n * @param {respoke.Group} evt.group\n * @param {string} evt.name - the event name.\n */\n/**\n * Receive notification that a message has been received. This callback is called every time\n * respoke.Client#message is fired.\n * @callback respoke.Client.onClientMessage\n * @param {respoke.Event} evt\n * @param {respoke.TextMessage} evt.message\n * @param {respoke.Group} [evt.group] - If the message is to a group we already know about,\n * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n * the group. From that point forward, Group#message will fire when a message is received as well. If\n * group is undefined instead of null, the message is not a group message at all.\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Receive notification that the client is receiving a call from a remote party. This callback is called every\n * time respoke.Client#call is fired.\n * @callback respoke.Client.onCall\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.call\n * @param {respoke.Endpoint} evt.endpoint\n * @param {string} evt.name - the event name.\n */\n/**\n * Receive notification that the client is receiving a request for a direct connection from a remote party.\n * This callback is called every time respoke.Client#direct-connection is fired.\n * @callback respoke.Client.onDirectConnection\n * @param {respoke.Event} evt\n * @param {respoke.DirectConnection} evt.directConnection\n * @param {respoke.Endpoint} evt.endpoint\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * Receive notification Respoke has successfully connected to the cloud. This callback is called every time\n * respoke.Client#connect is fired.\n * @callback respoke.Client.onConnect\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Receive notification Respoke has successfully disconnected from the cloud. This callback is called every time\n * respoke.Client#disconnect is fired.\n * @callback respoke.Client.onDisconnect\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Receive notification Respoke has successfully reconnected to the cloud. This callback is called every time\n * respoke.Client#reconnect is fired.\n * @callback respoke.Client.onReconnect\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Handle disconnection to the cloud successfully.\n * @callback respoke.Client.disconnectSuccessHandler\n */\n/**\n * Handle an error that resulted from a method call.\n * @callback respoke.Client.errorHandler\n * @params {Error} err\n */\n/**\n * Handle connection to the cloud successfully.\n * @callback respoke.Client.connectSuccessHandler\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/client.js\n ** module id = 3\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar respoke = require('./respoke');\n\n/**\n * The purpose of the class is to allow multiple types of entities to expose presence functionality.\n * \n * Setting the presence on a client is provided via `client.setPresence({ presence: \"At lunch\" })`.\n * \n * @class respoke.Presentable\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId\n * @param {string} params.id\n * @returns {respoke.Presentable}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Presentable\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.Presentable\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Presentable';\n    /**\n     * Represents the presence status. Typically a string, but other types are supported.\n     * Defaults to `'unavailable'`.\n     * \n     * **Do not modify this directly** - it won't update presence with Respoke. Use `setPresence()`.\n     * \n     * @memberof! respoke.Presentable\n     * @name presence\n     * @type {string|number|object|Array}\n     * @private\n     */\n    that.presence = 'unavailable';\n\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name client\n     * @type {respoke.Client}\n     * @private\n     */\n    var client = respoke.getClient(instanceId);\n\n    /**\n     * Set the presence on the object for this session.\n     * \n     * @memberof! respoke.Presentable\n     * @method respoke.Presentable.setPresence\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=available]\n     * @param {string} params.connectionId\n     * @fires respoke.Presentable#presence\n     * @private\n     */\n    that.setPresence = function (params) {\n        var connection;\n        params = params || {};\n        params.presence = params.presence || 'available';\n        params.connectionId = params.connectionId || that.connectionId;\n\n        if (that.className === 'respoke.Client' || that.className === 'respoke.Connection') {\n            that.presence = params.presence;\n            if (that.className === 'respoke.Connection') {\n                that.getEndpoint().resolvePresence();\n            }\n        } else if (that.className === 'respoke.Endpoint') {\n            if (!params.connectionId) {\n                throw new Error(\"Can't set Endpoint presence without a connectionId.\");\n            }\n\n            connection = that.getConnection({connectionId: params.connectionId}) || client.getConnection({\n                connectionId: params.connectionId,\n                skipCreate: false,\n                endpointId: that.id\n            });\n\n            connection.presence = params.presence;\n            that.resolvePresence();\n        }\n\n        /**\n         * This event indicates that the presence for this endpoint has been updated.\n         * @event respoke.Presentable#presence\n         * @type {respoke.Event}\n         * @property {string|number|object|Array} presence\n         * @property {string} name - the event name.\n         * @property {respoke.Presentable} target\n         */\n        that.fire('presence', {\n            presence: that.presence\n        });\n    };\n\n    /**\n     * Get the presence of a Presentable instance.\n     * \n     *      var billy = client.getEndpoint({ id: \"billychia\" });\n     *      var pres = billy.getPresence();\n     *      console.log('Billy is', pres); // \"Billy is available\"\n     * \n     * @memberof! respoke.Presentable\n     * @method respoke.Presentable.getPresence\n     * @returns {string|number|object|array} the current presence of this endpoint.\n     */\n    that.getPresence = function () {\n        return that.presence;\n    };\n\n    return that;\n}; // End respoke.Presentable\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/presentable.js\n ** module id = 4\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar respoke = require('./respoke');\n\n/**\n * A `respoke.Connection` always belongs to an Endpoint.\n *\n * There is a distinction between Endpoint and Connection because an Endpoint can be authenticated\n * from multiple devices, browsers, or browser tabs. Each of these separate authentications is a Connection.\n * A Client can choose to interact with connections of the same endpoint in different ways.\n *\n * @constructor\n * @class respoke.Connection\n * @augments respoke.Presentable\n * @param {object} params\n * @param {string} params.id\n * @returns {respoke.Connection}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Connection\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.Presentable(params);\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name client\n     * @type {respoke.Client}\n     * @private\n     */\n    var client = respoke.getClient(instanceId);\n\n    /**\n     * The connection id.\n     * @memberof! respoke.Connection\n     * @name id\n     * @type {string}\n     */\n    that.id = that.id || that.connectionId;\n    if (!that.id) {\n        throw new Error(\"Can't make a connection without an id.\");\n    }\n    delete that.instanceId;\n    delete that.connectionId;\n\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.Connection\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Connection';\n\n    /**\n     * Send a message to this connection of an endpoint. If the endpoint has multiple connections,\n     * it will only receive the message at this connection.\n     *\n     *     connection.sendMessage({\n     *         message: \"PJ, put that PBR down!\"\n     *     });\n     *\n     * **Using callbacks** will disable promises.\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.sendMessage\n     * @param {object} params\n     * @param {string} params.message\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().sendMessage(params);\n    };\n\n    /**\n     * Create a new Call for a voice and/or video call this particular connection, only. The Call cannot be answered\n     * by another connection of this Endpoint.\n     *\n     *     connection.startCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {RTCConstraints} [params.constraints]\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote video attached to it.\n     * @returns {respoke.Call}\n     */\n    that.startCall = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().startCall(params);\n    };\n\n    /**\n     * Create a new audio-only call.\n     *\n     *     connection.startAudioCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startAudioCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @returns {respoke.Call}\n     */\n    that.startAudioCall = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        params.constraints = {\n            video: false,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };\n\n    /**\n     * Create a new call with audio and video.\n     *\n     *     connection.startVideoCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startVideoCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has\n     * been hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @returns {respoke.Call}\n     */\n    that.startVideoCall = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().startCall(params);\n    };\n\n    /**\n     * Create a new DirectConnection with this particular connection, only. The DirectConnection cannot be answered\n     * by another connection of this Endpoint.  This method creates a new Call as well, attaching this\n     * DirectConnection to it for the purposes of creating a peer-to-peer link for sending data such as messages to\n     * the other endpoint. Information sent through a DirectConnection is not handled by the cloud infrastructure.\n     *\n     *     connection.startDirectConnection({\n     *         onOpen: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startDirectConnection\n     * @param {object} params\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n     * connection begins. The direct connection will not be open yet.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n     * the DirectConnection is open and ready to be used.\n     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n     * connection.\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n     * when the DirectConnection is closed and the two Endpoints are disconnected.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n     * through the DirectConnection.\n     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n     * request for a direct connection and setup begins.\n     * @returns {respoke.DirectConnection} The DirectConnection which can be used to send data and messages\n     * directly to the other endpoint.\n     */\n    that.startDirectConnection = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().startDirectConnection(params);\n    };\n\n    /**\n     * Get the Endpoint that this Connection belongs to.\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.getEndpoint\n     * @returns {respoke.Endpoint}\n     */\n    that.getEndpoint = function () {\n        return client.getEndpoint({\n            id: that.endpointId,\n            skipPresence: true\n        });\n    };\n\n    return that;\n}; // End respoke.Connection\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/connection.js\n ** module id = 5\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');\n\n/**\n * `respoke.Endpoint`s are users of a Respoke app.\n *\n * An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.\n *\n * A Client can interact with endpoints through messages, audio or video calls, or direct connections.\n *\n * An Endpoint may be authenticated from multiple devices to the same app (each of\n * which is represented by a Connection).\n *\n *\n * @constructor\n * @class respoke.Endpoint\n * @augments respoke.Presentable\n * @param {object} params\n * @param {string} params.id\n * @param {string} params.instanceId\n * @param {respoke.client.resolvePresence} [params.resolvePresence] An optional function for resolving presence for an endpoint.\n * @returns {respoke.Endpoint}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Endpoint\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.Presentable(params);\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name client\n     * @type {respoke.Client}\n     * @private\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name signalingChannel\n     * @type {respoke.SignalingChannel}\n     * @private\n     */\n    var signalingChannel = params.signalingChannel;\n\n    var addCall = params.addCall;\n\n    delete that.signalingChannel;\n    delete that.instanceId;\n    delete that.connectionId;\n    delete that.addCall;\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.Endpoint\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Endpoint';\n    /**\n     * A direct connection to this endpoint. This can be used to send direct messages.\n     * @memberof! respoke.Endpoint\n     * @name directConnection\n     * @type {respoke.DirectConnection}\n     */\n    that.directConnection = null;\n\n    /**\n     * Array of connections for this endpoint.\n     * @memberof! respoke.Endpoint\n     * @name connections\n     * @type {Array<respoke.Connection>}\n     */\n    that.connections = [];\n    client.listen('disconnect', function disconnectHandler() {\n        that.connections = [];\n    });\n\n    var resolveEndpointPresence = params.resolveEndpointPresence;\n    delete that.resolveEndpointPresence;\n\n    /**\n     * Send a message to the endpoint through the infrastructure.\n     *\n     *    endpoint.sendMessage({\n     *        message: \"wassuuuuup\"\n     *    });\n     *\n     * **Using callbacks** will disable promises.\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.sendMessage\n     * @param {object} params\n     * @param {string} params.message\n     * @param {string} [params.connectionId]\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of this\n     * method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this method\n     * only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n\n        promise = signalingChannel.sendMessage({\n            connectionId: params.connectionId,\n            message: params.message,\n            recipient: that\n        });\n\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };\n\n    /**\n     * Create a new audio-only call.\n     *\n     *     endpoint.startAudioCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startAudioCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @returns {respoke.Call}\n     */\n    that.startAudioCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video: false,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };\n\n    /**\n     * Create a new call with audio and video.\n     *\n     *     endpoint.startVideoCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startVideoCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @returns {respoke.Call}\n     */\n    that.startVideoCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video: true,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };\n\n    /**\n     * Create a new call.\n     *\n     *     endpoint.startCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {RTCConstraints} [params.constraints]\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote video attached to it.\n     * @returns {respoke.Call}\n     */\n    that.startCall = function (params) {\n        var call = null;\n        params = params || {};\n\n        log.debug('Endpoint.call');\n        client.verifyConnected();\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            log.error(\"Can't start a call without endpoint ID!\");\n            return;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.connectionId = signalParams.call.connectionId;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.warn(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            signalingChannel.sendReport(signalParams).done(null, function errorHandler(err) {\n                log.warn(\"Couldn't debug report.\", err.message, err.stack);\n            });\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        return call;\n    };\n\n    /**\n     * Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\n     * it for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\n     * Information sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\n     * a direct connection open, this method will resolve the promise with that direct connection instead of\n     * attempting to create a new one.\n     *\n     *     endpoint.startDirectConnection({\n     *         onOpen: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startDirectConnection\n     * @param {object} params\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n     * connection begins. The direct connection will not be open yet.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n     * the DirectConnection is open and ready to be used.\n     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n     * connection.\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n     * when the DirectConnection is closed and the two Endpoints are disconnected.\n     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n     * request for a direct connection and setup begins.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n     * through the DirectConnection.\n     * @param {string} [params.connectionId] - An optional connection ID to use for this connection. This allows\n     * the connection to be made to a specific instance of an endpoint in the case that the same endpoint is logged\n     * in from multiple locations.\n     * @returns {respoke.DirectConnection} The DirectConnection which can be used to send data and messages\n     * directly to the other endpoint.\n     */\n    that.startDirectConnection = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        var call;\n\n        try {\n            client.verifyConnected();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (that.directConnection || params.create === false) {\n            deferred.resolve(that.directConnection);\n            return retVal;\n        }\n\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            deferred.reject(new Error(\"Can't start a direct connection without endpoint ID!\"));\n            return retVal;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalParams.signalType = 'answer';\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            signalParams.report.target = 'directConnection';\n            log.debug(\"Not sending report\");\n            log.debug(signalParams.report);\n        };\n        params.needDirectConnection = true;\n        // Don't include audio in the offer SDP\n        params.offerOptions = {\n            mandatory: {\n                OfferToReceiveAudio: false\n            }\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        call.listen('direct-connection', function directConnectionHandler(evt) {\n            that.directConnection = evt.directConnection;\n            if (params.caller !== true) {\n                if (!client.hasListeners('direct-connection') &&\n                        !client.hasListeners('direct-connection') &&\n                        !call.hasListeners('direct-connection')) {\n                    that.directConnection.reject();\n                    deferred.reject(new Error(\"Got an incoming direct connection with no handlers to accept it!\"));\n                    return;\n                }\n\n                deferred.resolve(that.directConnection);\n                that.directConnection.listen('close', function closeHandler(evt) {\n                    that.directConnection = undefined;\n                }, true);\n            }\n        }, true);\n\n        return retVal;\n    };\n\n    /**\n     * Find the presence out of all known connections with the highest priority (most availability)\n     * and set it as the endpoint's resolved presence.\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.resolvePresence\n     * @private\n     */\n    that.resolvePresence = function () {\n\n        var presenceList = that.connections.map(function (connection) {\n            return connection.presence;\n        });\n\n        if (resolveEndpointPresence !== undefined) {\n            that.presence = resolveEndpointPresence(presenceList);\n        } else {\n            var options = ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable'];\n            var idList;\n\n            /*\n             * Sort the connections array by the priority of the value of the presence of that\n             * connectionId. This will cause the first element in the list to be the id of the\n             * session with the highest priority presence so we can access it by the 0 index.\n             * TODO: If we don't really care about the sorting and only about the highest priority\n             * we could use Array.prototype.every to improve this algorithm.\n             */\n            idList = that.connections.sort(function sorter(a, b) {\n                var indexA = options.indexOf(a.presence);\n                var indexB = options.indexOf(b.presence);\n                // Move it to the end of the list if it isn't one of our accepted presence values\n                indexA = indexA === -1 ? 1000 : indexA;\n                indexB = indexB === -1 ? 1000 : indexB;\n                return indexA < indexB ? -1 : (indexB < indexA ? 1 : 0);\n            });\n\n            if (idList[0]) {\n                that.presence = idList[0].presence;\n            } else {\n                that.presence = 'unavailable';\n            }\n        }\n    };\n\n    /**\n     * Get the Connection with the specified id. The connection ID is optional if only one connection exists.\n     *\n     *     var connection = endpoint.getConnection({\n     *         connectionId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.getConnection\n     * @private\n     * @param {object} params\n     * @param {string} [params.connectionId]\n     * @return {respoke.Connection}\n     */\n    that.getConnection = function (params) {\n        var connection = null;\n        params = params || {};\n        if (that.connections.length === 1 &&\n                (!params.connectionId || that.connections[0] === params.connectionId)) {\n            return that.connections[0];\n        }\n\n        if (!params || !params.connectionId) {\n            throw new Error(\"Can't find a connection without the connectionId.\");\n        }\n\n        that.connections.every(function eachConnection(conn) {\n            if (conn.id === params.connectionId) {\n                connection = conn;\n                return false;\n            }\n            return true;\n        });\n\n        return connection;\n    };\n\n    return that;\n}; // End respoke.Endpoint\n/**\n * Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\n * respoke.Endpoint#message fires.\n * @callback respoke.Endpoint.onMessage\n * @param {respoke.Event} evt\n * @param {respoke.TextMessage} evt.message - the message\n * @param {respoke.Endpoint} evt.target\n * @param {string} evt.name - the event name\n */\n/**\n * Handle presence notifications from this one Endpoint.  This callback is called every time\n * respoke.Endpoint#message fires.\n * @callback respoke.Endpoint.onPresence\n * @param {respoke.Event} evt\n * @param {string|number|object|Array} evt.presence - the Endpoint's presence\n * @param {respoke.Endpoint} evt.target\n * @param {string} evt.name - the event name\n */\n /**\n * Handle resolving presence for this endpoint\n * @callback respoke.Client.resolveEndpointPresence\n * @param {Array<object>} connectionPresence\n * @returns {object|string|number}\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/endpoint.js\n ** module id = 6\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\n/**\n * A text message and the information needed to route it.\n * @class respoke.TextMessage\n * @constructor\n * @param {object} params\n * @param {string} [params.endpointId] - If sending, endpoint ID of the thing we're sending a message to.\n * @param {string} [params.connectionId] - If sending, connection ID of the thing we're sending a message to.\n * @param {string} [params.message] - If sending, a message to send\n * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n * @private\n * @returns {respoke.TextMessage}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = {};\n\n    /**\n     * Parse rawMessage and set attributes required for message delivery.\n     * @memberof! respoke.TextMessage\n     * @method respoke.TextMessage.parse\n     * @private\n     */\n    function parse() {\n        if (params.rawMessage) {\n            try {\n                that.endpointId = params.rawMessage.header.from;\n                that.connectionId = params.rawMessage.header.fromConnection;\n                that.timestamp = params.rawMessage.header.timestamp;\n            } catch (e) {\n                throw new Error(e);\n            }\n            that.message = params.rawMessage.message || params.rawMessage.body;\n            if (params.rawMessage.header.channel) {\n                that.recipient = params.rawMessage.header.channel;\n            }\n        } else {\n            try {\n                that.to = params.endpointId;\n                that.toConnection = params.connectionId;\n                that.requestConnectionReply = (params.requestConnectionReply === true);\n            } catch (e) {\n                throw new Error(e);\n            }\n            that.message = params.message;\n        }\n    }\n\n    parse();\n    return that;\n}; // End respoke.TextMessage\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/textMessage.js\n ** module id = 7\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\n/**\n * A signaling message and the information needed to route it.\n * @class respoke.SignalingMessage\n * @constructor\n * @param {object} params\n * @param {string} [params.fromEndpoint] - If sending, the endpoint ID of the recipient\n * @param {string} [params.fromConnection] - If sending, the connection ID of the recipient\n * @param {string} [params.connectionId] - The connectionId of the endpoint whose answer signal has been accepted.\n * @param {string} [params.signal] - If sending, a message to send\n * @param {respoke.Endpoint} [params.recipient]\n * @param {string} [params.signalType]\n * @param {string} [params.sessionId] - A globally unique ID to identify this call.\n * @param {string} [params.target] - Either 'call' or 'directConnection', TODO remove the need for this.\n * @param {string} [params.callerId] - Human readable caller ID. Not implemented.\n * @param {RTCSessionDescription} [params.sdp]\n * @param {Array<RTCIceCandidate>} [params.iceCandidates]\n * @param {object} [params.offering] - Object describing the media we're offering to send the remote party in a more\n * usable way than SDP. Not implemented.\n * @param {object} [params.requesting] - Object describing the media we're requesting from the remote party in a more\n * usable way than SDP. Not implemented.\n * @param {string} [params.reason] - Human readable reason for hanging up.\n * @param {string} [params.error] - String indicating that a previous signal was malformed or received in the wrong\n * state. Not implemented.\n * @param {string} [params.status] - \"Ringing\". Not implemented.\n * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n * @private\n * @returns {respoke.SignalingMessage}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = {};\n    /**\n     * Attributes without which we cannot build a signaling message.\n     * @memberof! respoke.SignalingMessage\n     * @name required\n     * @private\n     * @type {string}\n     */\n    var required = ['recipient', 'signalType', 'sessionId', 'target', 'signalId'];\n    /**\n     * Attributes which we will copy onto the signal if defined.\n     * @memberof! respoke.SignalingMessage\n     * @name required\n     * @private\n     * @type {string}\n     */\n    var allowed = [\n        'signalType', 'sessionId', 'callerId', 'sessionDescription', 'iceCandidates', 'offering', 'target', 'signalId',\n        'requesting', 'reason', 'error', 'status', 'connectionId', 'version'\n    ];\n\n    params.version = '1.0';\n\n    /**\n     * Parse rawMessage and set attributes required for message delivery.\n     * @memberof! respoke.SignalingMessage\n     * @method respoke.SignalingMessage.parse\n     * @private\n     */\n    function parse() {\n        if (params.rawMessage) {\n            try {\n                that = JSON.parse(params.rawMessage.body); // Incoming message\n            } catch (e) {\n                that = params.rawMessage.body;\n            }\n            that.fromType = params.rawMessage.header.fromType;\n            that.fromEndpoint = params.rawMessage.header.from;\n            that.fromConnection = params.rawMessage.header.fromConnection;\n            that.timestamp = params.rawMessage.header.timestamp;\n\n            if (!that.target) {\n                that.target = 'call';\n            }\n        } else {\n            required.forEach(function eachAttr(attr) {\n                if (params[attr] === 0 || !params[attr]) {\n                    throw new Error(\"Can't build a signaling without \" + attr);\n                }\n            });\n\n            allowed.forEach(function eachAttr(attr) {\n                if (params[attr] === 0 || params[attr]) {\n                    that[attr] = params[attr];\n                }\n            });\n        }\n    }\n\n    parse();\n    return that;\n}; // End respoke.SignalingMessage\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/signalingMessage.js\n ** module id = 8\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\n\n/**\n * A `respoke.Group` represents a collection of endpoints.\n *\n * There are methods to communicate with the endpoints at the group level and track\n * their presence in the group.\n *\n * @class respoke.Group\n * @augments respoke.EventEmitter\n * @constructor\n * @param {object} params\n * @param {string} params.instanceId\n * @param {respoke.Group.onJoin} params.onJoin - A callback to receive notifications every time a new\n * endpoint has joined the group. This callback does not get called when the client joins the group.\n * @param {respoke.Group.onMessage} params.onMessage - A callback to receive messages sent to the group from\n * remote endpoints.\n * @param {respoke.Group.onLeave} params.onLeave - A callback to receive notifications every time a new\n * endpoint has left the group. This callback does not get called when the client leaves the group.\n * @returns {respoke.Group}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n\n    var that = respoke.EventEmitter(params);\n    /**\n     * @memberof! respoke.Group\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var client = respoke.getClient(instanceId);\n\n    if (!that.id) {\n        throw new Error(\"Can't create a group without an ID.\");\n    }\n\n    /**\n     * Internal reference to the api signaling channel.\n     * @memberof! respoke.Group\n     * @name signalingChannel\n     * @type respoke.SignalingChannel\n     * @private\n     */\n    var signalingChannel = params.signalingChannel;\n    delete params.signalingChannel;\n\n    /**\n     * The connections to members of this group.\n     * @memberof! respoke.Group\n     * @name endpoints\n     * @type {array<respoke.Connection>}\n     */\n    that.connections = [];\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.Group\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Group';\n    that.listen('join', params.onJoin);\n    /**\n     * Indicates that a message has been sent to this group.\n     *\n     * @event respoke.Group#message\n     * @type {respoke.Event}\n     * @property {respoke.TextMessage} message\n     * @property {string} name - The event name.\n     * @property {respoke.Group} target\n     */\n    that.listen('message', params.onMessage);\n    that.listen('leave', params.onLeave);\n    client.listen('disconnect', function disconnectHandler() {\n        that.connections = [];\n    });\n\n    delete that.instanceId;\n    delete that.onMessage;\n    delete that.onPresence;\n    delete that.onJoin;\n    delete that.onLeave;\n\n    /**\n     * Join this group.\n     *\n     *     group.join().done(function () {\n     *         group.sendMessage({\n     *             message: \"Hey, ppl! I'm here!\"\n     *         });\n     *     }, function (err) {\n     *         // Couldn't join the group, possibly permissions error\n     *     });\n     *\n     * **Using callbacks** will disable promises.\n     * @memberof! respoke.Group\n     * @method respoke.Group.join\n     * @return {Promise|undefined}\n     * @param {object} params\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @fires respoke.Client#join\n     */\n    that.join = function () {\n        var params = {\n            id: that.id\n        };\n        var promise;\n        var deferred;\n        var retVal;\n\n        try {\n            validateConnection();\n        } catch (err) {\n            deferred = Q.defer();\n            retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        promise = client.join(params);\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };\n\n    /**\n     * Leave this group. If this method is called multiple times synchronously, it will batch requests and\n     * only make one API call to Respoke.\n     *\n     *     group.leave({\n     *         onSuccess: function () {\n     *             // good riddance\n     *         },\n     *         onError: function (err) {\n     *             // Couldn't leave the group, possibly a permissions error\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.leave\n     * @param {object} params\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @return {Promise|undefined}\n     * @fires respoke.Client#leave\n     */\n    that.leave = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        signalingChannel.leaveGroup({\n            groupList: [that.id]\n        }).done(function successHandler() {\n            /**\n             * This event is fired when the client leaves a group.\n             * @event respoke.Client#leave\n             * @type {respoke.Event}\n             * @property {respoke.Group} group\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             * @private\n             */\n            client.fire('leave', {\n                group: that\n            });\n            that.connections = [];\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject();\n        });\n        return retVal;\n    };\n\n    /**\n     * Remove a Connection from a Group. This does not change the status of the remote Endpoint, it only changes the\n     * internal representation of the Group membership. This method should only be used internally.\n     * @private\n     * @memberof! respoke.Group\n     * @method respoke.Group.removeMember\n     * @param {object} params\n     * @param {string} [params.connectionId] - Endpoint's connection id\n     * @fires respoke.Group#leave\n     */\n    that.removeMember = function (params) {\n        params = params || {};\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            return;\n        }\n\n        if (!params.connectionId) {\n            throw new Error(\"Can't remove a member to the group without it's Connection id.\");\n        }\n\n        that.connections.every(function eachConnection(conn, index) {\n            if (conn.id === params.connectionId) {\n                that.connections.splice(index, 1);\n\n                /**\n                 * This event is fired when a member leaves a group the client is a member of.\n                 * @event respoke.Group#leave\n                 * @type {respoke.Event}\n                 * @property {respoke.Connection} connection - The connection that left the group.\n                 * @property {string} name - The event name.\n                 * @property {respoke.Group} target\n                 */\n                that.fire('leave', {\n                    connection: conn\n                });\n                return false;\n            }\n            return true;\n        });\n    };\n\n    /**\n     * Return true if the logged-in user is a member of this group and false if not.\n     *\n     *     if (group.isJoined()) {\n     *         // I'm a member!\n     *     } else {\n     *         // Maybe join here\n     *     }\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.isJoined\n     * @returns {boolean}\n     */\n    that.isJoined = function () {\n        // connections array contains some connections and ours is among them.\n        return (that.connections.length > 0 && !that.connections.every(function (conn) {\n            return conn.id !== client.connectionId;\n        }));\n    };\n\n    /**\n     * Add a Connection to a group. This does not change the status of the remote Endpoint, it only changes the\n     * internal representation of the Group membership. This method should only be used internally.\n     * @memberof! respoke.Group\n     * @private\n     * @method respoke.Group.addMember\n     * @param {object} params\n     * @param {respoke.Connection} params.connection\n     * @fires respoke.Group#join\n     */\n    that.addMember = function (params) {\n        params = params || {};\n        var absent;\n\n        validateConnection();\n\n        if (!params.connection) {\n            throw new Error(\"Can't add a member to the group without it's Connection object.\");\n        }\n\n        absent = that.connections.every(function eachConnection(conn) {\n            return (conn.id !== params.connection.id);\n        });\n\n        if (absent) {\n            that.connections.push(params.connection);\n            if (params.skipEvent) {\n                return;\n            }\n\n            /**\n             * This event is fired when a member joins a Group that the currently logged-in endpoint is a member\n             * of.\n             * @event respoke.Group#join\n             * @type {respoke.Event}\n             * @property {respoke.Connection} connection - The connection that joined the group.\n             * @property {string} name - The event name.\n             * @property {respoke.Group} target\n             */\n            that.fire('join', {\n                connection: params.connection\n            });\n        }\n    };\n\n    /**\n     * Validate that the client is connected to the Respoke infrastructure.\n     * @memberof! respoke.Group\n     * @method respoke.Group.validateConnection\n     * @private\n     */\n    function validateConnection() {\n        if (!signalingChannel || !signalingChannel.isConnected()) {\n            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n        }\n    }\n\n    /**\n     * Validate that the client is a member of this group.\n     * @memberof! respoke.Group\n     * @method respoke.Group.validateMembership\n     * @private\n     */\n    function validateMembership() {\n        if (!that.isJoined()) {\n            throw new Error(\"Not a member of this group anymore.\");\n        }\n    }\n\n    /**\n     *\n     * Send a message to all of the endpoints in the group.\n     *\n     *      var group = client.getGroup({ id: 'js-enthusiasts'});\n     *\n     *      group.sendMessage({\n     *          message: \"Cat on keyboard\",\n     *          onSuccess: function (evt) {\n     *              console.log('Message was sent');\n     *          }\n     *      });\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.sendMessage\n     * @param {object} params\n     * @param {string} params.message - The message.\n     * @param {function} params.onSuccess - Success handler indicating that the message was delivered.\n     * @param {function} params.onError - Error handler indicating that the message was not delivered.\n     * @returns {Promise}\n     */\n    that.sendMessage = function (params) {\n        params = params || {};\n        params.id = that.id;\n        var promise;\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            promise = Q.reject(err);\n        }\n\n        return respoke.handlePromise(promise ? promise : signalingChannel.publish(params),\n                params.onSuccess, params.onError);\n    };\n\n    /**\n     * Get group members\n     *\n     * Get an array containing the members of the group. Accepts `onSuccess` or `onError` parameters,\n     * or a promise.\n     *\n     *     group.getMembers({\n     *         onSuccess: function (members) {\n     *             members.forEach(function (member) {\n     *                 // do something\n     *             });\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.getMembers\n     * @param {object} params\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Success handler for this invocation of this method only.\n     * @returns {Promise<Array>} A promise to an array of Connections.\n     */\n    that.getMembers = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        signalingChannel.getGroupMembers({\n            id: that.id\n        }).done(function successHandler(list) {\n            var endpointList = [];\n            list.forEach(function eachMember(params) {\n                var connection = client.getConnection({\n                    endpointId: params.endpointId,\n                    connectionId: params.connectionId,\n                    skipCreate: true\n                });\n\n                if (!connection) {\n                    // Create the connection\n                    connection = client.getConnection({\n                        endpointId: params.endpointId,\n                        connectionId: params.connectionId\n                    });\n                }\n\n                if (endpointList.indexOf(params.endpointId) === -1) {\n                    endpointList.push(params.endpointId);\n                }\n                that.addMember({\n                    connection: connection,\n                    skipEvent: true\n                });\n            });\n\n            deferred.resolve(that.connections);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return retVal;\n    };\n\n    return that;\n}; // End respoke.Group\n/**\n * Receive notification that an endpoint has joined this group. This callback is called everytime\n * respoke.Group#join is fired.\n * @callback respoke.Group.onJoin\n * @param {respoke.Event} evt\n * @param {respoke.Connection} evt.connection\n * @param {string} evt.name - the event name.\n * @param {respoke.Group} evt.target\n */\n/**\n * Receive notification that an endpoint has left this group. This callback is called everytime\n * respoke.Group#leave is fired.\n * @callback respoke.Group.onLeave\n * @param {respoke.Event} evt\n * @param {respoke.Connection} evt.connection\n * @param {string} evt.name - the event name.\n * @param {respoke.Group} evt.target\n */\n/**\n * Receive notification that a message has been received to a group. This callback is called every time\n * respoke.Group#message is fired.\n * @callback respoke.Group.onMessage\n * @param {respoke.Event} evt\n * @param {respoke.TextMessage} evt.message\n * @param {string} evt.name - the event name.\n * @param {respoke.Group} evt.target\n */\n/**\n * Get a list of the Connections which are members of this Group.\n * @callback respoke.Group.connectionsHandler\n * @param {Array<respoke.Connection>} connections\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/group.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar Q = require('q');\nvar io = require('socket.io-client');\nvar respoke = require('./respoke');\n\n/**\n * Returns a timestamp, measured in milliseconds.\n *\n * This method will use high resolution time, if available. Otherwise it falls back to just\n * using the wall clock.\n *\n * @return {number} Number of milliseconds that have passed since some point in the past.\n * @private\n */\nvar now;\nvar performance;\nif (performance && performance.now) {\n    now = performance.now.bind(performance);\n} else if (Date.now) {\n    now = Date.now.bind(Date);\n} else {\n    now = function () {\n        return new Date().getTime();\n    };\n}\n\n/**\n * Container for holding requests that are currently waiting on responses.\n * @returns {PendingRequests}\n * @private\n * @constructor\n */\nvar PendingRequests = function () {\n    /**\n     * Pending requests.\n     * @private\n     * @type {Array}\n     */\n    var contents = [];\n    /**\n     * Counter to provide the next id.\n     * @private\n     * @type {number}\n     */\n    var counter = 0;\n    var that = {};\n\n    /**\n     * Add a new pending request.\n     *\n     * @memberof PendingRequests\n     * @param obj\n     * @returns {*} The key to use for the `remove` method.\n     */\n    that.add = function (obj) {\n        contents[counter] = obj;\n        counter++;\n        return counter;\n    };\n\n    /**\n     * Remove a pending request.\n     *\n     * @param {*} key Key returned from `add` method.\n     */\n    that.remove = function (key) {\n        delete contents[key];\n    };\n\n    /**\n     * Disposes of any currently pending requests, synchronously invoking the provided function on\n     * each.\n     *\n     * @param {function} [fn] Callback for pending requests.\n     */\n    that.reset = function (fn) {\n        if (fn) {\n            contents.forEach(fn);\n        }\n        contents = [];\n    };\n\n    return that;\n};\n\n/**\n * The purpose of this class is to make a method call for each API call\n * to the backend REST interface.  This class takes care of App authentication, websocket connection,\n * Endpoint authentication, and all App interactions thereafter.  Almost all methods return a Promise.\n * @class respoke.SignalingChannel\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @private\n * @returns {respoke.SignalingChannel}\n */\nmodule.exports = function (params) {\n    params = params || {};\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name className\n     * @type {string}\n     * @private\n     */\n    that.className = 'respoke.SignalingChannel';\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name client\n     * @private\n     * @type {respoke.Client}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name socket\n     * @private\n     * @type {Socket.io.Socket}\n     */\n    var socket = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name clientSettings\n     * @private\n     * @type {object}\n     */\n    var clientSettings = params.clientSettings;\n    delete that.clientSettings;\n    clientSettings.baseURL = clientSettings.baseURL || 'https://api.respoke.io';\n    /**\n     * A map to avoid duplicate endpoint presence registrations.\n     * @memberof! respoke.SignalingChannel\n     * @name presenceRegistered\n     * @private\n     * @type {object}\n     */\n    var presenceRegistered = {};\n    /**\n     * A reference to the private function Client.actuallyConnect that gets set in SignalingChannel.open() so we\n     * don't have to make it public.\n     * @memberof! respoke.SignalingChannel\n     * @name actuallyConnect\n     * @private\n     * @type {function}\n     */\n    var actuallyConnect = null;\n    /**\n     * Set of promises for any pending requests on the WebSocket.\n     * @private\n     * @type {PendingRequests}\n     */\n    var pendingRequests = PendingRequests();\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name reconnectTimeout\n     * @private\n     * @type {number}\n     */\n    var reconnectTimeout = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name maxReconnectTimeout\n     * @private\n     * @type {number}\n     */\n    var maxReconnectTimeout = 5 * 60 * 1000;\n    /**\n     * Rejects a message if the body size is greater than this. It is enforced servcer side, so changing this\n     * won't make the bodySizeLimit any bigger, this just gives you a senseable error if it's too big.\n     * @memberof! respoke.signalingChannel\n     * @name bodySizeLimit\n     * @private\n     * @type {number}\n     */\n    var bodySizeLimit = 20000;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name appId\n     * @private\n     * @type {string}\n     */\n    var appId = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name endpointId\n     * @private\n     * @type {string}\n     */\n    var endpointId = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name token\n     * @private\n     * @type {string}\n     */\n    var token = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name appToken\n     * @private\n     * @type {string}\n     */\n    var appToken = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name xhr\n     * @private\n     * @type {XMLHttpRequest}\n     */\n    var xhr = new XMLHttpRequest();\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name routingMethods\n     * @private\n     * @type {object}\n     * @desc The methods contained in this object are statically defined methods that are called by constructing\n     * their names dynamically. 'do' + $className + $signalType == 'doCallOffer', et. al.\n     */\n    var routingMethods = {};\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name handlerQueue\n     * @private\n     * @type {object}\n     */\n    var handlerQueue = {\n        'message': [],\n        'signal': [],\n        'presence': []\n    };\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name errors\n     * @private\n     * @type {object}\n     */\n    var errors = {\n        400: \"Can't perform this action: missing or invalid parameters.\",\n        401: \"Can't perform this action: not authenticated.\",\n        403: \"Can't perform this action: not authorized.\",\n        404: \"Item not found.\",\n        409: \"Can't perform this action: item in the wrong state.\",\n        429: \"API rate limit was exceeded.\",\n        500: \"Can't perform this action: server problem.\"\n    };\n\n    /**\n     * Indicate whether the signaling channel has a valid connection to Respoke.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.isConnected\n     * @return {boolean}\n     */\n    that.isConnected = function () {\n        return !!(socket && socket.socket.connected);\n    };\n\n    /**\n     * Indicate whether the signaling channel is currently waiting on a websocket to connect.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.isConnecting\n     * @private\n     * @return {boolean}\n     */\n    function isConnecting() {\n        return !!(socket && socket.socket.connecting);\n    }\n\n    /**\n     * Get the call debug preference.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.isSendingReport\n     * @private\n     * @return {boolean}\n     */\n    that.isSendingReport = function (params) {\n        return  clientSettings.enableCallDebugReport;\n    };\n\n    /**\n     * Open a connection to the REST API and validate the app, creating a session token.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.open\n     * @private\n     * @param {object} params\n     * @param {string} [params.token] - The Endpoint's auth token\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @return {Promise}\n     */\n    that.open = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug('SignalingChannel.open', params, clientSettings);\n        token = params.token || token;\n        actuallyConnect = typeof params.actuallyConnect === 'function' ? params.actuallyConnect : actuallyConnect;\n\n        Q.fcall(function tokenPromise() {\n            if (clientSettings.developmentMode === true && clientSettings.appId && params.endpointId) {\n                return that.getToken({\n                    appId: clientSettings.appId,\n                    endpointId: params.endpointId\n                });\n            }\n            return null;\n        }).then(function successHandler(newToken) {\n            token = newToken || token;\n            return doOpen({token: token});\n        }).done(function successHandler() {\n            deferred.resolve();\n            log.debug('client', client);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Get a developer mode token for an endpoint. App must be in developer mode.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getToken\n     * @private\n     * @param {object} params\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @return {Promise<String>}\n     */\n    that.getToken = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug('SignalingChannel.getToken', params);\n\n        var callParams = {\n            path: '/v1/tokens',\n            httpMethod: 'POST',\n            parameters: {\n                appId: clientSettings.appId,\n                endpointId: params.endpointId,\n                ttl: 60 * 60 * 6\n            }\n        };\n\n        call(callParams).done(function (response) {\n            if (response.code === 200 && response.result && response.result.tokenId) {\n                token = response.result.tokenId;\n                deferred.resolve(response.result.tokenId);\n                return;\n            }\n            deferred.reject(new Error(\"Couldn't get a developer mode token: \" + response.error));\n        }, function (err) {\n            deferred.reject(new Error(\"Couldn't get a developer mode token: \" + err));\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * Open a connection to the REST API and validate the app, creating a session token.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.doOpen\n     * @param {object} params\n     * @param {string} params.token - The Endpoint's auth token\n     * @return {Promise}\n     * @private\n     */\n    function doOpen(params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug('SignalingChannel.doOpen', params);\n\n        if (!params.token) {\n            deferred.reject(new Error(\"Can't open connection to Respoke without a token.\"));\n            return deferred.promise;\n        }\n\n        call({\n            path: '/v1/session-tokens',\n            httpMethod: 'POST',\n            parameters: {\n                tokenId: params.token\n            }\n        }).done(function (response) {\n            if (response.code === 200) {\n                appToken = response.result.token;\n                deferred.resolve();\n                log.debug(\"Signaling connection open to\", clientSettings.baseURL);\n            } else {\n                deferred.reject(new Error(\"Couldn't authenticate app: \" + response.error));\n            }\n        }, function (err) {\n            log.error(\"Network call failed:\", err.message);\n            deferred.reject(new Error(\"Couldn't authenticate app: \" + err.message));\n        });\n\n        return deferred.promise;\n    }\n\n    /**\n     * Close a connection to the REST API. Invalidate the session token.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.close\n     * @private\n     * @param {object} params\n     * @return {Promise}\n     */\n    that.close = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n\n        wsCall({\n            path: '/v1/connections/%s/',\n            httpMethod: 'DELETE',\n            objectId: client.endpointId\n        }).fin(function finallyHandler() {\n            return call({\n                path: '/v1/session-tokens',\n                httpMethod: 'DELETE'\n            });\n        }).fin(function finallyHandler() {\n            if (socket) {\n                socket.removeAllListeners();\n                socket.disconnect();\n            }\n            deferred.resolve();\n        }).done();\n\n        return deferred.promise;\n    };\n\n    /**\n     * Generate and send a presence message representing the client's current status. This triggers\n     * the server to send the client's endpoint's presence.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendPresence\n     * @private\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=available]\n     * @param {string} [params.status] - Non-enumeration human-readable status.\n     * @param {string} [params.show] - I can't remember what this is.\n     * @returns {Promise}\n     */\n    that.sendPresence = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug(\"Signaling sendPresence\");\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/presence',\n            httpMethod: 'POST',\n            parameters: {\n                'presence': {\n                    show: params.show,\n                    'status': params.status,\n                    type: params.presence || \"available\"\n                }\n            }\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * Get or create a group in the infrastructure.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getGroup\n     * @private\n     * @returns {Promise<respoke.Group>}\n     * @param {object} params\n     * @param {string} name\n     */\n    that.getGroup = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug('signalingChannel.getGroup');\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            httpMethod: 'POST',\n            path: '/v1/channels/',\n            parameters: {\n                name: params.name\n            }\n        }).then(function successHandler(group) {\n            deferred.resolve(group);\n        }, function errorHandler(err) {\n            // Group was already created, just return back the same params we were given.\n            deferred.resolve({id: params.name});\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Leave a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n     * issued. The same instance of Promise is returned each time.\n     * @memberof! respoke.SignalingChannel\n     * @private\n     * @method respoke.SignalingChannel.leaveGroup\n     * @returns {Promise}\n     * @param {object} params\n     * @param {array} params.groupList\n     */\n    that.leaveGroup = (function () {\n        var groups = {};\n        var deferred = Q.defer();\n\n        return function (params) {\n            params = params || {};\n            params.groupList = params.groupList || [];\n\n            var toRun = (Object.keys(groups).length === 0);\n\n            if (!that.isConnected()) {\n                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n                return deferred.promise;\n            }\n\n            params.groupList.forEach(function (id) {\n                if (typeof id === 'string') {\n                    groups[id] = true;\n                }\n            });\n\n            if (!toRun) {\n                return deferred.promise;\n            }\n\n            setTimeout(function () {\n                // restart accumulation\n                var groupList = Object.keys(groups);\n                groups = {};\n                var saveDeferred = deferred;\n                deferred = Q.defer();\n\n                if (groupList.length === 0) {\n                    saveDeferred.resolve();\n                    return;\n                }\n\n                wsCall({\n                    path: '/v1/groups/',\n                    parameters: {\n                        groups: groupList\n                    },\n                    httpMethod: 'DELETE'\n                }).done(function successHandler() {\n                    saveDeferred.resolve();\n                }, function errorHandler(err) {\n                    saveDeferred.reject(err);\n                });\n            });\n            return deferred.promise;\n        };\n    })();\n\n    /**\n     * Join a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n     * issued. The same instance of Promise is returned each time.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.joinGroup\n     * @private\n     * @returns {Promise}\n     * @param {object} params\n     * @param {array} params.groupList\n     */\n    that.joinGroup = (function () {\n        var groups = {};\n        var deferred = Q.defer();\n\n        return function (params) {\n            params = params || {};\n            params.groupList = params.groupList || [];\n\n            var toRun = (Object.keys(groups).length === 0);\n\n            if (!that.isConnected()) {\n                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n                return deferred.promise;\n            }\n\n            params.groupList.forEach(function (id) {\n                if (typeof id === 'string') {\n                    groups[id] = true;\n                }\n            });\n\n            if (!toRun) {\n                return deferred.promise;\n            }\n\n            setTimeout(function () {\n                // restart accumulation\n                var groupList = Object.keys(groups);\n                groups = {};\n                var saveDeferred = deferred;\n                deferred = Q.defer();\n\n                if (groupList.length === 0) {\n                    saveDeferred.resolve();\n                    return;\n                }\n\n                wsCall({\n                    path: '/v1/groups/',\n                    parameters: {\n                        groups: groupList\n                    },\n                    httpMethod: 'POST'\n                }).done(function successHandler() {\n                    saveDeferred.resolve();\n                }, function errorHandler(err) {\n                    saveDeferred.reject(err);\n                });\n            });\n            return deferred.promise;\n        };\n    })();\n\n    /**\n     * Publish a message to a group.\n     * @memberof! respoke.SignalingChannel\n     * @private\n     * @method respoke.SignalingChannel.publish\n     * @returns {Promise}\n     * @param {object} params\n     * @param {string} params.id\n     * @param {string} params.message\n     */\n    that.publish = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var message = respoke.TextMessage({\n            endpointId: params.id,\n            message: params.message\n        });\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/channels/%s/publish/',\n            objectId: params.id,\n            httpMethod: 'POST',\n            parameters: message\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * Register as an observer of presence for the specified endpoint ids. In order to aggregate subsequent repeated\n     * requests, this function, when called synchronously, will continue to accumulate endpoint ids until the next\n     * tick of the event loop, when the request will be issued. The same instance of Promise is returned each time.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.registerPresence\n     * @private\n     * @param {object} params\n     * @param {Array<string>} params.endpointList\n     * @returns {Promise}\n     */\n    that.registerPresence = (function () {\n        var endpoints = {};\n        var deferred = Q.defer();\n\n        return function (params) {\n            params = params || {};\n            params.endpointList = params.endpointList || [];\n            var toRun = (Object.keys(endpoints).length === 0);\n\n            if (!that.isConnected()) {\n                return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            }\n\n            params.endpointList.forEach(function (ep) {\n                if (typeof ep === 'string' && presenceRegistered[ep] !== true) {\n                    endpoints[ep] = true;\n                }\n            });\n\n            if (!toRun) {\n                return deferred.promise;\n            }\n\n            setTimeout(function () {\n                // restart accumulation\n                var endpointList = Object.keys(endpoints);\n                endpoints = {};\n                var saveDeferred = deferred;\n                deferred = Q.defer();\n\n                if (endpointList.length === 0) {\n                    saveDeferred.resolve();\n                    return;\n                }\n\n                wsCall({\n                    httpMethod: 'POST',\n                    path: '/v1/presenceobservers',\n                    parameters: {\n                        endpointList: endpointList\n                    }\n                }).done(function successHandler() {\n                    params.endpointList.forEach(function eachId(id) {\n                        presenceRegistered[id] = true;\n                    });\n                    saveDeferred.resolve();\n                }, function (err) {\n                    saveDeferred.reject(err);\n                });\n            // We could even add a tiny delay like 10ms if we want to get more conservative and\n            // catch asychronous calls to client.getEndpoint() and other methods which call\n            // this method.\n            });\n\n            return deferred.promise;\n        }\n    })();\n\n    /**\n     * Join a group.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getGroupMembers\n     * @private\n     * @returns {Promise<Array>}\n     * @param {object} params\n     * @param {string} params.id\n     */\n    that.getGroupMembers = function (params) {\n        var deferred = Q.defer();\n        var promise;\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        if (!params.id) {\n            deferred.reject(new Error(\"Can't get group's endpoints without group ID.\"));\n            return deferred.promise;\n        }\n\n        promise = wsCall({\n            path: '/v1/channels/%s/subscribers/',\n            objectId: params.id,\n            httpMethod: 'GET'\n        });\n\n        promise.done(function successHandler(list) {\n            list.forEach(function eachSubscriber(params) {\n                presenceRegistered[params.endpointId] = true;\n            });\n        });\n        return promise;\n    };\n\n    /**\n     * Send a chat message.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendMessage\n     * @private\n     * @param {object} params\n     * @param {respoke.SignalingMessage} params.message - The string text message to send.\n     * @param {respoke.Endpoint} params.recipient\n     * @param {string} [params.connectionId]\n     * @returns {Promise}\n     */\n    that.sendMessage = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var message = respoke.TextMessage({\n            endpointId: params.recipient.id,\n            connectionId: params.connectionId,\n            message: params.message\n        });\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/messages',\n            httpMethod: 'POST',\n            parameters: message\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * Send an ACK signal to acknowlege reception of a signal.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendACK\n     * @private\n     * @param {object} params\n     * @param {respoke.SignalingMessage} params.signal\n     * @return {Promise}\n     */\n    that.sendACK = function (params) {\n        var endpoint;\n        params = params || {};\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        if (!params.signal) {\n            return Q.reject(new Error(\"Can't send ACK, no signal was given.\"));\n        }\n\n        endpoint = client.getEndpoint({\n            id: params.signal.fromEndpoint,\n            skipPresence: true\n        });\n        if (!endpoint) {\n            return Q.reject(new Error(\"Can't send ACK, can't get endpoint.\"));\n        }\n\n        return that.sendSignal({\n            recipient: endpoint,\n            signalType: 'ack',\n            signalId: params.signal.signalId,\n            sessionId: params.signal.sessionId,\n            target: params.signal.target,\n            ackedSignalType: params.signal.signalType\n        });\n    };\n\n    /**\n     * Send a signaling message.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendSignal\n     * @private\n     * @param {object} params\n     * @param {respoke.Call} [params.call] - For getting the sessionId & connectionId. Not required for 'ack'.\n     * @return {Promise}\n     */\n    that.sendSignal = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var signal;\n        var to;\n        var toConnection;\n        var toType;\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        if (params.call) {\n            params.sessionId = params.call.id;\n            if (params.call.connectionId) { // the recipient's connectionId\n                params.connectionId = params.call.connectionId;\n            }\n        }\n\n        to = params.recipient.id;\n        toConnection = params.connectionId;\n        toType = params.toType || 'web';\n\n        //hack\n        if (params.signalType === 'iceCandidates' && window.webrtcDetectedType === 'plugin') {\n            var keys = ['candidate', 'sdpMLineIndex', 'sdpMid'];\n\n            var candidate = {};\n\n            keys.forEach(function(key){\n                candidate[key] = params.candidate[key];\n            });\n\n            params.candidate = candidate;\n\n            var iceCandidates = [];\n\n            params.iceCandidates.forEach(function(jsapiObject){\n                var ic = {};\n                keys.forEach(function(key){\n                    ic[key] = jsapiObject[key];\n                });\n                iceCandidates.push(ic);\n            });\n\n            params.iceCandidates = iceCandidates;\n\n        }\n\n        try {\n            params.signalId = respoke.makeGUID();\n            // This will strip off non-signaling attributes.\n            signal = respoke.SignalingMessage(params);\n        } catch (e) {\n            deferred.reject(e);\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/signaling',\n            httpMethod: 'POST',\n            parameters: {\n                signal: JSON.stringify(signal),\n                to: to,\n                toConnection: toConnection,\n                toType: toType\n            }\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Send an ICE candidate.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendCandidate\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} [params.connectionId]\n     * @param {Array<RTCIceCandidate>} params.iceCandidates - An array of ICE candidate.\n     * @return {Promise}\n     */\n    that.sendCandidate = function (params) {\n        params = params || {};\n        params.signalType = 'iceCandidates';\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send an SDP.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendSDP\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} [params.connectionId]\n     * @param {RTCSessionDescription} params.sessionDescription - An SDP to JSONify and send.\n     * @return {Promise}\n     */\n    that.sendSDP = function (params) {\n        params = params || {};\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        if (['offer', 'answer'].indexOf(params.signalType) === -1) {\n            return Q.reject(\"Not an SDP type signal.\");\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send a call report to the cloud infrastructure.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendReport\n     * @private\n     * @param {object} params\n     * @todo TODO document the params.\n     * @return {Promise}\n     */\n    that.sendReport = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var message = {\n            debugData: params\n        };\n\n        if (!clientSettings.enableCallDebugReport) {\n            log.debug('not sending call debugs - disabled');\n            deferred.resolve();\n            return deferred.promise;\n        }\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/call-debugs',\n            httpMethod: 'POST',\n            parameters: message\n        }).done(function () {\n            deferred.resolve();\n        }, function (err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Send a message hanging up the WebRTC session.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendHangup\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} [params.connectionId]\n     * @param {string} params.reason - The reason the session is being hung up.\n     * @return {Promise}\n     */\n    that.sendHangup = function (params) {\n        params = params || {};\n        params.signalType = 'bye';\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send a message to all connection ids indicating we have negotiated a call with one connection.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendConnected\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @return {Promise}\n     */\n    that.sendConnected = function (params) {\n        params = params || {};\n        params.signalType = 'connected';\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send a message to the remote party indicating a desire to renegotiate media.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendModify\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} params.action - The state of the modify request, one of: 'initiate', 'accept', 'reject'\n     * @return {Promise}\n     */\n    that.sendModify = function (params) {\n        params = params || {};\n        params.signalType = 'modify';\n\n        if (['initiate', 'accept', 'reject'].indexOf(params.action) === -1) {\n            return Q.reject(\"No valid action in modify signal.\");\n        }\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Uppercase the first letter of the word.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.firstUpper\n     * @private\n     */\n    function firstUpper(str) {\n        return str[0].toUpperCase() + str.slice(1);\n    }\n\n    /**\n     * Route different types of signaling messages via events.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routeSignal\n     * @private\n     * @param {respoke.SignalingMessage} message - A message to route\n     * @fires respoke.Call#offer\n     * @fires respoke.Call#connected\n     * @fires respoke.Call#answer\n     * @fires respoke.Call#iceCandidates\n     * @fires respoke.Call#hangup\n     * @fires respoke.DirectConnection#offer\n     * @fires respoke.DirectConnection#connected\n     * @fires respoke.DirectConnection#answer\n     * @fires respoke.DirectConnection#iceCandidates\n     * @fires respoke.DirectConnection#hangup\n     */\n    that.routeSignal = function (signal) {\n        var target = null;\n        var method = 'do';\n\n        if (signal.signalType !== 'iceCandidates') { // Too many of these!\n            log.debug(signal.signalType, signal);\n        }\n\n        if (signal.target === undefined) {\n            throw new Error(\"target undefined\");\n        }\n\n        // Only create if this signal is an offer.\n        Q.fcall(function makePromise() {\n            var endpoint;\n            /*\n             * This will return calls regardless of whether they are associated\n             * with a direct connection or not, and it will create a call if no\n             * call is found and this signal is an offer. Direct connections get\n             * created in the next step.\n             */\n            target = client.getCall({\n                id: signal.sessionId,\n                endpointId: signal.fromEndpoint,\n                fromType: signal.fromType,\n                create: (signal.target === 'call' && signal.signalType === 'offer')\n            });\n            if (target) {\n                return target;\n            }\n\n            if (signal.target === 'directConnection') {\n                // return a promise\n                endpoint = client.getEndpoint({\n                    id: signal.fromEndpoint,\n                    skipPresence: true\n                });\n\n                if (endpoint.directConnection && endpoint.directConnection.call.id === signal.sessionId) {\n                    return endpoint.directConnection;\n                }\n\n                return endpoint.startDirectConnection({\n                    id: signal.sessionId,\n                    create: (signal.signalType === 'offer'),\n                    caller: (signal.signalType !== 'offer')\n                });\n            }\n        }).done(function successHandler(target) {\n            // target might be null, a Call, or a DirectConnection.\n            if (target) {\n                target = target.call || target;\n            }\n            if (!target || target.id !== signal.sessionId) {\n                // orphaned signal\n                log.warn(\"Couldn't associate signal with a call.\", signal);\n                return;\n            }\n\n            method += firstUpper(signal.signalType);\n            routingMethods[method]({\n                call: target,\n                signal: signal\n            });\n        }, null);\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doOffer\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-offer\n     */\n    routingMethods.doOffer = function (params) {\n        params.call.connectionId = params.signal.fromConnection;\n        /**\n         * @event respoke.Call#signal-offer\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-offer', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doConnected\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-connected\n     */\n    routingMethods.doConnected = function (params) {\n        /**\n         * @event respoke.Call#signal-connected\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-connected', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.dModify\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-modify\n     */\n    routingMethods.doModify = function (params) {\n        /**\n         * @event respoke.Call#signal-modify\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-modify', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doAnswer\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-answer\n     */\n    routingMethods.doAnswer = function (params) {\n        params.call.connectionId = params.signal.fromConnection;\n        /**\n         * @event respoke.Call#signal-answer\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-answer', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doIceCandidates\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-icecandidates\n     */\n    routingMethods.doIceCandidates = function (params) {\n        /**\n         * @event respoke.Call#signal-icecandidates\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-icecandidates', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doBye\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-hangup\n     */\n    routingMethods.doBye = function (params) {\n        /**\n         *  We may receive hangup from one or more parties after connectionId is set if the call is rejected\n         *  by a connection that didn't win the call. In this case, we have to ignore the signal since\n         *  we are already on a call. TODO: this should really be inside PeerConnection.\n         */\n        if (params.call.connectionId && params.call.connectionId !== params.signal.fromConnection) {\n            return;\n        }\n        /**\n         * @event respoke.Call#signal-hangup\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-hangup', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doUnknown\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     */\n    routingMethods.doUnknown = function (params) {\n        log.error(\"Don't know what to do with\", params.signal.target, \"msg of unknown type\", params.signal.signalType);\n    };\n\n    /**\n     * Add a handler to the connection for messages of different types.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.addHandler\n     * @private\n     * @param {object} params\n     * @param {string} params.type - The type of socket message, i. e., 'message', 'presence', 'join'\n     * @param {function} params.handler - A function to which to pass the message\n     * @todo TODO See if this is necessary anymore\n     */\n    that.addHandler = function (params) {\n        if (socket.socket && socket.socket.open) {\n            socket.on(params.type, params.handler);\n        } else {\n            handlerQueue[params.type].push(params.handler);\n        }\n    };\n\n    /**\n     * Socket handler for pub-sub messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.onPubSub\n     * @param {object} message The Socket.io message.\n     * @private\n     * @fires respoke.Group#message\n     * @fires respoke.Client#message\n     */\n    var onPubSub = function onPubSub(message) {\n        var group;\n        var groupMessage;\n\n        if (message.header.from === client.endpointId) {\n            return;\n        }\n\n        groupMessage = respoke.TextMessage({\n            rawMessage: message\n        });\n\n        group = client.getGroup({id: message.header.channel});\n        if (group) {\n            /**\n             * @event respoke.Group#message\n             * @type {respoke.Event}\n             * @property {respoke.TextMessage} message\n             * @property {string} name - the event name.\n             * @property {respoke.Group} target\n             */\n            group.fire('message', {\n                message: groupMessage\n            });\n        }\n        /**\n         * @event respoke.Client#message\n         * @type {respoke.Event}\n         * @property {respoke.TextMessage} message\n         * @property {respoke.Group} [group] - If the message is to a group we already know about,\n         * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n         * the group. From that point forward, Group#message will fire when a message is received as well. If\n         * group is undefined instead of null, the message is not a group message at all.\n         * @property {string} name - the event name.\n         * @property {respoke.Client} target\n         */\n        client.fire('message', {\n            message: groupMessage,\n            group: group || null\n        });\n    };\n\n    /**\n     * Socket handler for join messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.onJoin\n     * @param {object} message The Socket.io message.\n     * @private\n     */\n    var onJoin = function onJoin(message) {\n        var group;\n        var presenceMessage;\n        var endpoint;\n        var connection;\n\n        if (message.connectionId === client.connectionId) {\n            connection = client.getConnection({connectionId: message.connectionId, endpointId: message.endpointId});\n            group = client.getGroup({id: message.header.channel});\n            if (!group) {\n                group = respoke.Group({\n                    id: message.header.channel,\n                    instanceId: instanceId,\n                    signalingChannel: that\n                });\n                client.addGroup(group);\n            }\n            if (!group.isJoined()) {\n                group.addMember({connection: connection});\n                client.fire('join', {\n                    group: group\n                });\n            }\n        } else {\n\n            endpoint = client.getEndpoint({\n                skipPresence: true,\n                id: message.endpointId,\n                instanceId: instanceId,\n                name: message.endpointId\n            });\n\n            // Handle presence not associated with a channel\n            if (!connection) {\n                endpoint.setPresence({\n                    connectionId: message.connectionId\n                });\n                connection = client.getConnection({\n                    connectionId: message.connectionId,\n                    endpointId: message.endpointId\n                });\n            }\n\n            group = client.getGroup({id: message.header.channel});\n\n            if (group && connection) {\n                group.addMember({connection: connection});\n            } else {\n                log.error(\"Can't add endpoint to group:\", message, group, endpoint, connection);\n            }\n        }\n    };\n\n    /**\n     * Socket handler for leave messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.onLeave\n     * @param {object} message The Socket.io message.\n     * @private\n     */\n    var onLeave = function onLeave(message) {\n        var group;\n        var presenceMessage;\n        var endpoint;\n        if (message.connectionId === client.connectionId) {\n            group = client.getGroup({id: message.header.channel});\n            client.fire('leave', {\n                group: group\n            });\n        } else {\n\n            endpoint = client.getEndpoint({\n                skipPresence: true,\n                id: message.endpointId\n            });\n\n            endpoint.connections.every(function eachConnection(conn, index) {\n                if (conn.id === message.connectionId) {\n                    endpoint.connections.splice(index, 1);\n                    return false;\n                }\n                return true;\n            });\n\n            group = client.getGroup({id: message.header.channel});\n            group.removeMember({connectionId: message.connectionId});\n        }\n    };\n\n    /**\n     * Socket handler for presence messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.onMessage\n     * @param {object} message The Socket.io message.\n     * @private\n     * @fires respoke.Endpoint#message\n     * @fires respoke.Client#message\n     */\n    var onMessage = function onMessage(message) {\n        var endpoint;\n        message = respoke.TextMessage({rawMessage: message});\n        if (message.endpointId) {\n            endpoint = client.getEndpoint({\n                id: message.endpointId,\n                skipCreate: true\n            });\n        }\n        if (endpoint) {\n            /**\n             * @event respoke.Endpoint#message\n             * @type {respoke.Event}\n             * @property {respoke.TextMessage} message\n             * @property {string} name - the event name.\n             * @property {respoke.Endpoint} target\n             */\n            endpoint.fire('message', {\n                message: message\n            });\n        }\n        /**\n         * @event respoke.Client#message\n         * @type {respoke.Event}\n         * @property {respoke.TextMessage} message\n         * @property {respoke.Endpoint} [endpoint] - If the message is from an endpoint we already know about,\n         * this will be set. If null, the developer can use client.getEndpoint({id: evt.message.endpointId}) to get\n         * the Endpoint. From that point forward, Endpoint#message will fire when a message is received as well.\n         * @property {string} name - the event name.\n         * @property {respoke.Client} target\n         */\n        client.fire('message', {\n            endpoint: endpoint || null,\n            message: message\n        });\n    };\n\n    /**\n     * Create a socket handler for the onConnect event with all the right things in scope.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.generateConnectHandler\n     * @param {respoke.Client.successHandler} [onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [onError] - Error handler for this invocation of this\n     * method only.\n     * @private\n     */\n    var generateConnectHandler = function generateConnectHandler(onSuccess, onError) {\n        onSuccess = onSuccess || function () {};\n        onError = onError || function () {};\n        return function onConnect() {\n            Object.keys(handlerQueue).forEach(function addEachHandlerType(category) {\n                if (!handlerQueue[category]) {\n                    return;\n                }\n\n                handlerQueue[category].forEach(function addEachHandler(handler) {\n                    socket.on(category, handler);\n                });\n                handlerQueue[category] = [];\n            });\n\n            wsCall({\n                path: '/v1/connections',\n                httpMethod: 'POST'\n            }).done(function successHandler(res) {\n                log.debug('connections result', res);\n                client.endpointId = res.endpointId;\n                client.connectionId = res.id;\n                onSuccess();\n            }, onError);\n        };\n    };\n\n    /**\n     * Socket handler for presence messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.onPresence\n     * @param {object} message The Socket.io message.\n     * @private\n     */\n    function onPresence(message) {\n        var endpoint;\n        var groups;\n\n        if (message.header.from === client.endpointId) {\n            // Skip ourselves\n            return;\n        }\n        log.debug('socket.on presence', message);\n\n        endpoint = client.getEndpoint({\n            skipPresence: true,\n            id: message.header.from,\n            instanceId: instanceId,\n            name: message.header.from,\n            connection: message.header.fromConnection\n        });\n\n        endpoint.setPresence({\n            connectionId: message.header.fromConnection,\n            presence: message.type\n        });\n\n        if (endpoint.getPresence() === 'unavailable') {\n            var groups = client.getGroups();\n            if (groups) {\n                groups.forEach(function eachGroup(group) {\n                    group.removeMember({connectionId: message.header.fromConnection});\n                });\n            }\n        }\n    }\n\n    /*\n     * On reconnect, start with a reconnect interval of 2000ms. Every time reconnect fails, the interval\n     * is doubled up to a maximum of 5 minutes. From then on, it will attempt to reconnect every 5 minutes forever.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.reconnect\n     * @private\n     */\n    function reconnect() {\n        appToken = undefined;\n        token = undefined;\n        reconnectTimeout = (reconnectTimeout === null) ? 2500 : 2 * reconnectTimeout;\n\n        if (reconnectTimeout > (maxReconnectTimeout)) {\n            reconnectTimeout = maxReconnectTimeout;\n        }\n\n        setTimeout(function doReconnect() {\n            actuallyConnect().then(function successHandler() {\n                reconnectTimeout = null;\n                log.debug('socket reconnected');\n                return Q.all(client.getGroups().map(function iterGroups(group) {\n                    client.join({\n                        id: group.id,\n                        onMessage: clientSettings.onMessage,\n                        onJoin: clientSettings.onJoin,\n                        onLeave: clientSettings.onLeave\n                    });\n                }));\n            }).done(function successHandler(user) {\n                /**\n                 * @event respoke.Client#reconnect\n                 * @property {string} name - the event name.\n                 * @property {respoke.Client}\n                 */\n                client.fire('reconnect');\n            }, function (err) {\n                log.error(\"Couldn't rejoin previous groups.\", err.message, err.stack);\n                reconnect();\n            });\n        }, reconnectTimeout);\n    }\n\n    /**\n     * Authenticate to the cloud and call the handler on state change.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.authenticate\n     * @private\n     * @param {object} params\n     * @return {Promise}\n     */\n    that.authenticate = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var pieces = [];\n        var protocol = null;\n        var host = null;\n        var port = null;\n\n        if (!appToken) {\n            deferred.reject(new Error(\"Can't open a websocket without an app token.\"));\n        }\n\n        pieces = clientSettings.baseURL.split(/:\\/\\//);\n        protocol = pieces[0];\n        pieces = pieces[1].split(/:/);\n        host = pieces[0];\n        port = pieces[1];\n\n        /*\n         * Try to connect for 2 seconds before failing.\n         * @private\n         */\n        var connectParams = {\n            'connect timeout': 2000,\n            'force new connection': true, // Don't try to reuse old connection.\n            'sync disconnect on unload': true, // have Socket.io call disconnect() on the browser unload event.\n            reconnect: false,\n            host: host,\n            port: port || '443',\n            protocol: protocol,\n            secure: (protocol === 'https'),\n            query: '__sails_io_sdk_version=0.10.0&app-token=' + appToken\n        };\n\n        if (that.isConnected() || isConnecting()) {\n            return;\n        }\n        socket = io.connect(clientSettings.baseURL, connectParams);\n\n        socket.on('connect', generateConnectHandler(function onSuccess() {\n            deferred.resolve();\n        }, function onError(err) {\n            deferred.reject(err);\n        }));\n\n        socket.on('join', onJoin);\n        socket.on('leave', onLeave);\n        socket.on('pubsub', onPubSub);\n        socket.on('message', onMessage);\n        socket.on('presence', onPresence);\n\n        // connection timeout\n        socket.on('connect_failed', function connectFailedHandler(res) {\n            deferred.reject(new Error(\"WebSocket connection failed.\"));\n            log.error('Socket.io connect timeout.', res || \"\");\n            reconnect();\n        });\n\n        // handshake error, 403\n        socket.on('error', function errorHandler(res) {\n            log.debug('Socket.io request failed.', res || \"\");\n            reconnect();\n        });\n\n        that.addHandler({\n            type: 'signal',\n            handler: function signalHandler(message) {\n                var knownSignals = ['offer', 'answer', 'connected', 'modify', 'iceCandidates', 'bye'];\n                var signal = respoke.SignalingMessage({\n                    rawMessage: message\n                });\n\n                if (signal.signalType === 'ack') {\n                    return;\n                }\n\n                if (!signal.target || !signal.signalType || knownSignals.indexOf(signal.signalType) === -1) {\n                    log.error(\"Got malformed signal.\", signal);\n                    throw new Error(\"Can't route signal without target or type.\");\n                }\n\n                that.routeSignal(signal);\n            }\n        });\n\n        socket.on('disconnect', function onDisconnect() {\n            pendingRequests.reset(function (pendingRequest) {\n                log.debug('Failing pending requests');\n                pendingRequest.reject(new Error(\"WebSocket disconnected\"));\n            });\n\n            /**\n             * @event respoke.Client#disconnect\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            client.fire('disconnect');\n\n            if (clientSettings.reconnect !== true) {\n                socket = null;\n                return;\n            }\n            reconnect();\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Get ephemeral TURN credentials.  This method is called whenever a call is either\n     * sent or received, prior to creating a PeerConnection\n     *\n     * @memberof! respoke.SignalingChannel\n     * @private\n     * @method respoke.SignalingChannel.getTurnCredentials\n     * @return {Promise<Array>}\n     */\n    that.getTurnCredentials = function () {\n        var deferred = Q.defer();\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            httpMethod: 'GET',\n            path: '/v1/turn'\n        }).done(function successHandler(creds) {\n            var result = [];\n\n            if (!creds || !creds.uris) {\n                deferred.reject(new Error(\"Turn credentials empty.\"));\n                return;\n            }\n\n            creds.uris.forEach(function saveTurnUri(uri) {\n                var cred = null;\n\n                if (!uri) {\n                    return;\n                }\n\n                cred = createIceServer(uri, creds.username, creds.password);\n                result.push(cred);\n            });\n\n            if (result.length === 0) {\n                deferred.reject(new Error(\"Got no TURN credentials.\"));\n            }\n\n            log.debug('TURN creds', result);\n            deferred.resolve(result);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Construct a websocket API call and return the formatted response and errors. The 'success'\n     * attribute indicates the success or failure of the API call. The 'response' attribute\n     * is an associative array constructed by json.decode. The 'error' attriute is a message.\n     * If the API call is successful but the server returns invalid JSON, error will be\n     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.wsCall\n     * @private\n     * @param {object} params\n     * @param {string} params.httpMethod\n     * @param {string} params.path\n     * @param {string} params.objectId\n     * @param {object} params.parameters\n     * @return {Promise<object>}\n     */\n    function wsCall(params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var start = now();\n        // Too many of these!\n        var logRequest = params.path.indexOf('messages') === -1 && params.path.indexOf('signaling') === -1;\n        var request;\n        var bodyLength = 0;\n        if (params.paramaters) {\n            bodyLength = encodeURI(JSON.stringify(params.parameters)).split(/%..|./).length - 1;\n        }\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        if (!params) {\n            deferred.reject(new Error('No params.'));\n            return deferred.promise;\n        }\n\n        if (!params.path) {\n            deferred.reject(new Error('No request path.'));\n            return deferred.promise;\n        }\n\n        if (bodyLength > bodySizeLimit) {\n            deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n            return deferred.promise;\n        }\n\n        params.httpMethod = (params.httpMethod || 'get').toLowerCase();\n\n        if (params.objectId) {\n            params.path = params.path.replace(/\\%s/ig, params.objectId);\n        }\n\n        if (logRequest) {\n            log.debug('socket request', {\n                method: params.httpMethod,\n                path: params.path,\n                parameters: params.parameters\n            });\n        }\n\n        request = {\n            method: params.httpMethod,\n            path: params.path,\n            parameters: params.parameters,\n            tries: 0,\n            durationMillis: 0\n        };\n\n        request.id = pendingRequests.add(deferred);\n\n        function handleResponse(response) {\n            /*\n             * Response:\n             *  {\n             *      body: {},\n             *      headers: {},\n             *      statusCode: 200\n             *  }\n             */\n            try {\n                response.body = JSON.parse(response.body);\n            } catch (e) {\n                if (typeof response.body !== 'object') {\n                    deferred.reject(new Error(\"Server response could not be parsed!\" + response.body));\n                    return;\n                }\n            }\n\n            if (response.statusCode === 429) {\n                if (request.tries < 3 && deferred.promise.isPending()) {\n                    setTimeout(function () {\n                        start = now();\n                        sendWebsocketRequest(request, handleResponse);\n                    }, 1000); // one day this will be response.interval or something\n                } else {\n                    request.durationMillis = now() - start;\n                    pendingRequests.remove(request.id);\n                    failWebsocketRequest(request, response.body,\n                            \"Too many retries after rate limit exceeded.\", deferred);\n                }\n                return;\n            }\n\n            request.durationMillis = now() - start;\n            pendingRequests.remove(request.id);\n\n            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(this.status) === -1) {\n                failWebsocketRequest(request, response.body,\n                        response.body.error || errors[this.status] || \"Unknown error\", deferred);\n            } else {\n                deferred.resolve(response.body);\n            }\n\n            if (logRequest) {\n                log.debug('socket response', {\n                    method: request.method,\n                    path: request.path,\n                    durationMillis: request.durationMillis,\n                    response: response.body\n                });\n            }\n        }\n\n        start = now();\n        sendWebsocketRequest(request, handleResponse);\n        return deferred.promise;\n    }\n\n    function failWebsocketRequest(request, response, error, deferred) {\n        if (response && response.error) {\n            deferred.reject(new Error(error + '(' + request.method + ' ' + params.path + ')'));\n        } else {\n            deferred.resolve(response);\n        }\n    }\n\n    function sendWebsocketRequest(request, handleResponse) {\n        request.tries += 1;\n        socket.emit(request.method, JSON.stringify({\n            url: request.path,\n            data: request.parameters,\n            headers: {'App-Token': appToken}\n        }), handleResponse);\n    }\n\n    /**\n     * Construct an API call and return the formatted response and errors. The 'success'\n     * attribute indicates the success or failure of the API call. The 'response' attribute\n     * is an associative array constructed by json.decode. The 'error' attribute is a message.\n     * If the API call is successful but the server returns invalid JSON, error will be\n     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.call\n     * @private\n     * @param {object} params\n     * @param {string} params.httpMethod\n     * @param {string} params.objectId\n     * @param {string} params.path\n     * @param {object} params.parameters\n     * @returns {Promise}\n     */\n    function call(params) {\n        /* Params go in the URI for GET, DELETE, same format for\n         * POST and PUT, but they must be sent separately after the\n         * request is opened. */\n        var deferred = Q.defer();\n        var paramString = null;\n        var uri = null;\n        var response = {\n            'result': null,\n            'code': null\n        };\n        var start;\n\n        uri = clientSettings.baseURL + params.path;\n\n        if (!params) {\n            deferred.reject(new Error('No params.'));\n            return;\n        }\n\n        if (!params.httpMethod) {\n            deferred.reject(new Error('No HTTP method.'));\n            return;\n        }\n\n        if (!params.path) {\n            deferred.reject(new Error('No request path.'));\n            return;\n        }\n\n        if (params.objectId) {\n            params.path = params.path.replace(/\\%s/ig, params.objectId);\n        }\n\n        if (['GET', 'DELETE'].indexOf(params.httpMethod) > -1) {\n            uri += makeParamString(params.parameters);\n        }\n\n        xhr.open(params.httpMethod, uri);\n        if (appToken) {\n            xhr.setRequestHeader(\"App-Token\", appToken);\n        }\n        if (['POST', 'PUT'].indexOf(params.httpMethod) > -1) {\n            paramString = JSON.stringify(params.parameters);\n            if (paramString.length > bodySizeLimit) {\n                deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n                return;\n            }\n            xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n        } else if (['GET', 'DELETE'].indexOf(params.httpMethod) === -1) {\n            deferred.reject(new Error('Illegal HTTP request method ' + params.httpMethod));\n            return;\n        }\n        log.debug('request', {\n            method: params.httpMethod,\n            uri: uri,\n            params: paramString\n        });\n\n        try {\n            xhr.send(paramString);\n        } catch (err) {\n            deferred.reject(err);\n            return;\n        }\n\n        xhr.onreadystatechange = function () {\n            var durationMillis = now() - start;\n            var limit;\n            var unit;\n\n            if (this.readyState !== 4) {\n                return;\n            }\n            if (this.status === 0) {\n                deferred.reject(new Error(\"Status is 0: Incomplete request, SSL error, or CORS error.\"));\n                return;\n            }\n            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(this.status) > -1) {\n                response.code = this.status;\n                response.uri = uri;\n                response.params = params.parameters;\n                response.error = errors[this.status];\n                if (this.response) {\n                    try {\n                        response.result = JSON.parse(this.response);\n                    } catch (e) {\n                        response.result = this.response;\n                        response.error = \"Invalid JSON.\";\n                    }\n                }\n                log.debug('response', {\n                    method: params.httpMethod,\n                    durationMillis: durationMillis,\n                    response: response\n                });\n                deferred.resolve(response);\n            } else if (this.status === 429) {\n                unit = this.getResponseHeader('RateLimit-Time-Units');\n                limit = this.getResponseHeader('RateLimit-Limit');\n                deferred.reject(new Error(\"Rate limit of \" + limit + \"/\" + unit +\n                    \" exceeded. Try again in 1 \" + unit + \".\"));\n                return;\n            } else {\n                deferred.reject(new Error('unexpected response ' + this.status));\n                return;\n            }\n        };\n\n        return deferred.promise;\n    }\n\n    /**\n     * Turn key/value and key/list pairs into an HTTP URL parameter string.\n     * var1=value1&var2=value2,value3,value4\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.makeParamString\n     * @private\n     * @param {object} params - Arbitrary collection of strings and arrays to serialize.\n     * @returns {string}\n     */\n    function makeParamString(params) {\n        var strings = [];\n        if (!params) {\n            return '';\n        }\n\n        Object.keys(params).forEach(function formatParam(name) {\n            var value = params[name];\n            /* Skip objects -- We won't know how to name these. */\n            if (value instanceof Array) {\n                strings.push([name, value.join(',')].join('='));\n            } else if (typeof value !== 'object' && typeof value !== 'function') {\n                strings.push([name, value].join('='));\n            }\n        });\n\n        if (strings.length > 0) {\n            return '?' + strings.join('&');\n        } else {\n            return '';\n        }\n    }\n\n    return that;\n}; // End respoke.SignalingChannel\n/**\n * Handle an error that resulted from a method call.\n * @callback respoke.SignalingChannel.errorHandler\n * @params {Error} err\n */\n/**\n * Handle sending successfully.\n * @callback respoke.SignalingChannel.sendHandler\n */\n/**\n * Receive a group.\n * @callback respoke.SignalingChannel.groupHandler\n * @param {respoke.Group}\n */\n/**\n * Receive a list of groups.\n * @callback respoke.SignalingChannel.groupListHandler\n * @param {Array}\n */\n/**\n * Receive a list of TURN credentials.\n * @callback respoke.SignalingChannel.turnSuccessHandler\n * @param {Array}\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/signalingChannel.js\n ** module id = 10\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');\n\n/**\n * A direct connection via RTCDataChannel, including state and path negotation.\n * @class respoke.DirectConnection\n * @constructor\n * @augments respoke.EventEmitter\n * @param {string} params\n * @param {string} params.instanceId - client id\n * @param {respoke.Call} params.call - The call that is handling state for this direct connection.\n * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n * it to flow peer-to-peer. The relay acts like a blind proxy.\n * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n * @param {function} params.signalReport - Signaling action from SignalingChannel.\n * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when setup of the direct connection\n * begins. The direct connection will not be open yet.\n * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors that happen during\n * direct connection setup or media renegotiation.\n * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for closing the direct connection.\n * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for opening the direct connection.\n * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the request\n * for a direct connection and setup is about to begin.\n * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages. Not usually\n * necessary to listen to this event if you are already listening to respoke.Endpoint#message.\n * @returns {respoke.DirectConnection}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Client\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n\n    /**\n     * A name to identify this class\n     * @memberof! respoke.DirectConnection\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.DirectConnection';\n    /**\n     * The unique identifier of the direct connection.\n     *\n     * @memberof! respoke.DirectConnection\n     * @name id\n     * @type {string}\n     */\n    that.id = respoke.makeGUID();\n\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name call\n     * @type {respoke.Call}\n     */\n    if (!that.call.caller) {\n        that.call.caller = false;\n    }\n\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name dataChannel\n     * @type {RTCDataChannel}\n     * @private\n     */\n    var dataChannel = null;\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name client\n     * @type {respoke.Client}\n     * @private\n     */\n    var client = respoke.getClient(instanceId);\n\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name pc\n     * @type {RTCPeerConnection}\n     * @private\n     */\n    var pc = params.pc;\n    delete params.pc;\n\n    /**\n     * When the datachannel is availble, we need to attach the callbacks. The event this function is attached to\n     * only fires for the callee.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.listenDataChannel\n     * @param {respoke.Event} evt\n     * @private\n     */\n    function listenDataChannel(evt) {\n        dataChannel = evt.channel;\n        dataChannel.onerror = onDataChannelError;\n        dataChannel.onmessage = onDataChannelMessage;\n        if (dataChannel.readyState === 'open') {\n            dataChannel.onopen = null;\n            onDataChannelOpen();\n        } else {\n            dataChannel.onopen = onDataChannelOpen;\n        }\n    }\n\n    /**\n     * Register any event listeners passed in as callbacks\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.saveParameters\n     * @param {object} params\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for when the direct connection\n     * is closed.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for when the direct connection\n     * is open.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages.\n     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n     * connection.\n     * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when the direct connection\n     * is being set up. The direct connection will not be open yet.\n     * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n     * it to flow peer-to-peer. The relay acts like a blind proxy.\n     * @private\n     */\n    function saveParameters(params) {\n        /**\n         * The direct connection is open.\n         * @event respoke.DirectConnection#open\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('open', params.onOpen);\n        /**\n         * The direct connection is closed.\n         * @event respoke.DirectConnection#close\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('close', params.onClose);\n        /**\n         * Incoming message on this direct connection.\n         * @event respoke.DirectConnection#message\n         * @type {respoke.Event}\n         * @property {respoke.TextMessage} message\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('message', params.onMessage);\n        // documented elsewhere\n        that.listen('start', params.onStart);\n        /**\n         * An error occurred while setting up the direct connection.\n         * @event respoke.DirectConnection#error\n         * @type {respoke.Event}\n         * @property {string} reason - A human-readable description of the error.\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('error', params.onError);\n        pc.listen('direct-connection', listenDataChannel, true);\n        pc.listen('stats', function fireStats(evt) {\n            /**\n             * This event is fired every time statistical information about the direct connection\n             * becomes available.\n             * @event respoke.DirectConnection#stats\n             * @type {respoke.Event}\n             * @property {object} stats - an object with stats in it.\n             * @property {respoke.DirectConnection} target\n             * @property {string} name - the event name.\n             */\n            that.fire('stats', {stats: evt.stats});\n        }, true);\n\n    }\n    saveParameters(params);\n\n    delete that.onOpen;\n    delete that.onClose;\n    delete that.onMessage;\n\n    /**\n     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n     * statistics, we'll return a promise for the stats object.\n     *\n     *     directConnection.getStats({\n     *         onStats: function (evt) {\n     *             console.log('Stats', evt.stats);\n     *         }\n     *     }).done(function () {\n     *         console.log('Stats started.');\n     *     }, function (err) {\n     *         console.log('Direct connection is already closed.');\n     *     });\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.getStats\n     * @returns {Promise<object>|undefined}\n     * @param {object} params\n     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive the\n     * stats if the Respoke stats module is loaded. If no callback is provided, the connection's report will\n     * contain stats but the developer will not receive them on the client-side.\n     * @param {respoke.DirectConnection.statsSuccessHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation of\n     * this method only.\n     */\n    that.getStats = function (params) {\n        if (pc && pc.getStats) {\n            that.listen('stats', params.onStats);\n            delete params.onStats;\n            return pc.getStats(params);\n        }\n        return null;\n    };\n\n    if (!respoke.MediaStats) {\n        delete that.getStats;\n    }\n\n    /**\n     * Detect datachannel errors for internal state.\n     * @memberof! respoke.DirectConnection\n     * @private\n     * @method respoke.DirectConnection.onDataChannelError\n     */\n    function onDataChannelError(error) {\n        /**\n         * @event respoke.DirectConnection#error\n         * @type {respoke.Event}\n         * @property {object} error\n         * @property {respoke.DirectConnection} directConnection\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('error', {\n            error: error\n        });\n        that.close();\n    }\n\n    /**\n     * Receive and route messages to the Endpoint.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.onDataChannelMessage\n     * @private\n     * @param {MessageEvent}\n     * @fires respoke.DirectConnection#message\n     */\n    function onDataChannelMessage(evt) {\n        var message;\n        try {\n            message = JSON.parse(evt.data);\n        } catch (e) {\n            message = evt.data;\n        }\n        /**\n         * @event respoke.Endpoint#message\n         * @type {respoke.Event}\n         * @property {object} message\n         * @property {respoke.DirectConnection} directConnection\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.call.remoteEndpoint.fire('message', {\n            message: message,\n            directConnection: that\n        });\n        /**\n         * @event respoke.DirectConnection#message\n         * @type {respoke.Event}\n         * @property {object} message\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('message', {\n            message: message,\n            endpoint: that.call.remoteEndpoint\n        });\n    }\n\n    /**\n     * Detect when the channel is open.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.onDataChannelOpen\n     * @private\n     * @param {MessageEvent}\n     * @fires respoke.DirectConnection#open\n     */\n    function onDataChannelOpen(evt) {\n        //dataChannel = evt.target || evt.channel;\n        /**\n         * @event respoke.DirectConnection#open\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('open');\n    }\n\n    /**\n     * Detect when the channel is closed.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.onDataChannelClose\n     * @private\n     * @param {MessageEvent}\n     * @fires respoke.DirectConnection#close\n     */\n    function onDataChannelClose(evt) {\n        //dataChannel = evt.target || evt.channel;\n        /**\n         * @event respoke.DirectConnection#close\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('close');\n    }\n\n    /**\n     * Create the datachannel. For the caller, set up all the handlers we'll need to keep track of the\n     * datachannel's state and to receive messages.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.createDataChannel\n     * @private\n     */\n    function createDataChannel() {\n        dataChannel = pc.createDataChannel(\"respokeDataChannel\");\n        dataChannel.binaryType = 'arraybuffer';\n        dataChannel.onerror = onDataChannelError;\n        dataChannel.onmessage = onDataChannelMessage;\n        dataChannel.onopen = onDataChannelOpen;\n\n        /**\n         * The direct connection setup has begun. This does NOT mean it's ready to send messages yet. Listen to\n         * DirectConnection#open for that notification.\n         * @event respoke.DirectConnection#start\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('start');\n    }\n\n    /**\n     * Start the process of obtaining media. saveParameters will only be meaningful for the callee,\n     * since the library calls this method for the caller. Developers will use this method to pass in\n     * callbacks for the callee.\n     *\n     *     directConnection.accept({\n     *         onOpen: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.accept\n     * @fires respoke.DirectConnection#accept\n     * @param {object} params\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen]\n     * @param {respoke.DirectConnection.onClose} [params.onClose]\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage]\n     */\n    that.accept = function (params) {\n        params = params || {};\n        log.debug('DirectConnection.accept');\n        saveParameters(params);\n\n        log.debug(\"I am \" + (pc.state.caller ? '' : 'not ') + \"the caller.\");\n\n        if (pc.state.caller === true) {\n            createDataChannel();\n        }\n        that.call.answer();\n\n        /**\n         * @event respoke.DirectConnection#accept\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('accept');\n    };\n\n    /**\n     * Tear down the connection.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.close\n     * @fires respoke.DirectConnection#close\n     */\n    that.close = function (params) {\n        params = params || {};\n        log.debug(\"DirectConnection.close\");\n        if (dataChannel) {\n            dataChannel.close();\n        }\n\n        /**\n         * @event respoke.DirectConnection#close\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('close');\n\n        that.ignore();\n\n        if (params.skipRemove !== true) {\n            that.call.removeDirectConnection();\n        }\n\n        dataChannel = null;\n        that.call.remoteEndpoint.directConnection = null;\n        that.call = null;\n        pc = null;\n    };\n\n    /**\n     * Send a message over the datachannel in the form of a JSON-encoded plain old JavaScript object. Only one\n     * attribute may be given: either a string 'message' or an object 'object'.\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     *     directConnection.sendMessage({\n     *         message: \"And they say HTTP is stateless!\"\n     *     });\n     *\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.sendMessage\n     * @param {object} params\n     * @param {string} [params.message] - The message to send.\n     * @param {object} [params.object] - An object to send.\n     * @param {respoke.DirectConnection.sendHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation\n     * of this method only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        if (that.isActive()) {\n            dataChannel.send(JSON.stringify(params.object || {\n                message: params.message\n            }));\n            deferred.resolve();\n        } else {\n            deferred.reject(new Error(\"dataChannel not in an open state.\"));\n        }\n        return retVal;\n    };\n\n    /**\n     * Expose close as reject for approve/reject workflow.\n     *\n     *     client.listen('direct-connection, function (evt) {\n     *         if (iDontLikeThisPerson()) {\n     *             evt.directConnection.reject();\n     *         }\n     *     });\n     *\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.reject\n     * @param {boolean} signal - Optional flag to indicate whether to send or suppress sending\n     * a hangup signal to the remote side.\n     */\n    that.reject = that.close;\n\n    /**\n     * Indicate whether a datachannel is being setup or is in progress.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.isActive\n     * @returns {boolean}\n     */\n    that.isActive = function () {\n        // Why does pc.iceConnectionState not transition into 'connected' even though media is flowing?\n        //return (pc && pc.isActive() && dataChannel && dataChannel.readyState === 'open');\n        return (dataChannel && dataChannel.readyState === 'open');\n    };\n\n    return that;\n}; // End respoke.DirectConnection\n\n/**\n * Called when the direct connection is closed.  This callback is called every time respoke.DirectConnection#close\n * fires.\n * @callback respoke.DirectConnection.onClose\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when the setup of the direct connection has begun. The direct connection will not be open yet. This\n * callback is called every time respoke.DirectConnection#start fires.\n * @callback respoke.DirectConnection.onStart\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when the direct connection is opened.  This callback is called every time respoke.DirectConnection#open\n * fires.\n * @callback respoke.DirectConnection.onOpen\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when a message is received over the direct connection.  This callback is called every time\n * respoke.DirectConnection#message fires.\n * @callback respoke.DirectConnection.onMessage\n * @param {respoke.Event} evt\n * @param {object} evt.message\n * @param {respoke.Endpoint} evt.endpoint\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Handle an error that resulted from a specific method call. This handler will not fire more than once.\n * @callback respoke.DirectConnection.errorHandler\n * @param {Error} err\n */\n/**\n * When a call is in setup or media renegotiation happens. This callback will be called every time\n * respoke.DirectConnection#error.\n * @callback respoke.DirectConnection.onError\n * @param {respoke.Event} evt\n * @param {boolean} evt.reason - A human-readable description of the error.\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when the callee accepts the direct connection. This callback is called every time\n * respoke.DirectConnection#accept is fired.\n * @callback respoke.DirectConnection.onAccept\n * @param {respoke.Event} evt\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Handle the successful kick-off of stats on a call.\n * @callback respoke.DirectConnection.statsSuccessHandler\n * @param {respoke.Event} evt\n * @param {object} evt.stats - an object with stats in it.\n * @param {respoke.DirectConnection} evt.target\n * @param {string} evt.name - the event name.\n */\n/**\n * Handle sending successfully.\n * @callback respoke.DirectConnection.sendHandler\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/directConnection.js\n ** module id = 11\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');\n\n/**\n * WebRTC PeerConnection. This class handles all the state and connectivity for Call and DirectConnection.\n * This class cannot be used alone, but is instantiated by and must be given media by either Call, DirectConnection,\n * or the not-yet-implemented ScreenShare.\n * @class respoke.PeerConnection\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @param {boolean} [params.forceTurn] - If true, delete all 'host' and 'srvflx' candidates and send only 'relay'\n * candidates.\n * @param {boolean} [params.disableTurn] - If true, delete all 'relay' candidates and send only 'host' and 'srvflx'\n * candidates.\n * @param {respoke.Call} params.call\n * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n * @param {function} params.signalModify - Signaling action from SignalingChannel.\n * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n * @param {function} params.signalReport - Signaling action from SignalingChannel.\n * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for the developer to receive\n * statistics about the call. This is only used if call.getStats() is called and the stats module is loaded.\n * @param {object} [params.pcOptions]\n * @param {object} [params.offerOptions]\n * @returns {respoke.PeerConnection}\n */\n\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.PeerConnection';\n\n    /**\n     * Whether or not we will send a 'hangup' signal to the other side during hangup.\n     * @memberof! respoke.PeerConnection\n     * @name toSendHangup\n     * @type {respoke.Endpoint}\n     */\n    var toSendHangup;\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @private\n     * @name pc\n     * @type RTCPeerConnection\n     * @desc The RTCPeerConnection as provided by the browser API. All internal state, networking functionality, and\n     * raw data transfer occurs within the PeerConnection.\n     */\n    var pc = null;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name defModify\n     * @private\n     * @type {Promise}\n     * @desc Used in the state machine to trigger methods or functions whose execution depends on the reception,\n     * handling, or sending of some information.\n     */\n    var defModify;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name previewLocalMedia\n     * @private\n     * @type {respoke.Call.previewLocalMedia}\n     * @desc A callback provided by the developer that we'll call after receiving local media and before\n     * approve() is called.\n     */\n    var previewLocalMedia = typeof params.previewLocalMedia === 'function' ? params.previewLocalMedia : undefined;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name candidateSendingQueue\n     * @private\n     * @type {array}\n     * @desc An array to save candidates between offer and answer so that both parties can process them simultaneously.\n     */\n    var candidateSendingQueue = [];\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name candidateReceivingQueue\n     * @private\n     * @type {array}\n     * @desc An array to save candidates between offer and answer so that both parties can process them simultaneously.\n     */\n    var candidateReceivingQueue = [];\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name client\n     * @private\n     * @type {respoke.Client}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalOffer\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalOffer = params.signalOffer;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalConnected\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalConnected = params.signalConnected;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalModify\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalModify = params.signalModify;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalAnswer\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalAnswer = params.signalAnswer;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalHangup\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalHangup = respoke.once(params.signalHangup);\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalReport\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalReport = params.signalReport;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalCandidateOrig\n     * @private\n     * @type {function}\n     * @desc A temporary function saved from params in order to construct the candidate signaling function.\n     */\n    var signalCandidateOrig = params.signalCandidate;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalCandidate\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed from the one passed to us by the signaling channel with additions\n     * to facilitate candidate logging.\n     */\n    function signalCandidate(params) {\n        if (!pc) {\n            return;\n        }\n\n        params.iceCandidates = [params.candidate];\n        signalCandidateOrig(params);\n        that.report.candidatesSent.push({candidate: params.candidate});\n    }\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name offerOptions\n     * @private\n     * @type {object}\n     */\n    var offerOptions = params.offerOptions || null;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name pcOptions\n     * @private\n     * @type {object}\n     */\n    var pcOptions = params.pcOptions || {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name report\n     * @type {object}\n     */\n    that.report = {\n        callStarted: 0,\n        callStopped: 0,\n        callerendpoint: that.call.caller ? client.name : that.call.remoteEndpoint.id,\n        callerconnection: that.call.caller ? client.id : that.call.connectionId,\n        calleeendpoint: that.call.caller ? that.call.remoteEndpoint.id : client.id,\n        calleeconnection: that.call.caller ? that.call.connectionId : client.connectionId,\n        sessionId: that.call.id,\n        lastSDPString: '',\n        sdpsSent: [],\n        sdpsReceived: [],\n        candidatesSent: [],\n        candidatesReceived: [],\n        userAgent: navigator.userAgent,\n        os: navigator.platform\n    };\n\n    /**\n     * Start the process of network and media negotiation. Called after local video approved.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.initOffer\n     * @fires respoke.PeerConnection#initOffer\n     * @private\n     */\n    function initOffer() {\n        if (!pc) {\n            return;\n        }\n\n        log.info('creating offer', offerOptions);\n        pc.createOffer(saveOfferAndSend, function errorHandler(p) {\n            log.error('createOffer failed');\n        }, offerOptions);\n    }\n\n    /**\n     * Process a remote offer if we are not the caller. This is necessary because we don't process the offer until\n     * the callee has answered the call.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.processOffer\n     * @param {RTCSessionDescriptor}\n     * @returns {Promise}\n     */\n    that.processOffer = function (oOffer) {\n        if (!pc) {\n            return;\n        }\n        log.debug('processOffer', oOffer);\n\n        that.report.sdpsReceived.push(oOffer);\n        that.report.lastSDPString = oOffer.sdp;\n\n        //set flags for audio / video being offered\n        that.call.hasAudio = respoke.sdpHasAudio(oOffer.sdp);\n        that.call.hasVideo = respoke.sdpHasVideo(oOffer.sdp);\n        that.call.hasDataChannel = respoke.sdpHasDataChannel(oOffer.sdp);\n\n        try {\n            pc.setRemoteDescription(new RTCSessionDescription(oOffer),\n                function successHandler() {\n                    if (!pc) {\n                        return;\n                    }\n\n                    log.debug('set remote desc of offer succeeded');\n                    that.call.incomingMedia.setSDP(oOffer); // callee's incoming media\n                    pc.createAnswer(function successHandler(oSession) {\n                        that.state.processedRemoteSDP = true;\n                        that.call.outgoingMedia.setSDP(oSession); // callee's outgoing media\n                        saveAnswerAndSend(oSession);\n                    }, function errorHandler(err) {\n                        err = new Error(\"Error creating SDP answer.\" + err.message);\n                        that.report.callStoppedReason = err.message;\n                        /**\n                         * This event is fired on errors that occur during call setup or media negotiation.\n                         * @event respoke.Call#error\n                         * @type {respoke.Event}\n                         * @property {string} reason - A human readable description about the error.\n                         * @property {respoke.Call} target\n                         * @property {string} name - the event name.\n                         */\n                        that.call.fire('error', {\n                            message: err.message\n                        });\n                        log.error('create answer failed');\n                        that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n                        that.close();\n                    });\n                }, function errorHandler(err) {\n                    err = new Error('Error calling setRemoteDescription on offer I received.' + err.message);\n                    that.report.callStoppedReason = err.message;\n                    /**\n                     * This event is fired on errors that occur during call setup or media negotiation.\n                     * @event respoke.Call#error\n                     * @type {respoke.Event}\n                     * @property {string} reason - A human readable description about the error.\n                     * @property {respoke.Call} target\n                     * @property {string} name - the event name.\n                     */\n                    that.call.fire('error', {\n                        message: err.message\n                    });\n                }\n            );\n        } catch (err) {\n            var newErr = new Error(\"Exception calling setRemoteDescription on offer I received.\" + err.message);\n            that.report.callStoppedReason = newErr.message;\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.call.fire('error', {\n                message: newErr.message\n            });\n        }\n    };\n\n    /**\n     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n     * statistics, we'll return a promise for the stats object.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.getStats\n     * @returns {Promise<{respoke.MediaStatsParser}>|undefined}\n     * @param {object} params\n     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @fires respoke.PeerConnection#stats\n     */\n    function getStats(params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        if (!respoke.MediaStats) {\n            deferred.reject(new Error(\"Statistics module is not loaded.\"));\n            return retVal;\n        }\n\n        function onConnect() {\n            var stats = respoke.MediaStatsParser({\n                peerConnection: pc,\n                interval: params.interval,\n                onStats: function statsHandler(stats) {\n                    if (!pc) {\n                        return;\n                    }\n\n                    /**\n                     * @event respoke.PeerConnection#stats\n                     * @type {respoke.Event}\n                     * @property {object} stats - an object with stats in it.\n                     * @property {string} name - the event name.\n                     * @property {respoke.PeerConnection}\n                     */\n                    that.fire('stats', {\n                        stats: stats\n                    });\n                }\n            });\n            that.listen('close', function closeHandler(evt) {\n                stats.stopStats();\n            }, true);\n            deferred.resolve();\n        }\n\n        if (!pc) {\n            that.once('stream-received', onConnect);\n        } else {\n            onConnect();\n        }\n\n        return retVal;\n    }\n\n    if (respoke.MediaStats) {\n        that.getStats = getStats;\n    }\n\n    /**\n     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.init\n     */\n    that.init = function init() {\n        log.debug('PC.init');\n\n        if (pc) {\n            return;\n        }\n\n        that.report.callStarted = new Date().getTime();\n\n        pc = new RTCPeerConnection(that.servers, pcOptions);\n        pc.onicecandidate = onIceCandidate;\n        pc.onnegotiationneeded = onNegotiationNeeded;\n        pc.onaddstream = function onaddstream(evt) {\n            /**\n             * @event respoke.PeerConnection#connect\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('connect', {\n                stream: evt.stream\n            });\n        };\n        pc.onremovestream = function onremovestream(evt) {\n            /**\n             * @event respoke.PeerConnection#remote-stream-removed\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('remote-stream-removed', {\n                stream: evt.stream\n            });\n        };\n        pc.ondatachannel = function ondatachannel(evt) {\n            /**\n             * CAUTION: This event is only called for the callee because RTCPeerConnection#ondatachannel\n             * is only called for the callee.\n             * @event respoke.PeerConnection#direct-connection\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('direct-connection', {\n                channel: evt.channel\n            });\n        };\n\n        that.state.listen('offering:entry', function (evt) {\n            if (that.state.caller) {\n                initOffer();\n            }\n        });\n    };\n\n    /**\n     * Return an array of remote media streams.\n     * @muremberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.getRemoteStreams\n     */\n    that.getRemoteStreams = function () {\n        if (!pc) {\n            return [];\n        }\n        return pc.getRemoteStreams.apply(pc, Array.prototype.slice.call(arguments));\n    };\n\n    /**\n     * Return an array of local media streams.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.getLocalStreams\n     */\n    that.getLocalStreams = function () {\n        if (!pc) {\n            return [];\n        }\n        return pc.getLocalStreams.apply(pc, Array.prototype.slice.call(arguments));\n    };\n\n    /**\n     * Create a data channel.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.createDataChannel\n     */\n    that.createDataChannel = function () {\n        if (!pc) {\n            return;\n        }\n        return pc.createDataChannel.apply(pc, Array.prototype.slice.call(arguments));\n    };\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.addStream\n     * Expose addStream.\n     * @param {RTCMediaStream}\n     */\n    that.addStream = function (stream) {\n        if (!pc) {\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.call.fire('error', {\n                message: \"Got local stream in a precall state.\"\n            });\n            return;\n        }\n        pc.addStream(stream);\n    };\n\n    /**\n     * Process a local ICE Candidate\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.onIceCandidate\n     * @private\n     * @param {RTCIceCandidate}\n     */\n    function onIceCandidate(oCan) {\n        var candidate = oCan.candidate; // {candidate: ..., sdpMLineIndex: ... }\n        if (!candidate || !candidate.candidate) {\n            return;\n        }\n\n        if (that.forceTurn === true && candidate.candidate.indexOf(\"typ relay\") === -1) {\n            log.debug(\"Dropping candidate because forceTurn is on.\");\n            return;\n        } else if (that.disableTurn === true && candidate.candidate.indexOf(\"typ relay\") !== -1) {\n            log.debug(\"Dropping candidate because disableTurn is on.\");\n            return;\n        }\n\n        if (!that.state.sentSDP && !that.state.processedRemoteSDP) {\n            candidateSendingQueue.push(candidate);\n        } else {\n            signalCandidate({\n                candidate: candidate,\n                call: that.call\n            });\n        }\n    }\n\n    /**\n     * Handle renegotiation\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.onNegotiationNeeded\n     * @private\n     */\n    function onNegotiationNeeded() {\n        log.warn(\"Negotiation needed.\");\n    }\n\n    /**\n     * Process any ICE candidates that we received either from the browser or the other side while\n     * we were trying to set up our RTCPeerConnection to handle them.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.processQueues\n     * @private\n     */\n    function processQueues() {\n        /* We only need to queue (and thus process queues) if\n         * we are the caller. The person receiving the call\n         * never has a valid PeerConnection at a time when we don't\n         * have one. */\n        var can = null;\n        for (var i = 0; i < candidateSendingQueue.length; i += 1) {\n            signalCandidate({\n                candidate: candidateSendingQueue[i],\n                call: that.call\n            });\n        }\n        candidateSendingQueue = [];\n        for (var i = 0; i < candidateReceivingQueue.length; i += 1) {\n            that.addRemoteCandidate({\n                candidate: candidateReceivingQueue[i],\n                processingQueue: true\n            });\n        }\n        candidateReceivingQueue = [];\n    }\n\n    /**\n     * Save an SDP we've gotten from the browser which will be an offer and send it to the other\n     * side.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.saveOfferAndSend\n     * @param {RTCSessionDescription}\n     * @private\n     */\n    function saveOfferAndSend(oSession) {\n        oSession.type = 'offer';\n        if (!pc) {\n            return;\n        }\n        log.debug('setting and sending offer', oSession);\n        that.report.sdpsSent.push(oSession);\n        that.call.outgoingMedia.setSDP(oSession); // caller's outgoing media\n        that.call.incomingMedia.setSDP(oSession); // caller's incoming media estimate\n        pc.setLocalDescription(oSession, function successHandler(p) {\n            oSession.type = 'offer';\n            signalOffer({\n                call: that.call,\n                sessionDescription: oSession,\n                onSuccess: function () {\n                    that.state.sentSDP = true;\n                    setTimeout(processQueues);\n                },\n                onError: function (err) {\n                    respoke.log.error('offer could not be sent');\n                    that.call.hangup({signal: false});\n                }\n            });\n        }, function errorHandler(p) {\n            var err = new Error('Error calling setLocalDescription on offer I created.');\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.call.fire('error', {\n                message: err.message\n            });\n        });\n    }\n\n    /**\n     * Save our SDP we've gotten from the browser which will be an answer and send it to the\n     * other side.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.saveAnswerAndSend\n     * @param {RTCSessionDescription}\n     * @private\n     */\n    function saveAnswerAndSend(oSession) {\n        if (!pc) {\n            return;\n        }\n\n        if (!that.state.caller) {\n            that.report.callerconnection = that.call.connectionId;\n        }\n\n        oSession.type = 'answer';\n        log.debug('setting and sending answer', oSession);\n        that.report.sdpsSent.push(oSession);\n\n        pc.setLocalDescription(oSession, function successHandler(p) {\n            oSession.type = 'answer';\n            signalAnswer({\n                sessionDescription: oSession,\n                call: that.call\n            });\n            that.state.sentSDP = true;\n            processQueues();\n        }, function errorHandler(p) {\n            var err = new Error('Error calling setLocalDescription on answer I created.');\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.call.fire('error', {\n                message: err.message\n            });\n        });\n    }\n\n    /**\n     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n     * signal is not false and we have not received a hangup signal from the remote party.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.close\n     * @fires respoke.PeerConnection#destoy\n     * @param {object} param\n     * @param {boolean} [param.signal] - Optional flag to indicate whether to send or suppress sending\n     * a hangup signal to the remote side. This is set to false by the library if we're responding to a\n     * hangup signal.\n     * @fires respoke.PeerConnection#close\n     */\n    that.close = function (params) {\n        params = params || {};\n        toSendHangup = true;\n\n        if (that.state.caller === true) {\n            if (!that.state.sentSDP) {\n                // Never send hangup if we are the caller but we haven't sent any other signal yet.\n                toSendHangup = false;\n            }\n        }\n\n        toSendHangup = (typeof params.signal === 'boolean' ? params.signal : toSendHangup);\n        if (toSendHangup) {\n            log.info('sending hangup');\n            signalHangup({\n                call: that.call\n            });\n        }\n\n        that.report.callStopped = new Date().getTime();\n\n        /**\n         * @event respoke.PeerConnection#close\n         * @type {respoke.Event}\n         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n         * @property {string} name - the event name.\n         * @property {respoke.PeerConnection}\n         */\n        that.fire('close', {\n            sentSignal: toSendHangup\n        });\n        that.ignore();\n\n        if (pc && that.report) {\n            pc.close();\n        }\n        pc = null;\n\n        if (that.call.enableCallDebugReport) {\n            signalReport({\n                report: that.report\n            });\n        }\n        that.report = null;\n    };\n    that.close = respoke.once(that.close);\n\n    /**\n     * Indicate whether a call is being setup or is in progress.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.isActive\n     * @returns {boolean}\n     */\n    that.isActive = function () {\n        return !!(pc && ['completed', 'connected', 'new', 'checking'].indexOf(pc.iceConnectionState) > -1);\n    };\n\n    /**\n     * Set the estimated media status on incoming and outgoing media.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.listenOffer\n     * @param {object} evt\n     * @param {object} evt.signal - The signal, including the remote SDP and the connectionId of the endpoint who\n     * answered the call.\n     * @private\n     */\n    function listenOffer(evt) {\n        that.call.incomingMedia.setSDP(evt.signal.sessionDescription); // callee's incoming media\n        that.call.outgoingMedia.setSDP(evt.signal.sessionDescription); // callee's outgoing media estimate\n    }\n\n    /**\n     * Save the answer and tell the browser about it.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.listenAnswer\n     * @param {object} evt\n     * @param {object} evt.signal - The signal, including the remote SDP and the connectionId of the endpoint who\n     * answered the call.\n     * @private\n     */\n    function listenAnswer(evt) {\n        if (!pc) {\n            return;\n        }\n        log.debug('got answer', evt.signal);\n\n        that.report.sdpsReceived.push(evt.signal.sessionDescription);\n        that.report.lastSDPString = evt.signal.sessionDescription.sdp;\n        //set flags for audio / video for answer\n        that.call.hasAudio = respoke.sdpHasAudio(evt.signal.sessionDescription.sdp);\n        that.call.hasVideo = respoke.sdpHasVideo(evt.signal.sessionDescription.sdp);\n        that.call.hasDataChannel = respoke.sdpHasDataChannel(evt.signal.sessionDescription.sdp);\n        if (that.state.caller) {\n            that.report.calleeconnection = evt.signal.fromConnection;\n        }\n        that.call.connectionId = evt.signal.fromConnection;\n        // TODO don't signal connected more than once.\n        signalConnected({\n            call: that.call\n        });\n\n        pc.setRemoteDescription(\n            new RTCSessionDescription(evt.signal.sessionDescription),\n            function successHandler() {\n                that.call.incomingMedia.setSDP(evt.signal.sessionDescription); // caller's incoming media\n                that.state.dispatch('receiveAnswer');\n            }, function errorHandler(p) {\n                var newErr = new Error(\"Exception calling setRemoteDescription on answer I received.\");\n                that.report.callStoppedReason = newErr.message;\n                /**\n                 * This event is fired on errors that occur during call setup or media negotiation.\n                 * @event respoke.Call#error\n                 * @type {respoke.Event}\n                 * @property {string} reason - A human readable description about the error.\n                 * @property {respoke.Call} target\n                 * @property {string} name - the event name.\n                 */\n                that.call.fire('error', {\n                    message: newErr.message\n                });\n                log.error('set remote desc of answer failed', evt.signal.sessionDescription);\n                that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n                that.close();\n            }\n        );\n    }\n\n    /**\n     * Figure out who won the call. This necessary to prevent two connections of the same endpoint from thinking\n     * they are both on the same call.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.listenConnected\n     * @private\n     */\n    function listenConnected(evt) {\n        if (evt.signal.connectionId !== client.connectionId) {\n            log.debug(\"Hanging up because I didn't win the call.\", evt.signal, client);\n            that.call.hangup({signal: false});\n        }\n    }\n\n    /**\n     * Send the initiate signal to start the modify process. This method is only called by the caller of the\n     * renegotiation.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.startModify\n     * @param {object} params\n     * @param {object} [params.constraints] - Indicate this is a request for media and what type of media.\n     * @param {boolean} [params.directConnection] - Indicate this is a request for a direct connection.\n     */\n    that.startModify = function (params) {\n        defModify = Q.defer();\n        signalModify({\n            action: 'initiate',\n            call: that.call,\n            constraints: params.constraints,\n            directConnection: params.directConnection\n        });\n    };\n\n    /**\n     * Indicate a desire from the other side to renegotiate media.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.listenModify\n     * @param {object} evt\n     * @param {object} evt.signal\n     * @private\n     */\n    function listenModify(evt) {\n        var err;\n        log.debug('PC.listenModify', evt.signal);\n\n        if (evt.signal.action === 'accept') {\n            if (defModify.promise.isPending()) {\n                defModify.resolve();\n                /**\n                 * @event respoke.PeerConnection#modify-accept\n                 * @type {respoke.Event}\n                 * @property {string} name - the event name.\n                 * @property {respoke.PeerConnection}\n                 */\n                that.fire('modify-accept', {signal: evt.signal});\n            }\n            return;\n        } else if (evt.signal.action === 'reject') {\n            if (defModify.promise.isPending()) {\n                err = new Error(\"Remote party cannot negotiate.\");\n                log.debug(err.message);\n                defModify.reject(err);\n                /**\n                 * @event respoke.PeerConnection#modify-reject\n                 * @type {respoke.Event}\n                 * @property {Error} err\n                 * @property {string} name - the event name.\n                 * @property {respoke.PeerConnection}\n                 */\n                that.fire('modify-reject', {err: err});\n            }\n            return;\n        }\n\n        // This code only gets executed if signal.action === 'initiate'\n        if (defModify && defModify.promise.isPending()) {\n            // TODO compare signal request ID and accept if we have the higher request ID,\n            // reject if we have the lower request ID.\n            err = new Error(\"Got modify in a negotiating state.\");\n            log.debug(err.message);\n            defModify.reject(err);\n            /**\n             * @event respoke.PeerConnection#modify-reject\n             * @type {respoke.Event}\n             * @property {Error} err\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('modify-reject', {err: err});\n            signalModify({\n                action: 'reject',\n                call: that.call\n            });\n            return;\n        }\n\n        defModify = Q.defer();\n\n        if (!that.state.sentSDP || that.state.isState('idle')) {\n            err = new Error(\"Got modify in a precall state.\");\n            /**\n             * @event respoke.PeerConnection#modify-reject\n             * @type {respoke.Event}\n             * @property {Error} err\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('modify-reject', {err: err});\n            signalModify({\n                action: 'reject',\n                call: that.call\n            });\n            defModify.reject(err);\n            return;\n        }\n\n       /**\n         * @event respoke.PeerConnection#modify-accept\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.PeerConnection}\n         */\n        that.fire('modify-accept', {signal: evt.signal});\n        signalModify({\n            action: 'accept',\n            call: that.call\n        });\n        defModify.resolve();\n    }\n\n    /**\n     * Save the candidate. If we initiated the call, place the candidate into the queue so\n     * we can process them after we receive the answer.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.addRemoteCandidate\n     * @param {object} params\n     * @param {RTCIceCandidate} params.candidate\n     */\n    that.addRemoteCandidate = function (params) {\n        params = params || {};\n\n        if (!pc && params.processingQueue) { // we hung up.\n            return;\n        }\n\n        if (!params.candidate || !params.candidate.hasOwnProperty('sdpMLineIndex')) {\n            log.warn(\"addRemoteCandidate got wrong format!\", params);\n            return;\n        }\n\n        if (!pc) {\n            candidateReceivingQueue.push(params.candidate);\n            log.debug('Queueing a candidate because pc is null.');\n            return;\n        }\n\n        if (that.state.sentSDP || that.state.processedRemoteSDP) {\n            try {\n                pc.addIceCandidate(new RTCIceCandidate(params.candidate));\n                log.debug('Got a remote candidate.', params.candidate);\n                that.report.candidatesReceived.push(params.candidate);\n            } catch (e) {\n                log.error(\"Couldn't add ICE candidate: \" + e.message, params.candidate);\n                return;\n            }\n        } else if (!params.processingQueue) {\n            candidateReceivingQueue.push(params.candidate);\n            log.debug('Queueing a candidate because no offer yet.');\n        }\n    };\n\n    that.call.listen('signal-offer', listenOffer, true);\n    that.call.listen('signal-answer', listenAnswer, true);\n    that.call.listen('signal-connected', listenConnected, true);\n    that.call.listen('signal-modify', listenModify, true);\n\n    return that;\n}; // End respoke.PeerConnection\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/peerConnection.js\n ** module id = 12\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar respoke = require('./respoke');\nvar Statechart = require('statechart');\nvar Q = require('q');\n\n/**\n * State machine for WebRTC calling, data channels, and screen sharing.\n * NOTE: All state transitions are synchronous! However, listeners to the events this class fires will be called\n * asynchronously.\n * @class respoke.CallState\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {respoke.Call} call\n * @link https://cdn.respoke.io/respoke.min.js\n * @returns {respoke.CallState}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var fsm;\n    var that = respoke.EventEmitter(params);\n    that.className = 'respoke.CallState';\n\n    var allTimers = [];\n    var answerTimer;\n    var answerTimeout = params.answerTimeout || 10000;\n    var receiveAnswerTimer;\n    var receiveAnswerTimeout = params.receiveAnswerTimeout || 60000;\n    var connectionTimer;\n    var connectionTimeout = params.connectionTimeout || 10000;\n    var modifyTimer;\n    var modifyTimeout = params.modifyTimeout || 60000;\n    var oldRole;\n\n    /*\n     * These can quite often result in a condition in which they do not cause a transition to occur.\n     * There is at least one \"universal\" (air quotes) event which probably? shouldn't? but may\n     * result in a non-transition error when it's OK, and that is the 'reject' event.\n     */\n    var nontransitionEvents = ['receiveLocalMedia', 'receiveRemoteMedia', 'approve', 'answer', 'sentOffer',\n        'receiveAnswer'];\n\n    function assert(condition) {\n        if (!condition) {\n            throw new Error(\"Assertion failed.\");\n        }\n    }\n\n    that.hasLocalMediaApproval = false;\n    that.hasLocalMedia = false;\n    that.receivedBye = false;\n    that.isAnswered = false;\n    that.sentSDP = false;\n    that.receivedSDP = false;\n    that.processedRemoteSDP = false;\n    that.needDirectConnection = !!that.needDirectConnection;\n    that.sendOnly = !!that.sendOnly;\n    that.receiveOnly = !!that.receiveOnly;\n\n    // Event\n    var rejectEvent = [{\n        target: 'connected',\n        guard: function (params) {\n            // we have any media flowing or data channel open\n            if (typeof oldRole === 'boolean') {\n                // Reset the role if we have aborted a modify.\n                that.caller = oldRole;\n            }\n\n            if (modifyTimer) {\n                modifyTimer.clear();\n            }\n\n            return that.hasMedia();\n        }\n    }, {\n        target: 'terminated',\n        guard: function (params) {\n            params = params || {};\n            // we have no media flowing or data channel open\n            that.hangupReason = params.reason || \"no media\";\n            return !that.hasMedia();\n        }\n    }];\n\n    // Event\n    function rejectModify() {\n        // reject modification\n        if (modifyTimer) {\n            modifyTimer.clear();\n        }\n    }\n\n    // Event\n    function clearReceiveAnswerTimer() {\n        that.processedRemoteSDP = true;\n        if (receiveAnswerTimer) {\n            receiveAnswerTimer.clear();\n        }\n    }\n\n    // Event\n    var hangupEvent = {\n        target: 'terminated',\n        action: function (params) {\n            params = params || {};\n            that.signalBye = params.signal;\n            that.hangupReason = that.hangupReason || params.reason || \"none\";\n        }\n    };\n\n    function needToObtainMedia(params) {\n        return (that.needDirectConnection !== true && that.receiveOnly !== true);\n    }\n\n    function needToApproveDirectConnection(params) {\n        return (that.needDirectConnection === true && typeof params.previewLocalMedia === 'function');\n    }\n\n    function automaticDirectConnectionCaller(params) {\n        return (that.needDirectConnection === true && typeof params.previewLocalMedia !== 'function' &&\n            that.caller === true);\n    }\n\n    function createTimer(func, name, time) {\n        var id = setTimeout(function () {\n            id = null;\n            respoke.log.error(name, \"timer expired.\");\n            func();\n        }, time);\n        respoke.log.debug('setting timer', name, 'for', time / 1000, 'secs');\n        var timer  = {\n            name: name,\n            clear: function () {\n                if (id === null) {\n                    return;\n                }\n                respoke.log.debug('clearing timer', name);\n                clearTimeout(id);\n                id = null;\n            }\n        };\n        allTimers.push(timer);\n        return timer;\n    }\n\n    var stateParams = {\n        initialState: 'idle',\n        receiveLocalMedia: function () {\n            that.hasLocalMedia = true;\n        },\n        states: {\n            // State\n            idle: {\n                // Event\n                exit: function () {\n                    that.fire('idle:exit');\n                },\n                // Event\n                initiate: [{\n                    target: 'negotiatingContainer',\n                    guard: function (params) {\n                        assert(typeof params.client === 'object');\n                        assert(typeof params.caller === 'boolean');\n                        return (params.caller === true || params.client.hasListeners('call'));\n                    }\n                }, {\n                    target: 'terminated',\n                    guard: function (params) {\n                        if (params.caller !== true && !params.client.hasListeners('call')) {\n                            that.hangupReason = 'no call listener';\n                            that.signalBye = true;\n                            return true;\n                        }\n                        return false;\n                    }\n                }],\n                // Event\n                hangup: hangupEvent\n            },\n            // State\n            negotiatingContainer: {\n                init: \"preparing\",\n                // Event\n                hangup: hangupEvent,\n                // Event\n                modify: rejectModify,\n                states: {\n                    preparing: {\n                        // Event\n                        entry: {\n                            action: function () {\n                                that.hasLocalMediaApproval = false;\n                                that.hasLocalMedia = false;\n                                that.sentSDP = false;\n                                that.receivedSDP = false;\n                                that.processedRemoteSDP = false;\n                                that.isAnswered = false;\n                                if (!that.isModifying()) {\n                                    answerTimer = createTimer(function () {\n                                        that.dispatch('reject', {reason: \"answer own call timer \" + that.caller});\n                                    }, 'answer own call', answerTimeout);\n                                }\n                                that.fire('preparing:entry');\n                            }\n                        },\n                        // Event\n                        exit: function () {\n                            that.fire('preparing:exit');\n                            if (answerTimer) {\n                                answerTimer.clear();\n                            }\n                        },\n                        // Event\n                        reject: rejectEvent,\n                        // Event\n                        receiveOffer: {\n                            action: function (params) {\n                                that.receivedSDP = true;\n                                if (that.isAnswered) {\n                                    // If we get here, we are the callee and we've answered the call before the call\n                                    // creation/receive offer promise chain completed.\n                                    setTimeout(function () {\n                                        that.dispatch('answer', params);\n                                    });\n                                }\n                            }\n                        },\n                        // Event\n                        answer: [{\n                            action: function (params) {\n                                assert(!params.previewLocalMedia || typeof params.previewLocalMedia === 'function');\n                                that.isAnswered = true;\n                                if (typeof params.previewLocalMedia !== 'function') {\n                                    that.hasLocalMediaApproval = true;\n                                }\n                            }\n                        }, {\n                            // we are going to send media\n                            target: 'approvingDeviceAccess',\n                            guard: needToObtainMedia\n                        }, {\n                            // we are sending a direct connection & developer wants to approve\n                            target: 'approvingContent',\n                            guard: needToApproveDirectConnection\n                        }, {\n                            target: 'offering',\n                            guard: automaticDirectConnectionCaller\n                        }, {\n                            // we are not sending anything or developer does not want to approve media.\n                            target: 'connecting',\n                            guard: function (params) {\n                                // always for callee, caller will always answer before sending offer.\n                                // callee should always answer after receiving offer.\n                                if (!that.receivedSDP) {\n                                    return false;\n                                }\n\n                                if (needToObtainMedia(params) || needToApproveDirectConnection(params) ||\n                                        automaticDirectConnectionCaller(params)) {\n                                    return false;\n                                }\n\n                                if (!params.previewLocalMedia || that.receiveOnly) {\n                                    setTimeout(function () {\n                                        params.approve();\n                                    });\n                                }\n                                return (that.receiveOnly === true || that.needDirectConnection === true);\n                            }\n                        }]\n                    },\n                    // State\n                    gettingMedia: {\n                        reject: rejectEvent,\n                        // Event\n                        receiveLocalMedia: [{\n                            action: function () {\n                                that.hasLocalMedia = true;\n                            }\n                        }, {\n                            target: 'offering',\n                            guard: function (params) {\n                                return (that.caller === true && that.hasLocalMediaApproval === true &&\n                                    that.hasLocalMedia === true);\n                            }\n                        }, {\n                            target: 'connecting',\n                            guard: function (params) {\n                                return (that.caller === false && that.hasLocalMediaApproval === true &&\n                                    that.hasLocalMedia === true);\n                            }\n                        }],\n                        states: {\n                            // State\n                            approvingDeviceAccess: {\n                                // Event\n                                entry: function () {\n                                    that.fire('approving-device-access:entry');\n                                },\n                                // Event\n                                approve: [{\n                                    target: 'approvingContent',\n                                    guard: function (params) {\n                                        return (typeof params.previewLocalMedia === 'function');\n                                    }\n                                }, {\n                                    target: 'connecting',\n                                    guard: function (params) {\n                                        return (that.caller === false &&\n                                            (that.hasLocalMedia === true || that.needDirectConnection === true) &&\n                                            typeof params.previewLocalMedia !== 'function');\n                                    }\n                                }, {\n                                    target: 'offering',\n                                    guard: function (params) {\n                                        return (that.caller === true && that.hasLocalMedia === true &&\n                                            typeof params.previewLocalMedia !== 'function');\n                                    }\n                                }]\n                            },\n                            // State\n                            approvingContent: {\n                                // Event\n                                entry: function () {\n                                    that.fire('approving-content:entry');\n                                },\n                                // Event\n                                exit: function () {\n                                    that.fire('approving-content:exit');\n                                },\n                                // Event\n                                approve: [function (params) {\n                                    that.hasLocalMediaApproval = true;\n                                }, {\n                                    target: 'offering',\n                                    guard: function (params) {\n                                        return (that.caller === true && that.hasLocalMedia === true);\n                                    }\n                                }, {\n                                    target: 'connecting',\n                                    guard: function (params) {\n                                        return (that.caller === false && that.hasLocalMedia === true);\n                                    }\n                                }]\n                            }\n                        }\n                    },\n                    // State\n                    offeringContainer: {\n                        init: 'offering',\n                        reject: rejectEvent,\n                        sentOffer: function () {\n                            // start answer timer\n                            receiveAnswerTimer = createTimer(function () {\n                                that.dispatch('reject', {reason: \"receive answer timer\"});\n                            }, 'receive answer', receiveAnswerTimeout);\n                        },\n                        states: {\n                            offering: {\n                                // Event\n                                entry: function () {\n                                    that.fire('offering:entry');\n                                },\n                                // Event\n                                exit: function () {\n                                    that.fire('offering:exit');\n                                },\n                                // Event\n                                receiveLocalMedia: [function () {\n                                    that.hasLocalMedia = true;\n                                }, {\n                                    target: 'connected',\n                                    guard: function (params) {\n                                        // for direct connection, local media is the same as remote media\n                                        return (that.needDirectConnection === true);\n                                    }\n                                }],\n                                // Event\n                                receiveRemoteMedia: {\n                                    target: 'connected'\n                                },\n                                // Event\n                                receiveAnswer: [clearReceiveAnswerTimer, {\n                                    target: 'connecting'\n                                }]\n                            }\n                        }\n                    },\n                    // State\n                    connectingContainer: {\n                        init: 'connecting',\n                        reject: rejectEvent,\n                        receiveAnswer: clearReceiveAnswerTimer,\n                        states: {\n                            connecting: {\n                                // Event\n                                entry: function () {\n                                    that.fire('connecting:entry');\n\n                                    // set connection timer\n                                    connectionTimer = createTimer(function () {\n                                        that.dispatch('reject', {reason: \"connection timer\"});\n                                    }, 'connection', connectionTimeout);\n                                },\n                                // Event\n                                exit: function () {\n                                    if (connectionTimer) {\n                                        connectionTimer.clear();\n                                    }\n                                    if (modifyTimer) {\n                                        modifyTimer.clear();\n                                    }\n                                    that.fire('connecting:exit');\n                                },\n                                // Event\n                                receiveLocalMedia: [{\n                                    action: function () {\n                                        that.hasLocalMedia = true;\n                                    }\n                                }, {\n                                    target: 'connected',\n                                    guard: function (params) {\n                                        // for direct connection, local media is the same as remote media\n                                        return (that.needDirectConnection === true && that.caller === false);\n                                    }\n                                }],\n                                // Event\n                                receiveRemoteMedia: {\n                                    target: 'connected'\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // State\n            // This state is for when we are in limbo between connected and negotiating and we are\n            // trying to figure out if the other side will allow us to modify. If we receive modify in\n            // this state, we will reject it. If the other party is in connected, we will be able to modify.\n            modifyingContainer: {\n                init: 'modifying',\n                reject: rejectEvent,\n                // Event\n                modify: rejectModify,\n                // Event\n                hangup: hangupEvent,\n                states: {\n                    modifying: {\n                        // Event\n                        entry: function () {\n                            modifyTimer = createTimer(function () {\n                                that.dispatch('reject', {reason: \"modify timer\"});\n                            }, 'modify for caller', modifyTimeout);\n                            that.fire('modifying:entry');\n                        },\n                        // Event\n                        accept: [function () {\n                            that.caller = true;\n                        }, {\n                            target: 'preparing'\n                        }],\n                        // Event\n                        exit: function () {\n                            that.fire('modifying:exit');\n                        }\n                    }\n                }\n            },\n            // State\n            connectedContainer: {\n                init: 'connected',\n                reject: {\n                    target: 'terminated',\n                    action: function (params) {\n                        that.hangupReason = params.reason || \"got reject while connected\";\n                    }\n                },\n                receiveAnswer: clearReceiveAnswerTimer,\n                // Event\n                hangup: hangupEvent,\n                states: {\n                    connected: {\n                        // Event\n                        entry: function () {\n                            oldRole = that.caller;\n                            that.needDirectConnection = false;\n                            that.fire('connected:entry');\n                        },\n                        // Event\n                        exit: function () {\n                            that.fire('connected:exit');\n                        },\n                        // Event\n                        modify: [{\n                            // be notified that the other side would like modification\n                            target: 'preparing',\n                            guard: function (params) {\n                                params = params || {};\n                                if (params.receive === true) {\n                                    that.caller = false;\n                                    modifyTimer = createTimer(function () {\n                                        // If modify gets interrupted, go back to previous roles.\n                                        that.dispatch('reject', {reason: \"modify timer\"});\n                                    }, 'modify', modifyTimeout);\n                                    return true;\n                                }\n                            }\n                        }, {\n                            // request to begin modification\n                            target: 'modifying',\n                            guard: function (params) {\n                                params = params || {};\n                                return (params.receive !== true);\n                            }\n                        }]\n                    }\n                }\n            },\n            // State\n            terminatedContainer: {\n                init: 'terminated',\n                states: {\n                    terminated: {\n                        // Event\n                        entry: {\n                            action: function () {\n                                that.fire('terminated:entry');\n                                allTimers.forEach(function (timer) {\n                                    timer.clear();\n                                });\n                                setTimeout(function () {\n                                    fsm = null;\n                                    that.ignore();\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    stateParams.that = Object.create(Statechart);\n    fsm = respoke.Class(stateParams);\n    fsm.run({\n        // rename to 'debug' to enable\n        debugOff: function () {\n            // So we can print the caller. Debug most often used when testing & tests run in the same tab.\n            var args = Array.prototype.slice.call(arguments);\n            args.splice(0, 0, that.caller);\n            respoke.log.debug.apply(respoke.log, args);\n        }\n    });\n\n    /**\n     * Return the name of the current state.\n     * @memberof! respoke.CallState\n     * @method respoke.Call.getState\n     * @returns {string}\n     */\n    that.getState = function () {\n        if (!fsm) {\n            return 'terminated';\n        }\n        return fsm.currentState().name;\n    };\n\n    /**\n     * Synchronously dispatch an event, which may or may not change the state.\n     * @memberof! respoke.CallState\n     * @method respoke.Call.dispatch\n     */\n    that.dispatch = function (evt, args) {\n        var oldState;\n        var newState;\n\n        if (!fsm) {\n            return;\n        }\n\n        oldState = that.getState();\n        try {\n            fsm.dispatch(evt, args);\n        } catch (err) {\n            respoke.log.debug('error dispatching', evt, 'from', oldState, \"with\", args, err);\n            throw err;\n        }\n        newState = that.getState();\n        if (oldState === newState && nontransitionEvents.indexOf(evt) === -1) {\n            respoke.log.debug(that.caller, \"Possible bad event \" + evt + \", no transition occured.\");\n        }\n        respoke.log.debug(that.caller, 'dispatching', evt, 'moving from ', oldState, 'to', newState, args);\n    };\n\n    /**\n     * Determine whether or not we are in the middle of a call modification.\n     * @memberof! respoke.CallState\n     * @method respoke.Call.isModifying\n     * @returns {boolean}\n     */\n    that.isModifying = function () {\n        var modifyingStates = ['preparing', 'modifying', 'approvingDeviceAccess', 'approvingMedia', 'offering'];\n        return (modifyingStates.indexOf(that.getState()) > -1 && that.hasMedia());\n    };\n\n    /**\n     * Helper for testing state name\n     * @memberof! respoke.CallState\n     * @method respoke.Call.isState\n     * @param {string} name\n     * @returns {boolean}\n     */\n    that.isState = function (name) {\n        return (that.getState() === name);\n    };\n\n    assert(typeof that.hasMedia === 'function');\n    assert(typeof that.caller === 'boolean');\n    return that;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/callState.js\n ** module id = 13\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar log = require('loglevel');\nvar respoke = require('./respoke');\n\n/**\n * A `respoke.Call` is Respoke's interface into a WebRTC call, including getUserMedia, path and codec negotation,\n * and call state.\n *\n * There are several methods on an instance of `respoke.Client` which return a `respoke.Call`.\n *\n * @class respoke.Call\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @param {boolean} params.caller - whether or not we initiated the call\n * @param {boolean} [params.receiveOnly] - whether or not we accept media\n * @param {boolean} [params.sendOnly] - whether or not we send media\n * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n * relay servers. If it cannot flow through relay servers, the call will fail.\n * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n * required to flow peer-to-peer. If it cannot, the call will fail.\n * @param {respoke.Endpoint} params.remoteEndpoint - The endpoint who is being called.\n * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint.\n * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n * wants to perform an action between local media becoming available and calling approve().\n * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n * @param {function} params.signalReport - Signaling action from SignalingChannel.\n * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n * media renegotiation.\n * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n * element with the local audio and/or video attached.\n * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n * it was ended in a graceful manner. TODO: add the hangup reason to the Event.\n * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n * This callback will be called when media is muted or unmuted.\n * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n * for the user to give permission to start getting audio or video.\n * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n * the approval was automatic.\n * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n * granted by the browser without asking the user to approve it.\n * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local video attached to it.\n * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n * @returns {respoke.Call}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Call\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * A name to identify the type of object.\n     * @memberof! respoke.Call\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Call';\n\n    /**\n     * Whether or not the client is the caller of the call.\n     * @memberof! respoke.Call\n     * @name caller\n     * @type {boolean}\n     */\n    that.caller = !!that.caller;\n\n    /**\n     * The call ID.\n     * @memberof! respoke.Call\n     * @name id\n     * @type {string}\n     */\n    that.id = that.caller ? respoke.makeGUID() : that.id;\n\n    if (!that.id) {\n        throw new Error(\"Can't start a new call without a call id.\");\n    }\n\n    /**\n     * Promise used to trigger actions dependant upon having received media or a datachannel.\n     * @memberof! respoke.Call\n     * @name defMedia\n     * @private\n     * @type {Promise}\n     */\n    var defMedia = Q.defer();\n    /**\n     * Promise used to trigger notification of a request for renegotiating media. For the caller of the\n     * renegotiation (which doesn't have to be the same as the caller of the call), this is resolved\n     * or rejected as soon as the 'accept' or 'reject' signal is received. For the callee, it is\n     * resolved or rejected only after the developer or user approves or rejects the modify.\n     * @memberof! respoke.Call\n     * @name defModify\n     * @private\n     * @type {Promise}\n     */\n    var defModify;\n    /**\n     * @memberof! respoke.Call\n     * @name previewLocalMedia\n     * @private\n     * @type {respoke.Call.previewLocalMedia}\n     */\n    var previewLocalMedia = params.previewLocalMedia;\n    /**\n     * @memberof! respoke.Call\n     * @name client\n     * @private\n     * @type {respoke.getClient}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.Call\n     * @name signalingChannel\n     * @private\n     * @type {respoke.signalingChannel}\n     */\n    var signalingChannel = params.signalingChannel;\n    /**\n     * Informational property. Whether call debugs were enabled on the client during creation.\n     * Changing this value will do nothing.\n     * @name enableCallDebugReport\n     * @type {boolean}\n     */\n    that.enableCallDebugReport = params.signalingChannel.isSendingReport();\n    /**\n     * A flag indicating whether this call has audio.\n     *\n     * This becomes available after the call is accepted, for the client being called only.\n     *\n     * @name hasAudio\n     * @type {boolean}\n     */\n    that.hasAudio = undefined;\n    /**\n     * A flag indicating whether this call has video.\n     *\n     * This becomes available after the call is accepted, for the client being called only.\n     *\n     * @name hasVideo\n     * @type {boolean}\n     */\n    that.hasVideo = undefined;\n\n    /**\n     * Local media that we are sending to the remote party.\n     * @name outgoingMedia\n     * @type {respoke.LocalMedia}\n     */\n    that.outgoingMedia = respoke.LocalMedia({\n        instanceId: instanceId,\n        callId: that.id,\n        constraints: params.constraints || {\n            video: true,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        }\n    });\n\n    /**\n     * Remote media that we are receiving from the remote party.\n     * @name incomingMedia\n     * @type {respoke.RemoteMedia}\n     */\n    that.incomingMedia = respoke.RemoteMedia({\n        instanceId: instanceId,\n        callId: that.id,\n        constraints: params.constraints\n    });\n\n    /**\n     * This event indicates that local video has been unmuted.\n     * @event respoke.Call#mute\n     * @property {string} name - the event name.\n     * @property {respoke.Call} target\n     * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n     * has been changed.\n     * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n     */\n    that.outgoingMedia.listen('mute', function (evt) {\n        that.fire('mute', {\n            type: evt.type,\n            muted: evt.muted\n        });\n    });\n\n    delete params.signalingChannel;\n    delete that.signalingChannel;\n\n    /**\n     * @memberof! respoke.Call\n     * @name videoIsMuted\n     * @private\n     * @type {boolean}\n     */\n    var videoIsMuted = false;\n    /**\n     * @memberof! respoke.Call\n     * @name audioIsMuted\n     * @private\n     * @type {boolean}\n     */\n    var audioIsMuted = false;\n    /**\n     * @memberof! respoke.Call\n     * @name directConnection\n     * @private\n     * @type {respoke.DirectConnection}\n     */\n    var directConnection = null;\n    /**\n     * @memberof! respoke.Call\n     * @name toSendHangup\n     * @private\n     * @type {boolean}\n     */\n    var toSendHangup = null;\n\n    /**\n     * @memberof! respoke.Call\n     * @name pc\n     * @private\n     * @type {respoke.PeerConnection}\n     */\n    var pc = respoke.PeerConnection({\n        instanceId: instanceId,\n        state: respoke.CallState({\n            caller: that.caller,\n            needDirectConnection: params.needDirectConnection,\n            sendOnly: params.sendOnly,\n            receiveOnly: params.receiveOnly,\n            // hasMedia is not defined yet.\n            hasMedia: function () {\n                return that.hasMedia();\n            }\n        }),\n        forceTurn: !!params.forceTurn,\n        call: that,\n        pcOptions: {\n            optional: [\n                { DtlsSrtpKeyAgreement: true },\n                { RtpDataChannels: false }\n            ]\n        },\n        offerOptions: params.offerOptions || null,\n        signalOffer: function (args) {\n            if (!pc) {\n                return;\n            }\n\n            params.signalOffer(args);\n            pc.state.dispatch('sentOffer');\n        },\n        signalConnected: params.signalConnected,\n        signalAnswer: params.signalAnswer,\n        signalModify: params.signalModify,\n        signalHangup: params.signalHangup,\n        signalReport: params.signalReport,\n        signalCandidate: params.signalCandidate\n    });\n\n    /**\n     * Set up promises. If we're not the caller, we need to listen for approval AND the remote SDP to come in\n     * before we can act on the call. Save parameters sent in with the constructor, then delete them off the call.\n     * If this call was initiated with a DirectConnection, set it up so answer() will be the approval mechanism.\n     * @method respoke.Call.init\n     * @memberof! respoke.Call\n     * @fires respoke.Client#call\n     * @private\n     */\n    function init() {\n        log.debug('Call.init');\n\n        if (defModify !== undefined) {\n            defMedia = Q.defer();\n        }\n\n        pc.init(); // instantiates RTCPeerConnection, can't call on modify\n        if (defModify === undefined && pc.state.needDirectConnection === true) {\n            actuallyAddDirectConnection(params);\n        }\n    }\n\n    /**\n     * Register any event listeners passed in as callbacks, save other params to answer() and accept().\n     * @memberof! respoke.Call\n     * @method respoke.Call.saveParameters\n     * @param {object} params\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n     * it was ended in a graceful manner. TODO: add the hangup reason to the Event.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will fire even if\n     * the approval was automatic.\n     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n     * user's media.  This event gets fired even if the allow process is automatic, i. e., permission and media is\n     * granted by the browser without asking the user to approve it.\n     * @param {object} [params.constraints]\n     * @param {boolean} [params.forceTurn]\n     * @param {boolean} [params.receiveOnly]\n     * @param {boolean} [params.sendOnly]\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local video attached to it.\n     * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n     * @private\n     * @fires respoke.Call#stats\n     */\n    function saveParameters(params) {\n        /* This happens when the call is hung up automatically, for instance due to the lack of an onCall\n         * handler. In this case, pc has been set to null in hangup. The call has already failed, and the\n         * invocation of this function is an artifact of async code not being finished yet, so we can just\n         * skip all of this setup.\n         */\n        if (!pc) {\n            return;\n        }\n\n        that.listen('local-stream-received', params.onLocalMedia);\n        that.listen('connect', params.onConnect);\n        that.listen('hangup', params.onHangup);\n        that.listen('allow', params.onAllow);\n        that.listen('answer', params.onAnswer);\n        that.listen('approve', params.onApprove);\n        that.listen('mute', params.onMute);\n        that.listen('requesting-media', params.onRequestingMedia);\n\n        previewLocalMedia = typeof params.previewLocalMedia === 'function' ?\n            params.previewLocalMedia : previewLocalMedia;\n\n        pc.state.receiveOnly = typeof params.receiveOnly === 'boolean' ? params.receiveOnly : pc.state.receiveOnly;\n        pc.state.sendOnly = typeof params.sendOnly === 'boolean' ? params.sendOnly : pc.state.sendOnly;\n        pc.state.needDirectConnection = typeof params.needDirectConnection === 'boolean' ?\n            params.needDirectConnection : pc.state.needDirectConnection;\n        pc.disableTurn = params.disableTurn || pc.disableTurn;\n        pc.forceTurn = typeof params.forceTurn === 'boolean' ? params.forceTurn : pc.forceTurn;\n\n        that.outgoingMedia.constraints = params.constraints || that.outgoingMedia.constraints;\n        that.outgoingMedia.element = params.videoLocalElement || that.outgoingMedia.element;\n        if (pc.state.caller === true) {\n            // Only the person who initiated this round of media negotiation needs to estimate remote\n            // media based on what constraints local media is using.\n            that.incomingMedia.setConstraints(that.outgoingMedia.constraints);\n        }\n        that.incomingMedia.element = params.videoRemoteElement || that.incomingMedia.element;\n\n        pc.listen('stats', function fireStats(evt) {\n            /**\n             * This event is fired every time statistical information about audio and/or video on a call\n             * becomes available.\n             * @event respoke.Call#stats\n             * @type {respoke.Event}\n             * @property {respoke.MediaStats} stats - an object with stats in it.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.fire('stats', {stats: evt.stats});\n        }, true);\n\n        delete that.signalOffer;\n        delete that.signalConnected;\n        delete that.signalAnswer;\n        delete that.signalHangup;\n        delete that.signalReport;\n        delete that.signalCandidate;\n    }\n\n    /**\n     * Answer the call and start the process of obtaining media. This method is called automatically on the caller's\n     * side. This method must be called on the callee's side to indicate that the endpoint does wish to accept the\n     * call. The app will have a later opportunity, by passing a callback named previewLocalMedia, to approve or\n     * reject the call based on whether audio and/or video is working and is working at an acceptable level.\n     *\n     *     client.listen('call', function (evt) {\n     *         if (!evt.call.caller) {\n     *             evt.call.answer();\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.answer\n     * @fires respoke.Call#answer\n     * @param {object} [params]\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n     * it was ended in a graceful manner. TODO: add the hangup reason to the Event.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n     * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n     * granted by the browser without asking the user to approve it.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n     * @param {object} [params.constraints] - Information about the media for this call.\n     * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local video attached to it.\n     * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n     */\n    that.answer = function (params) {\n        params = params || {};\n        log.debug('Call.answer');\n\n        saveParameters(params);\n\n        pc.listen('connect', onRemoteStreamAdded, true);\n        pc.listen('remote-stream-removed', onRemoteStreamRemoved, true);\n\n        pc.state.once('approving-device-access:entry', function (evt) {\n            doAddVideo(params);\n        });\n        pc.state.dispatch('answer', {\n            previewLocalMedia: previewLocalMedia,\n            approve: that.approve\n        });\n        /**\n         * The call was answered.\n         * @event respoke.Call#answer\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('answer');\n    };\n\n    /**\n     * Accept a request to modify the media on the call. This method should be called within the Call#modify\n     * event listener, which gives the developer or website user a chance to see what changes are proposed and\n     * to accept or reject them.\n     *\n     *     call.listen('modify', function (evt) {\n     *         evt.call.accept();\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.accept\n     * @fires respoke.Call#accept\n     * @private\n     * @param {object} [params]\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the developer to receive the\n     * remote video element.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n     * @param {object} [params.constraints] - Information about the media for this call.\n     */\n    that.accept = that.answer;\n\n    /**\n     * Start the process of network and media negotiation. If the app passes in a callback named previewLocalMedia\n     * in order to allow the logged-in person a chance to base their decision to continue the call on whether\n     * audio and/or video is working correctly,\n     * this method must be called on both sides in order to begin the call. If call.approve() is called, the call\n     * will progress as expected. If call.reject() is called, the call will be aborted.\n     *\n     *     call.listen('local-stream-received', function (evt) {\n     *         if (userLikesVideo()) {\n     *             evt.call.approve();\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.approve\n     * @fires respoke.Call#approve\n     */\n    that.approve = function () {\n        log.debug('Call.approve');\n        /**\n         * Fired when the local media access is approved.\n         *\n         * @event respoke.Call#approve\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('approve');\n        pc.state.dispatch('approve', {\n            previewLocalMedia: previewLocalMedia\n        });\n\n        if (defModify && defModify.promise.isPending()) {\n            defModify.resolve(true);\n            defModify = undefined;\n        }\n    };\n\n    /**\n     * Listen for the remote side to remove media in the middle of the call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.onRemoteStreamRemoved\n     * @private\n     * @param {object}\n     */\n    function onRemoteStreamRemoved(evt) {\n        log.debug('pc event: remote stream removed');\n    }\n\n    /**\n     * Listen for the remote side to add additional media in the middle of the call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.onRemoteStreamAdded\n     * @private\n     * @param {object}\n     * @fires respoke.Call#connect\n     */\n    function onRemoteStreamAdded(evt) {\n        if (!pc) {\n            return;\n        }\n        log.debug('received remote media', evt);\n\n        that.incomingMedia.setStream(evt.stream);\n\n        /**\n         * Indicates that a remote media stream has been added to the call.\n         *\n         * @event respoke.Call#connect\n         * @event respoke.LocalMedia#connect\n         * @type {respoke.Event}\n         * @property {Element} element - The HTML5 Video element with the remote stream attached.\n         * @property {respoke.RemoteMedia} stream - The incomingMedia property on the call.\n         * @property {string} name - The event name.\n         * @property {respoke.Call} target\n         */\n        pc.state.dispatch('receiveRemoteMedia');\n        that.fire('connect', {\n            stream: evt.stream,\n            element: that.incomingMedia.element\n        });\n    }\n\n    /**\n     * ## The plugin `respoke.MediaStats` must be loaded before using this method.\n     *\n     * Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\n     * Since we have to wait for both the answer and offer to be available before starting\n     * statistics, the library returns a promise for the stats object. The statistics object does not contain the\n     * statistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\n     * the actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\n     * stream of statistics every `interval` seconds.  Returns null if stats module is not loaded.\n     *\n     *     call.getStats({\n     *         onStats: function (evt) {\n     *             console.log('Stats', evt.stats);\n     *         }\n     *     }).done(function () {\n     *         console.log('Stats started');\n     *     }, function (err) {\n     *         console.log('Call is already hung up.');\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getStats\n     * @param {object} params\n     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive\n     * the stats. If no callback is provided, the call's report will contain stats but the developer will not\n     * receive them on the client-side.\n     * @param {respoke.Call.statsSuccessHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Call.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n     * @returns {Promise<object>|null}\n     */\n    function getStats(params) {\n        if (pc && pc.getStats) {\n            that.listen('stats', params.onStats);\n            return pc.getStats(params);\n        }\n        return null;\n    }\n    if (respoke.MediaStats) {\n        that.getStats = getStats;\n    }\n\n    /**\n     * Return local video element with the logged-in endpoint's audio and/or video streams attached to it.\n     *\n     *     var el = call.getLocalElement();\n     *     container.append(el);\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getLocalElement\n     * @returns {Video} An HTML5 video element.\n     */\n    that.getLocalElement = function () {\n        return that.outgoingMedia.element;\n    };\n\n    /**\n     * Return remote video element with the remote endpoint's audio and/or video streams attached to it.\n     *\n     *     var el = call.getRemoteElement();\n     *     container.append(el);\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getRemoteElement\n     * @returns {Video} An HTML5 video element.\n     */\n    that.getRemoteElement = function () {\n        return that.incomingMedia.element;\n    };\n\n    /**\n     * Create the RTCPeerConnection and add handlers. Process any offer we have already received. This method is called\n     * after answer() so we cannot use this method to set up the DirectConnection.\n     * @memberof! respoke.Call\n     * @method respoke.Call.doAddVideo\n     * @private\n     * @param {object} params\n     * @param {object} [params.constraints] - getUserMedia constraints\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect]\n     * @param {respoke.Call.onHangup} [params.onHangup]\n     * @fires respoke.Call#requesting-media\n     * @fires respoke.Call#allow\n     * @fires respoke.Call#local-stream-received\n     */\n    function doAddVideo(params) {\n        log.debug('Call.doAddVideo');\n        saveParameters(params);\n        that.outgoingMedia.listen('requesting-media', function waitAllowHandler(evt) {\n            if (!pc) {\n                return;\n            }\n\n            /**\n             * The browser is asking for permission to access the User's media. This would be an ideal time\n             * to modify the UI of the application so that the user notices the request for permissions\n             * and approves it.\n             * @event respoke.Call#requesting-media\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.fire('requesting-media');\n        }, true);\n        that.outgoingMedia.listen('allow', function allowHandler(evt) {\n            if (!pc) {\n                return;\n            }\n\n            /**\n             * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n             * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n             * even if the allow process is automatic, i. e., permission and media is granted by the browser\n             * without asking the user to approve it.\n             * @event respoke.Call#allow\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.fire('allow');\n            pc.state.dispatch('approve', {\n                previewLocalMedia: previewLocalMedia\n            });\n        }, true);\n        that.outgoingMedia.listen('stream-received', function streamReceivedHandler(evt) {\n            if (!pc) {\n                return;\n            }\n\n            defMedia.resolve(that.outgoingMedia);\n            pc.addStream(evt.stream);\n            pc.state.dispatch('receiveLocalMedia');\n            if (typeof previewLocalMedia === 'function') {\n                previewLocalMedia(evt.element, that);\n            }\n\n            /**\n             * @event respoke.Call#local-stream-received\n             * @type {respoke.Event}\n             * @property {Element} element\n             * @property {respoke.LocalMedia} stream\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.fire('local-stream-received', {\n                element: evt.element,\n                stream: that.outgoingMedia\n            });\n        }, true);\n        that.outgoingMedia.listen('error', function errorHandler(evt) {\n            pc.state.dispatch('reject', {reason: 'media stream error'});\n            pc.report.callStoppedReason = evt.reason;\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.fire('error', {\n                reason: evt.reason\n            });\n        });\n\n        that.outgoingMedia.start();\n        return that.outgoingMedia;\n    }\n\n    /**\n     * Add a video and audio stream to the existing call. By default, this method adds both video AND audio.\n     * If audio is not desired, pass {audio: false}.\n     * @memberof! respoke.Call\n     * @method respoke.Call.addVideo\n     * @private\n     * @param {object} params\n     * @param {boolean} [params.audio=true]\n     * @param {boolean} [params.video=true]\n     * @param {object} [params.constraints] - getUserMedia constraints, indicating the media being requested is\n     * an audio and/or video stream.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect]\n     * @param {respoke.Call.onHangup} [params.onHangup]\n     * @param {respoke.Call.mediaSuccessHandler} [params.onSuccess]\n     * @param {respoke.Client.errorHandler} [params.onError]\n     * @returns {Promise<respoke.LocalMedia>}\n     */\n    that.addVideo = function (params) {\n        log.debug('Call.addVideo');\n        params = params || {};\n        params.constraints = params.constraints || {video: true, audio: true};\n        params.constraints.audio = typeof params.audio === 'boolean' ? params.audio : params.constraints.audio;\n        params.constraints.video = typeof params.video === 'boolean' ? params.video : params.constraints.video;\n        params.instanceId = instanceId;\n\n        if (!defMedia.promise.isFulfilled()) { // we're the callee & have just accepted to modify\n            doAddVideo(params);\n        } else { // we're the caller and need to see if we can modify\n            pc.startModify({\n                constraints: params.constraints\n            });\n            defModify = Q.defer();\n            defModify.promise.then(function modifyAccepted() {\n                doAddVideo(params);\n            });\n        }\n        return defModify.promise;\n    };\n\n    /**\n     * Add an audio stream to the existing call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.addAudio\n     * @private\n     * @param {object} params\n     * @param {boolean} [params.audio=true]\n     * @param {boolean} [params.video=false]\n     * @param {object} [params.constraints] - getUserMedia constraints, indicating the media being requested is\n     * an audio and/or video stream.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect]\n     * @param {respoke.Call.onHangup} [params.onHangup]\n     * @param {respoke.Call.mediaSuccessHandler} [params.onSuccess]\n     * @param {respoke.Client.errorHandler} [params.onError]\n     * @returns {Promise<respoke.LocalMedia>}\n     */\n    that.addAudio = function (params) {\n        params = params || {};\n        params.constraints = params.constraints || {video: false, audio: true};\n        params.constraints.video = typeof params.constraints.video === 'boolean' ?\n            params.constraints.video : false;\n        params.constraints.audio = typeof params.audio === 'boolean' ? params.audio : params.constraints.audio;\n        params.constraints.video = typeof params.video === 'boolean' ? params.video : params.constraints.video;\n        return that.addVideo(params);\n    };\n\n    /**\n     * Get the direct connection on this call, if it exists.\n     *\n     *     var dc = call.getDirectConnection();\n     *     if (!dc) {\n     *         console.log(\"No direct connection has been started.\");\n     *     } else {\n     *         dc.sendMessage({message: 'hi'});\n     *     }\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getDirectConnection\n     * @returns {respoke.DirectConnection}\n     */\n    that.getDirectConnection = function () {\n        return directConnection || null;\n    };\n\n    /**\n     * Remove a direct connection from the existing call. If there is no other media, this will hang up the call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.removeDirectConnection\n     * @private\n     * @param {object} params\n     * @arg {boolean} [params.skipModify] Do not restart media negotiation.\n     */\n    that.removeDirectConnection = function (params) {\n        params = params || {};\n        log.debug('Call.removeDirectConnection');\n\n        if (directConnection && directConnection.isActive()) {\n            directConnection.close({skipRemove: true});\n        }\n\n        if (!that.hasMedia()) {\n            log.debug('Hanging up because there are no local streams.');\n            that.hangup();\n            return;\n        }\n\n        if (params.skipModify === true) {\n            return;\n        }\n\n        pc.startModify({\n            directConnection: false\n        });\n        defModify = Q.defer();\n        defModify.promise.done(function onModifySuccess() {\n            defMedia.resolve();\n            defModify = undefined;\n        });\n    };\n\n    /**\n     * Add a direct connection to the existing call.\n     *\n     *     call.addDirectConnection({\n     *         onOpen: function (evt) {\n     *             console.log(\"Direct connection open!\");\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.addDirectConnection\n     * @private\n     * @param {object} params\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n     * closing the connection.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n     * opening the connection.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n     * respoke.Endpoint#message.\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n     * @param {respoke.Client.errorHandler} [params.onError]\n     * @returns {Promise<respoke.DirectConnection>}\n     */\n    that.addDirectConnection = function (params) {\n        log.debug('Call.addDirectConnection');\n        pc.startModify({\n            directConnection: true\n        });\n        defModify = Q.defer();\n        return defModify.promise.then(function onModifySuccess() {\n            return actuallyAddDirectConnection(params);\n        }, function onModifyError(err) {\n            throw err;\n        });\n    };\n\n    /**\n     * Add a direct connection to the existing call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.actuallyAddDirectConnection\n     * @private\n     * @param {object} params\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n     * closing the connection.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n     * opening the connection.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n     * respoke.Endpoint#message.\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n     * @param {respoke.Client.errorHandler} [params.onError]\n     * @returns {Promise<respoke.DirectConnection>}\n     * @fires respoke.Client#direct-connection\n     * @fires respoke.Call#direct-connection\n     */\n    function actuallyAddDirectConnection(params) {\n        log.debug('Call.actuallyAddDirectConnection', params);\n        params = params || {};\n        defMedia.promise.then(params.onSuccess, params.onError);\n\n        if (directConnection && directConnection.isActive()) {\n            if (defMedia.promise.isPending()) {\n                defMedia.resolve(directConnection);\n            } else {\n                log.warn(\"Not creating a new direct connection.\");\n            }\n            return defMedia.promise;\n        }\n\n        params.instanceId = instanceId;\n        params.pc = pc;\n        params.call = that;\n\n        directConnection = respoke.DirectConnection(params);\n\n        directConnection.listen('close', function closeHandler() {\n            if (!that.hasMedia()) {\n                log.debug('Hanging up because there are no local streams.');\n                that.hangup();\n            } else {\n                if (directConnection && directConnection.isActive()) {\n                    that.removeDirectConnection({skipModify: true});\n                }\n            }\n        }, true);\n\n        directConnection.listen('accept', function acceptHandler() {\n            if (pc.state.caller === false) {\n                log.debug('Answering as a result of approval.');\n            } else {\n                defMedia.resolve(directConnection);\n            }\n        }, true);\n\n        directConnection.listen('open', function openHandler() {\n            pc.state.dispatch('receiveRemoteMedia');\n        }, true);\n\n        directConnection.listen('error', function errorHandler(err) {\n            defMedia.reject(new Error(err));\n        }, true);\n\n        that.remoteEndpoint.directConnection = directConnection;\n\n        /**\n         * This event is fired when the local end of the directConnection is available. It still will not be\n         * ready to send and receive messages until the 'open' event fires.\n         * @event respoke.Call#direct-connection\n         * @type {respoke.Event}\n         * @property {respoke.DirectConnection} directConnection\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('direct-connection', {\n            directConnection: directConnection,\n            endpoint: that.remoteEndpoint\n        });\n\n        /**\n         * This event is fired when the logged-in endpoint is receiving a request to open a direct connection\n         * to another endpoint.  If the user wishes to allow the direct connection, calling\n         * evt.directConnection.accept() will allow the connection to be set up.\n         * @event respoke.Client#direct-connection\n         * @type {respoke.Event}\n         * @property {respoke.DirectConnection} directConnection\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         * @private\n         */\n        client.fire('direct-connection', {\n            directConnection: directConnection,\n            endpoint: that.remoteEndpoint\n        });\n\n        if (pc.state.caller === true) {\n            directConnection.accept();\n        }\n\n        return defMedia.promise;\n    }\n\n    /**\n     * Close the direct connection.\n     * @memberof! respoke.Call\n     * @method respoke.Call.closeDirectConnection\n     */\n    that.closeDirectConnection = function () {\n        if (directConnection) {\n            directConnection.close();\n            directConnection = null;\n        }\n    };\n\n    /**\n     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n     * signal is not false and we have not received a hangup signal from the remote party.\n     * @memberof! respoke.Call\n     * @method respoke.Call.hangup\n     * @fires respoke.Call#hangup\n     * @param {object} params\n     * @arg {boolean} params.signal Optional flag to indicate whether to send or suppress sending\n     * a hangup signal to the remote side.\n     */\n    that.hangup = function (params) {\n        if (!pc) {\n            return;\n        }\n        params = params || {};\n        params.reason = params.reason || \"hangup method called.\";\n        pc.state.dispatch('hangup', params);\n    };\n    that.hangup = respoke.once(that.hangup);\n\n    /**\n     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n     * signal is not false and we have not received a hangup signal from the remote party. This is an event\n     * handler added to the state machine via `once`.\n     * @memberof! respoke.Call\n     * @method respoke.Call.hangup\n     * @fires respoke.Call#hangup\n     * @private\n     */\n    var doHangup = function () {\n        log.debug('hangup', that.caller);\n\n        that.outgoingMedia.stop();\n\n        if (directConnection && directConnection.isActive()) {\n            directConnection.close();\n            that.remoteEndpoint.directConnection = null;\n            directConnection.ignore();\n            directConnection = null;\n        }\n\n        if (pc) {\n            pc.close({signal: (pc.state.receivedBye ? false : pc.state.signalBye)});\n        }\n\n        /**\n         * This event is fired when the call has hung up.\n         * @event respoke.Call#hangup\n         * @type {respoke.Event}\n         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('hangup', {\n            reason: pc.state.hangupReason || \"No reason specified.\"\n        });\n\n        pc.state.ignore();\n        pc.ignore();\n        that.ignore();\n        pc = null;\n    };\n    doHangup = respoke.once(doHangup);\n\n    /**\n     * Expose hangup as reject for approve/reject workflow.\n     * @memberof! respoke.Call\n     * @method respoke.Call.reject\n     * @param {object} params\n     */\n    that.reject = function () {\n        if (!pc) {\n            return;\n        }\n        pc.state.dispatch('reject', {reason: 'call.reject() called'});\n    };\n\n    /**\n     * Indicate whether a call is being setup or is in progress.\n     * @memberof! respoke.Call\n     * @method respoke.Call.isActive\n     * @returns {boolean}\n     */\n    that.isActive = function () {\n        // TODO: make this look for remote streams, too. Want to make this handle one-way media calls.\n        return !!(pc && pc.isActive() && (\n            (that.outgoingMedia.hasMedia()) ||\n            (directConnection && directConnection.isActive())\n        ));\n    };\n\n    /**\n     * Save the offer so we can tell the browser about it after the PeerConnection is ready.\n     * @memberof! respoke.Call\n     * @method respoke.Call.listenOffer\n     * @param {object} evt\n     * @param {object} evt.signal - The offer signal including the sdp\n     * @private\n     * @fires respoke.Call#modify\n     */\n    function listenOffer(evt) {\n        log.debug('listenOffer', evt.signal);\n        var info = {};\n\n        that.sessionId = evt.signal.sessionId;\n        pc.state.listen('connecting:entry', function () {\n            if (!pc.state.caller) {\n                pc.processOffer(evt.signal.sessionDescription);\n            }\n        });\n\n        /*\n         * Always overwrite constraints for callee on every offer, since answer() and accept() will\n         * always be called after parsing the SDP.\n         */\n        that.outgoingMedia.constraints.video = respoke.sdpHasVideo(evt.signal.sessionDescription.sdp);\n        that.outgoingMedia.constraints.audio = respoke.sdpHasAudio(evt.signal.sessionDescription.sdp);\n\n        log.info(\"Setting outgoingMedia constraints to\", that.outgoingMedia.constraints);\n\n        if (pc.state.isModifying()) {\n            if (pc.state.needDirectConnection === true) {\n                info.directConnection = directConnection;\n            } else if (pc.state.needDirectConnection === false) {\n                // Nothing\n            } else {\n                info.call = that;\n            }\n            /**\n             * Indicates a request to add something to an existing call. If 'constraints' is set, evt.constraints\n             * describes the media the other side has added. In this case, call.approve() must be called in order\n             * to approve the new media and send the same type of media.  If directConnection exists, the other side\n             * wishes to to open a direct connection. In order to approve, call directConnection.accept(). In either\n             * case, call.reject() and directConnection.reject() can be called to decline the request to add to the\n             * call.\n             * @event respoke.Call#modify\n             * @type {respoke.Event}\n             * @property {object} [constraints]\n             * @property {boolean} [directConnection]\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.fire('modify', info);\n        }\n\n        pc.state.dispatch('receiveOffer', {\n            previewLocalMedia: previewLocalMedia,\n            approve: that.approve\n        });\n    }\n\n    /**\n     * Save the answer and tell the browser about it.\n     * @memberof! respoke.Call\n     * @method respoke.Call.listenModify\n     * @private\n     */\n    function listenModify(evt) {\n        log.debug('Call.listenModify', evt);\n        if (evt.signal.action === 'initiate') {\n            defModify = Q.defer();\n            pc.state.dispatch('modify', {receive: true});\n        }\n    }\n\n    /**\n     * Set up state and media for the modify.\n     * @memberof! respoke.Call\n     * @method respoke.Call.onModifyAccept\n     * @param {respoke.Event} evt\n     * @private\n     */\n    function onModifyAccept(evt) {\n        pc.state.dispatch('accept');\n\n        if (evt.signal.action !== 'initiate') {\n            defModify.resolve(); // resolved later for callee\n            defModify = undefined;\n            return;\n        }\n\n        // callee only from here down\n\n        // init the directConnection if necessary. We don't need to do anything with\n        // audio or video right now.\n        if (evt.signal.directConnection === true) {\n            actuallyAddDirectConnection().done(function successHandler(dc) {\n                directConnection = dc;\n                directConnection.accept();\n            });\n        } else if (evt.signal.directConnection === false) {\n            if (directConnection) {\n                that.removeDirectConnection({skipModify: true});\n                defMedia.resolve(false);\n            }\n        }\n        pc.state.needDirectConnection = typeof evt.signal.directConnection === 'boolean' ? evt.signal.directConnection : null;\n        that.outgoingMedia.constraints = evt.signal.constraints || that.outgoingMedia.constraints;\n    }\n\n    /**\n     * Ignore the modify.\n     * @memberof! respoke.Call\n     * @method respoke.Call.onModifyReject\n     * @param {respoke.Event} evt\n     * @param {Error} evt.err\n     * @private\n     */\n    function onModifyReject(evt) {\n        if (evt.signal.action !== 'initiate') {\n            defMedia.reject(evt.err);\n            defModify.reject(evt.err);\n            defModify = undefined;\n        }\n    }\n\n    /**\n     * If video is muted, unmute. If not muted, mute.\n     * @deprecated\n     * @memberof! respoke.Call\n     * @method respoke.Call.toggleVideo\n     */\n    that.toggleVideo = function () {\n        if (that.isActive()) {\n            if (!videoIsMuted) {\n                that.muteVideo();\n            } else {\n                that.unmuteVideo();\n            }\n        }\n    };\n\n    /**\n     * If audio is muted, unmute. If not muted, mute.\n     * @deprecated\n     * @memberof! respoke.Call\n     * @method respoke.Call.toggleAudio\n     */\n    that.toggleAudio = function () {\n        if (that.isActive()) {\n            if (!audioIsMuted) {\n                that.muteAudio();\n            } else {\n                that.unmuteAudio();\n            }\n        }\n    };\n\n    /**\n     * Indicate whether the call has media flowing.\n     * @memberof! respoke.Call\n     * @method respoke.Call.hasMedia\n     * @returns {boolean}\n     */\n    that.hasMedia = function () {\n        var local;\n        var remote;\n\n        if (!pc || !pc.getLocalStreams) {\n            // PeerConnection.init() has not been called yet\n            return false;\n        }\n\n        local = pc.getLocalStreams();\n        remote = pc.getRemoteStreams();\n\n        if (directConnection && directConnection.isActive()) {\n            return true;\n        }\n\n        return (local.length > 0 || remote.length > 0);\n    };\n\n    /**\n     * Mute all local video streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.muteVideo\n     * @fires respoke.Call#mute\n     */\n    that.muteVideo = function () {\n        if (videoIsMuted) {\n            return;\n        }\n        that.outgoingMedia.muteVideo();\n        videoIsMuted = true;\n    };\n\n    /**\n     * Unmute all local video streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.unmuteVideo\n     * @fires respoke.Call#mute\n     */\n    that.unmuteVideo = function () {\n        if (!videoIsMuted) {\n            return;\n        }\n        that.outgoingMedia.unmuteVideo();\n        videoIsMuted = false;\n    };\n\n    /**\n     * Mute all local audio streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.muteAudio\n     * @fires respoke.Call#mute\n     */\n    that.muteAudio = function () {\n        if (audioIsMuted) {\n            return;\n        }\n        that.outgoingMedia.muteAudio();\n        audioIsMuted = true;\n    };\n\n    /**\n     * Unmute all local audio streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.unmuteAudio\n     * @fires respoke.Call#mute\n     */\n    that.unmuteAudio = function () {\n        if (!audioIsMuted) {\n            return;\n        }\n\n        that.outgoingMedia.unmuteAudio();\n        audioIsMuted = false;\n    };\n\n    /**\n     * Save the hangup reason and hang up.\n     * @memberof! respoke.Call\n     * @method respoke.Call.listenHangup\n     * @params {object} evt\n     * @params {object} evt.signal - The hangup signal, including an optional hangup reason.\n     * @private\n     */\n    function listenHangup(evt) {\n        if (!pc) {\n            return;\n        }\n        pc.report.callStoppedReason = evt.signal.reason || \"Remote side hung up\";\n        pc.state.receivedBye = true;\n        pc.state.dispatch('hangup', {signal: false, reason: pc.report.callStoppedReason});\n    }\n\n    pc.state.once('terminated:entry', function (evt) {\n        doHangup();\n    }, true);\n\n    that.listen('signal-offer', listenOffer, true);\n    that.listen('signal-hangup', listenHangup, true);\n    that.listen('signal-modify', listenModify, true);\n    pc.listen('modify-reject', onModifyReject, true);\n    pc.listen('modify-accept', onModifyAccept, true);\n    that.listen('signal-icecandidates', function onCandidateSignal(evt) {\n        if (!pc || !evt.signal.iceCandidates || !evt.signal.iceCandidates.length) {\n            return;\n        }\n        evt.signal.iceCandidates.forEach(function processCandidate(candidate) {\n            if (!pc) {\n                return;\n            }\n            pc.addRemoteCandidate({candidate: candidate});\n        });\n    }, true);\n\n    if (pc.state.needDirectConnection !== true) {\n        pc.state.once('preparing:entry', function () {\n            /**\n             * This event provides notification for when an incoming call is being received.  If the user wishes\n             * to allow the call, the app should call evt.call.answer() to answer the call.\n             * @event respoke.Client#call\n             * @type {respoke.Event}\n             * @property {respoke.Call} call\n             * @property {respoke.Endpoint} endpoint\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            client.fire('call', {\n                endpoint: that.remoteEndpoint,\n                call: that\n            });\n        }, true);\n    }\n\n    pc.state.listen('idle:exit', function (evt) {\n        saveParameters(params);\n    });\n\n    pc.state.listen('preparing:entry', function (evt) {\n        init();\n\n        if (pc.state.caller === true) {\n            that.answer();\n        }\n    }, true);\n\n    signalingChannel.getTurnCredentials().then(function (result) {\n        if (!pc) {\n            throw new Error(\"Already hung up.\");\n            return;\n        }\n        if (!result) {\n            log.warn(\"Relay service not available.\");\n            pc.servers = {iceServers: []};\n        } else {\n            pc.servers = {iceServers: result};\n        }\n    }).fin(function () {\n        if (!pc) {\n            throw new Error(\"Already hung up.\");\n            return;\n        }\n        pc.state.dispatch('initiate', {\n            client: client,\n            caller: that.caller\n        });\n    }).done(null, function (err) {\n        if (err.message !== \"Already hung up.\") {\n            log.debug('Unexpected exception', err);\n        }\n    });\n\n    return that;\n}; // End respoke.Call\n\n/**\n * Handle an error that resulted from a method call.\n * @callback respoke.Call.errorHandler\n * @param {Error} err\n */\n/**\n * Handle the successful kick-off of stats on a call.\n * @callback respoke.Call.statsSuccessHandler\n * @param {respoke.MediaStatsParser} statsParser\n */\n/**\n * Handle obtaining media successfully.\n * @callback respoke.Call.mediaSuccessHandler\n * @param {respoke.LocalMedia} localMedia\n */\n/**\n * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n * to show the user their own video during a call. This callback is called every time\n * respoke.Call#local-stream-received is fired.\n * @callback respoke.Call.onLocalMedia Callback for receiving an HTML5 Video\n * element with the local audio and/or video attached.\n * @param {respoke.Event} evt\n * @param {Element} evt.element\n * @param {respoke.LocalMedia} - The outgoingMedia property on the call.\n * @param {string} evt.name - The event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When on a call, receive remote media when it becomes available. This is what you will need to provide if you want\n * to show the user the other party's video during a call. This callback is called every time\n * respoke.Call#connect is fired.\n * @callback respoke.Call.onConnect\n * @param {respoke.Event} evt\n * @param {Element} evt.element - the HTML5 Video element with the new stream attached.\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When a call is in setup or media renegotiation happens. This callback will be called every time\n * respoke.Call#error.\n * @callback respoke.Call.onError\n * @param {respoke.Event} evt\n * @param {boolean} evt.reason - A human-readable description of the error.\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When on a call, receive notification the call has been hung up. This callback is called every time\n * respoke.Call#hangup is fired.\n * @callback respoke.Call.onHangup\n * @param {respoke.Event} evt\n * @param {boolean} evt.sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * Called when changing the mute state on any type of media. This callback will be called when media is muted or\n * unmuted. This callback is called every time respoke.Call#mute is fired.\n * @callback respoke.Call.onMute\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.target\n */\n/**\n * Called when the callee answers the call. This callback is called every time respoke.Call#answer is fired.\n * @callback respoke.Call.onAnswer\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.target\n */\n/**\n * Called when the user approves local media. This callback will be called whether or not the approval was based\n * on user feedback. I. e., it will be called even if the approval was automatic. This callback is called every time\n * respoke.Call#approve is fired.\n * @callback respoke.Call.onApprove\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.target\n */\n/**\n * When setting up a call, receive notification that the browser has granted access to media.  This callback is\n * called every time respoke.Call#allow is fired.\n * @callback respoke.Call.onAllow\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When setting up a call, receive notification that the app has asked the browser for permission to get audio or\n * video and is waiting on the browser to grant or reject permission. This callback will be called every time\n * respoke.Call#requesting-media is fired.\n * @callback respoke.Call.onRequestingMedia\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * The use of stats requires an additional module to Respoke. When on a call, receive periodic statistical\n * information about the call, including the codec, lost packets, and bandwidth being consumed. This callback is\n * called every time respoke.Call#stats is fired.\n * @callback respoke.MediaStatsParser.statsHandler\n * @param {respoke.Event} evt\n * @param {respoke.MediaStats} evt.stats - an object with stats in it.\n * @param {respoke.Call} evt.target\n * @param {string} evt.name - the event name.\n */\n/**\n * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n * to allow the user to preview and approve or reject their own video before a call. If this callback is provided,\n * Respoke will wait for call.answer() to be called before proceeding. If this callback is not provided,\n * Respoke will proceed without waiting for user input. This callback is called every time\n * respoke.Call#local-stream-received is fired.\n * @callback respoke.Call.previewLocalMedia\n * @param {object} element - the HTML5 Video element with the new stream attached.\n * @param {respoke.Call} call\n */\n/**\n * Receive the DirectConnection.\n * @callback respoke.Call.directConnectionSuccessHandler\n * @param {respoke.DirectConnection} directConnection\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/call.js\n ** module id = 14\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar respoke = require('./respoke');\n\n/**\n * A wrapper around the stream from `getUserMedia`,\n * which is attached to a call at `call.outgoingMedia`.\n *\n * @class respoke.LocalMedia\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @param {string} params.callId - call id\n * @param {object} [params.constraints]\n * @param {HTMLVideoElement} params.element - Pass in an optional html video element to have local\n * video attached to it.\n * @returns {respoke.LocalMedia}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.LocalMedia';\n    /**\n     * Respoke media ID (different from a `MediaStream.id`).\n     * @memberof! respoke.LocalMedia\n     * @name id\n     * @type {string}\n     */\n    that.id = respoke.makeGUID();\n\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name client\n     * @private\n     * @type {respoke.getClient}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * The HTML element with video attached.\n     * @memberof! respoke.LocalMedia\n     * @name element\n     * @type {HTMLVideoElement}\n     */\n    that.element = params.element;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name sdpHasAudio\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasAudio = false;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name sdpHasVideo\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasVideo = false;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name sdpHasDataChannel\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasDataChannel = false;\n    /**\n     * A timer to make sure we only fire {respoke.LocalMedia#requesting-media} if the browser doesn't\n     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n     * @memberof! respoke.LocalMedia\n     * @name allowTimer\n     * @private\n     * @type {number}\n     */\n    var allowTimer = 0;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name mediaOptions\n     * @private\n     * @type {object}\n     */\n    var mediaOptions = {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name pc\n     * @private\n     * @type {respoke.PeerConnection}\n     */\n    var pc = params.pc;\n    delete that.pc;\n    /**\n     * The local `MediaStream` from `getUserMedia()`.\n     * @memberof! respoke.LocalMedia\n     * @name stream\n     * @type {RTCMediaStream}\n     */\n    that.stream = null;\n\n    function getStream(theConstraints) {\n        for (var i = 0; i < respoke.streams.length; i++) {\n            var s = respoke.streams[i];\n            if (respoke.isEqual(s.constraints, theConstraints)) {\n                return s.stream;\n            }\n        }\n        return null;\n    }\n\n    function removeStream(theConstraints) {\n        var toRemoveIndex;\n        for (var i = 0; i < respoke.streams.length; i++) {\n            var s = respoke.streams[i];\n            if (respoke.isEqual(s.constraints, theConstraints)) {\n                toRemoveIndex = i;\n                break;\n            }\n        }\n        if (toRemoveIndex !== undefined) {\n            respoke.streams.splice(toRemoveIndex, 1);\n        }\n    }\n\n    function checkAndCreateElement(){\n\n        that.element = that.element || document.createElement('video');\n\n        that.element.muted = true;//need to do this with JS\n        that.element.autoplay = true;//gets converted\n\n\n        if (window.webrtcDetectedType === 'plugin' && !that.element.parentNode) {\n            //go and add it to the DOM in a hidden div\n\n            console.log('need to add this into the DOM');\n            document.body.appendChild(that.element);\n        }\n\n\n        return that.element;\n    }\n\n    /**\n     * Save the local stream. Kick off SDP creation.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.onReceiveUserMedia\n     * @private\n     * @param {RTCMediaStream} theStream\n     * @fires respoke.LocalMedia#stream-received\n     */\n    function onReceiveUserMedia(theStream) {\n        that.stream = theStream;\n        clearTimeout(allowTimer);\n        /**\n         * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n         * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n         * even if the allow process is automatic, i. e., permission and media is granted by the browser\n         * without asking the user to approve it.\n         * @event respoke.LocalMedia#allow\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         */\n        that.fire('allow');\n        log.debug('User gave permission to use media.');\n        log.debug('onReceiveUserMedia');\n\n        /**\n         * Expose getAudioTracks.\n         * @memberof! respoke.LocalMedia\n         * @method respoke.LocalMedia.getAudioTracks\n         */\n\n        that.getAudioTracks = function () {\n            return that.stream.getAudioTracks();\n        }\n\n        /**\n         * Expose getVideoTracks.\n         * @memberof! respoke.LocalMedia\n         * @method respoke.LocalMedia.getVideoTracks\n         */\n        that.getVideoTracks = function () {\n            return that.stream.getVideoTracks();\n        }\n\n        // This happens when we get an automatic hangup or reject from the other side.\n        if (pc === null) {\n            that.hangup({signal: false});\n            return;\n        }\n\n        that.element = checkAndCreateElement();\n\n        // This still needs some work. Using cached streams causes an unused video element to be passed\n        // back to the App. This is because we assume at the moment that only one local media video element\n        // will be needed. The first one passed back will contain media and the others will fake it. Media\n        // will still be sent with every peer connection. Also need to study the use of getLocalElement\n        // and the implications of passing back a video element with no media attached.\n        var aStream = getStream(that.constraints);\n        if (aStream) {\n            aStream.numPc += 1;\n\n            //testing\n            var documentOwner = that.element.ownerDocument;\n\n            // that.element.muted = true;//need to do this with JS\n            // that.element.autoplay = true;//gets converted\n\n            that.element = attachMediaStream(that.element, that.stream);\n\n            that.element.ownerDocument = documentOwner;\n\n            // // We won't want our local video outputting audio.\n            // that.element.muted = true;//temasys needs this changed\n            // that.element.autoplay = true;\n\n            /**\n             * @event respoke.LocalMedia#stream-received\n             * @type {respoke.Event}\n             * @property {Element} element - the HTML5 Video element with the new stream attached.\n             * @property {RTCMediaStream} stream - the HTML5 Video stream\n             * @property {string} name - the event name.\n             * @property {respoke.LocalMedia} target\n             */\n            that.fire('stream-received', {\n                element: that.element,\n                stream: that.stream\n            });\n        } else {\n            that.stream.numPc = 1;\n            respoke.streams.push({stream: that.stream, constraints: that.constraints});\n\n            that.stream.id = client.endpointId;\n\n            //testing\n            var documentOwner = that.element.ownerDocument;\n\n            that.element = attachMediaStream(that.element, that.stream);\n\n            that.element.ownerDocument = documentOwner;\n\n\n            // We won't want our local video outputting audio.\n            // that.element.muted = true;\n            // that.element.autoplay = true;\n\n            /**\n             * @event respoke.LocalMedia#stream-received\n             * @type {respoke.Event}\n             * @property {Element} element - the HTML5 Video element with the new stream attached.\n             * @property {RTCMediaStream} stream - the HTML5 Video stream\n             * @property {string} name - the event name.\n             * @property {respoke.LocalMedia} target\n             */\n            that.fire('stream-received', {\n                element: that.element,\n                stream: that.stream\n            });\n        }\n    }\n\n    /**\n     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.requestMedia\n     * @private\n     */\n    function requestMedia() {\n        log.debug('requestMedia');\n\n        if (!that.constraints) {\n            throw new Error('No constraints.');\n        }\n\n        var theStream = getStream(that.constraints);\n        if (theStream) {\n            log.debug('using old stream');\n            onReceiveUserMedia(theStream);\n            return;\n        }\n\n        try {\n            log.debug(\"Running getUserMedia with constraints\", that.constraints);\n            // TODO set getStream(that.constraints) = true as a flag that we are already\n            // attempting to obtain this media so the race condition where gUM is called twice with\n            // the same constraints when calls are placed too quickly together doesn't occur.\n            allowTimer = setTimeout(function allowTimer() {\n                /**\n                 * The browser is asking for permission to access the User's media. This would be an ideal time\n                 * to modify the UI of the application so that the user notices the request for permissions\n                 * and approves it.\n                 * @event respoke.LocalMedia#requesting-media\n                 * @type {respoke.Event}\n                 * @property {string} name - the event name.\n                 * @property {respoke.LocalMedia} target\n                 */\n                that.fire('requesting-media');\n            }, 500);\n            if (respoke.useFakeMedia === true) {\n                that.constraints.fake = true;\n            }\n            getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n        } catch (e) {\n            log.error(\"Couldn't get user media: \" + e.message);\n        }\n    }\n\n    /**\n     * Handle any error that comes up during the process of getting user media.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.onUserMediaError\n     * @private\n     * @param {object}\n     */\n    function onUserMediaError(p) {\n        log.debug('onUserMediaError');\n        if (p.code === 1) {\n            log.warn(\"Permission denied.\");\n            /**\n             * Indicate there has been an error obtaining media.\n             * @event respoke.LocalMedia#requesting-media\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.LocalMedia} target\n             */\n            that.fire('error', {error: 'Permission denied.'});\n        } else {\n            log.warn(p);\n            /**\n             * Indicate there has been an error obtaining media.\n             * @event respoke.LocalMedia#requesting-media\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.LocalMedia} target\n             */\n            that.fire('error', {error: p.code});\n        }\n    }\n\n    /**\n     * Whether the video stream is muted.\n     *\n     * All video tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isVideoMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getVideoTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute local video stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.muteVideo\n     * @fires respoke.LocalMedia#mute\n     */\n    that.muteVideo = function () {\n        if (that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute local video stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.unmuteVideo\n     * @fires respoke.LocalMedia#mute\n     */\n    that.unmuteVideo = function () {\n        if (!that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: false\n        });\n    };\n\n    /**\n     * Whether the audio stream is muted.\n     *\n     * All audio tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isAudioMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getAudioTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute local audio stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.muteAudio\n     * @fires respoke.LocalMedia#mute\n     */\n    that.muteAudio = function () {\n        if (that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute local audio stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.unmuteAudio\n     * @fires respoke.LocalMedia#mute\n     */\n    that.unmuteAudio = function () {\n        if (!that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: false\n        });\n    };\n\n    /**\n     * Stop the stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.stop\n     * @fires respoke.LocalMedia#stop\n     */\n    that.stop = function () {\n        if (!that.stream) {\n            return;\n        }\n\n        that.stream.numPc -= 1;\n        if (that.stream.numPc === 0) {\n            that.stream.stop();\n            removeStream(that.constraints);\n        }\n        that.stream = null;\n        /**\n         * @event respoke.LocalMedia#stop\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         */\n        that.fire('stop');\n    };\n\n    /**\n     * Indicate whether we are sending video.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.hasVideo\n     * @return {boolean}\n     */\n    that.hasVideo = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0);\n        }\n        return sdpHasVideo;\n    };\n\n    /**\n     * Indicate whether we are sending audio.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.hasAudio\n     * @return {boolean}\n     */\n    that.hasAudio = function () {\n        if (that.stream) {\n            return (that.stream.getAudioTracks().length > 0);\n        }\n        return sdpHasAudio;\n    };\n\n    /**\n     * Indicate whether we have media yet.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.hasMedia\n     * @return {boolean}\n     */\n    that.hasMedia = function () {\n        return !!that.stream;\n    };\n\n    /**\n     * Save and parse the SDP.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.setSDP\n     * @param {RTCSessionDescription} oSession\n     * @private\n     */\n    that.setSDP = function (oSession) {\n        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n    };\n\n    /**\n     * Start the stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.start\n     * @fires respoke.LocalMedia#start\n     * @private\n     */\n    that.start = function () {\n        requestMedia();\n    };\n\n    return that;\n}; // End respoke.LocalMedia\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/localMedia.js\n ** module id = 15\n ** module chunks = 0\n **/","/*\n * Copyright 2014, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar respoke = require('./respoke');\n\n/**\n * Class for managing the remote media stream, \n * which is attached to a call at `call.outgoingMedia`.\n * \n * @class respoke.RemoteMedia\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @param {string} params.callId - call id\n * @param {object} params.constraints\n * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote video attached to it.\n * @returns {respoke.RemoteMedia}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.RemoteMedia';\n    /**\n     * Respoke media ID (different from a `MediaStream.id`).\n     * @memberof! respoke.RemoteMedia\n     * @name id\n     * @type {string}\n     */\n    that.id = respoke.makeGUID();\n\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name client\n     * @private\n     * @type {respoke.getClient}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * The HTML element with attached video.\n     * @memberof! respoke.RemoteMedia\n     * @name element\n     * @type {HTMLVideoElement}\n     */\n    that.element = params.videoRemoteElement;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name sdpHasAudio\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasAudio = false;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name sdpHasVideo\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasVideo = false;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name sdpHasDataChannel\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasDataChannel = false;\n    /**\n     * A timer to make sure we only fire {respoke.RemoteMedia#requesting-media} if the browser doesn't\n     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n     * @memberof! respoke.RemoteMedia\n     * @name allowTimer\n     * @private\n     * @type {number}\n     */\n    var allowTimer = 0;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name mediaOptions\n     * @private\n     * @type {object}\n     */\n    var mediaOptions = {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name pc\n     * @private\n     * @type {respoke.PeerConnection}\n     */\n    var pc = params.pc;\n    delete that.pc;\n    /**\n     * The remote `MediaStream`.\n     * @memberof! respoke.RemoteMedia\n     * @name stream\n     * @type {RTCMediaStream}\n     */\n    that.stream = null;\n\n    /**\n     * Indicate whether we are receiving video.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.hasVideo\n     * @return {boolean}\n     */\n    that.hasVideo = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0);\n        }\n        return sdpHasVideo;\n    };\n\n    /**\n     * Indicate whether we are receiving audio.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.hasAudio\n     * @return {boolean}\n     */\n    that.hasAudio = function () {\n        if (that.stream) {\n            return (that.stream.getAudioTracks().length > 0);\n        }\n        return sdpHasAudio;\n    };\n\n    /**\n     * Indicate whether we have media yet.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.hasMedia\n     * @return {boolean}\n     */\n    that.hasMedia = function () {\n        return !!that.stream;\n    };\n\n    /**\n     * Save and parse the SDP\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.setSDP\n     * @param {RTCSessionDescription} oSession\n     * @private\n     */\n    that.setSDP = function (oSession) {\n        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n    };\n\n    /**\n     * Parse the constraints.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.setConstraints\n     * @param {MediaConstraints} constraints\n     * @private\n     */\n    that.setConstraints = function (constraints) {\n        that.constraints = constraints;\n        sdpHasVideo = respoke.constraintsHasVideo(that.constraints);\n        sdpHasAudio = respoke.constraintsHasAudio(that.constraints);\n    };\n\n    function checkAndCreateElement(){\n\n        that.element = that.element || document.createElement('video');\n\n        that.element.autoplay = true;\n\n        if (window.webrtcDetectedType === 'plugin' && !that.element.parentNode) {\n            console.log('need to add this into the DOM');\n            document.body.appendChild(that.element);\n        }\n\n        //go and add it to the DOM in a hidden div\n\n        return that.element;\n    }\n\n    /**\n     * Save the media stream\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.setStream\n     * @param {MediaStream} str\n     * @private\n     */\n    that.setStream = function (str) {\n        if (str) {\n            that.stream = str;\n            /**\n             * Expose getAudioTracks.\n             */\n            that.getAudioTracks = function(){\n                return that.stream.getAudioTracks();\n            }\n            /**\n             * Expose getVideoTracks.\n             */\n            that.getVideoTracks = function(){\n                return that.stream.getVideoTracks();\n            }\n\n\n            that.element = checkAndCreateElement();\n            //testing\n            var documentOwner = that.element.ownerDocument;\n\n            that.element = attachMediaStream(that.element, that.stream);\n\n            that.element.ownerDocument = documentOwner;\n\n            //moved\n            // that.element.autoplay = true;\n            setTimeout(function(){\n                that.element.play();\n            });\n        }\n    };\n\n    /**\n     * Stop the stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.stop\n     * @fires respoke.RemoteMedia#stop\n     */\n    that.stop = function () {\n        if (!that.stream) {\n            return;\n        }\n\n        that.stream.numPc -= 1;\n        if (that.stream.numPc === 0) {\n            that.stream.stop();\n            delete respoke.streams[that.constraints];\n        }\n        that.stream = null;\n        /**\n         * @event respoke.RemoteMedia#stop\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         */\n        that.fire('stop');\n    };\n\n    /**\n     * Whether the video stream is muted.\n     * \n     * All video tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isVideoMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getVideoTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute remote video stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.muteVideo\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.muteVideo = function () {\n        if (that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute remote video stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.unmuteVideo\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.unmuteVideo = function () {\n        if (!that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: false\n        });\n    };\n\n    /**\n     * Whether the audio stream is muted.\n     * \n     * All audio tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isAudioMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getAudioTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute remote audio stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.muteAudio\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.muteAudio = function () {\n        if (that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute remote audio stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.unmuteAudio\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.unmuteAudio = function () {\n        if (!that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: false\n        });\n    };\n\n    return that;\n}; // End respoke.RemoteMedia\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/remoteMedia.js\n ** module id = 16\n ** module chunks = 0\n **/","/*! adapterjs - v0.10.3 - 2015-01-16 */\n\n// Adapter's interface.\nAdapterJS = { options:{} };\n\n// uncomment to get virtual webcams\n// AdapterJS.options.getAllCams = true;\n\n// uncomment to prevent the install prompt when the plugin in not yet installed\n// AdapterJS.options.hidePluginInstallPrompt = true;\n\n// AdapterJS version\nAdapterJS.VERSION = '0.10.3';\n\n// Plugin namespace\nAdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {};\n\n// The object to store plugin information\nAdapterJS.WebRTCPlugin.pluginInfo = {\n  prefix : 'Tem',\n  plugName : 'TemWebRTCPlugin',\n  pluginId : 'plugin0',\n  type : 'application/x-temwebrtcplugin',\n  onload : '__TemWebRTCReady0',\n  portalLink : 'http://temasys.atlassian.net/wiki/display/TWPP/WebRTC+Plugins',\n  downloadLink : null, //set below\n  companyName: 'Temasys'\n};\nif(!!navigator.platform.match(/^Mac/i)) {\n  AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = 'http://bit.ly/1n77hco';\n}\nelse if(!!navigator.platform.match(/^Win/i)) {\n  AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = 'http://bit.ly/1kkS4FN';\n}\n\n// Unique identifier of each opened page\nAdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2);\n\n// Use this whenever you want to call the plugin.\nAdapterJS.WebRTCPlugin.plugin = null;\n\n// Set log level for the plugin once it is ready.\n// The different values are\n// This is an asynchronous function that will run when the plugin is ready\nAdapterJS.WebRTCPlugin.setLogLevel = null;\n\n// Defines webrtc's JS interface according to the plugin's implementation.\n// Define plugin Browsers as WebRTC Interface.\nAdapterJS.WebRTCPlugin.defineWebRTCInterface = null;\n\n// This function detects whether or not a plugin is installed.\n// Checks if Not IE (firefox, for example), else if it's IE,\n// we're running IE and do something. If not it is not supported.\nAdapterJS.WebRTCPlugin.isPluginInstalled = null;\n\n // Lets adapter.js wait until the the document is ready before injecting the plugin\nAdapterJS.WebRTCPlugin.pluginInjectionInterval = null;\n\n// Inject the HTML DOM object element into the page.\nAdapterJS.WebRTCPlugin.injectPlugin = null;\n\n// States of readiness that the plugin goes through when\n// being injected and stated\nAdapterJS.WebRTCPlugin.PLUGIN_STATES = {\n  NONE : 0,           // no plugin use\n  INITIALIZING : 1,   // Detected need for plugin\n  INJECTING : 2,      // Injecting plugin\n  INJECTED: 3,        // Plugin element injected but not usable yet\n  READY: 4            // Plugin ready to be used\n};\n\n// Current state of the plugin. You cannot use the plugin before this is\n// equal to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY\nAdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE;\n\n// Log levels for the plugin.\n// To be set by calling AdapterJS.WebRTCPlugin.setLogLevel\n/*\nLog outputs are prefixed in some cases.\n  INFO: Information reported by the plugin.\n  ERROR: Errors originating from within the plugin.\n  WEBRTC: Error originating from within the libWebRTC library\n*/\n// From the least verbose to the most verbose\nAdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {\n  NONE : 'NONE',\n  ERROR : 'ERROR',\n  WARNING : 'WARNING',\n  INFO: 'INFO',\n  VERBOSE: 'VERBOSE',\n  SENSITIVE: 'SENSITIVE'\n};\n\n// Does a waiting check before proceeding to load the plugin.\nAdapterJS.WebRTCPlugin.WaitForPluginReady = null;\n\n// This methid will use an interval to wait for the plugin to be ready.\nAdapterJS.WebRTCPlugin.callWhenPluginReady = null;\n\n// This function will be called if the plugin is needed (browser different\n// from Chrome or Firefox), but the plugin is not installed.\n// Override it according to your application logic.\nAdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = null;\n\n// !!!! WARNING: DO NOT OVERRIDE THIS FUNCTION. !!!\n// This function will be called when plugin is ready. It sends necessary\n// details to the plugin.\n// The function will wait for the document to be ready and the set the\n// plugin state to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,\n// indicating that it can start being requested.\n// This function is not in the IE/Safari condition brackets so that\n// TemPluginLoaded function might be called on Chrome/Firefox.\n// This function is the only private function that is not encapsulated to\n// allow the plugin method to be called.\n__TemWebRTCReady0 = function () {\n  if (document.readyState === 'complete') {\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n  } else {\n    AdapterJS.WebRTCPlugin.documentReadyInterval = setInterval(function () {\n      if (document.readyState === 'complete') {\n        // TODO: update comments, we wait for the document to be ready\n        clearInterval(AdapterJS.WebRTCPlugin.documentReadyInterval);\n        AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n      }\n    }, 100);\n  }\n};\n\n// The result of ice connection states.\n// - starting: Ice connection is starting.\n// - checking: Ice connection is checking.\n// - connected Ice connection is connected.\n// - completed Ice connection is connected.\n// - done Ice connection has been completed.\n// - disconnected Ice connection has been disconnected.\n// - failed Ice connection has failed.\n// - closed Ice connection is closed.\nAdapterJS._iceConnectionStates = {\n  starting : 'starting',\n  checking : 'checking',\n  connected : 'connected',\n  completed : 'connected',\n  done : 'completed',\n  disconnected : 'disconnected',\n  failed : 'failed',\n  closed : 'closed'\n};\n\n//The IceConnection states that has been fired for each peer.\nAdapterJS._iceConnectionFiredStates = [];\n\n\n// Check if WebRTC Interface is defined.\nAdapterJS.isDefined = null;\n\n// This function helps to retrieve the webrtc detected browser information.\n// This sets:\n// - webrtcDetectedBrowser: The browser agent name.\n// - webrtcDetectedVersion: The browser version.\n// - webrtcDetectedType: The types of webRTC support.\n//   - 'moz': Mozilla implementation of webRTC.\n//   - 'webkit': WebKit implementation of webRTC.\n//   - 'plugin': Using the plugin implementation.\nAdapterJS.parseWebrtcDetectedBrowser = function () {\n  var hasMatch, checkMatch = navigator.userAgent.match(\n    /(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || [];\n  if (/trident/i.test(checkMatch[1])) {\n    hasMatch = /\\brv[ :]+(\\d+)/g.exec(navigator.userAgent) || [];\n    webrtcDetectedBrowser = 'IE';\n    webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);\n  } else if (checkMatch[1] === 'Chrome') {\n    hasMatch = navigator.userAgent.match(/\\bOPR\\/(\\d+)/);\n    if (hasMatch !== null) {\n      webrtcDetectedBrowser = 'opera';\n      webrtcDetectedVersion = parseInt(hasMatch[1], 10);\n    }\n  }\n  if (navigator.userAgent.indexOf('Safari')) {\n    if (typeof InstallTrigger !== 'undefined') {\n      webrtcDetectedBrowser = 'firefox';\n    } else if (/*@cc_on!@*/ false || !!document.documentMode) {\n      webrtcDetectedBrowser = 'IE';\n    } else if (\n      Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) {\n      webrtcDetectedBrowser = 'safari';\n    } else if (!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {\n      webrtcDetectedBrowser = 'opera';\n    } else if (!!window.chrome) {\n      webrtcDetectedBrowser = 'chrome';\n    }\n  }\n  if (!webrtcDetectedBrowser) {\n    webrtcDetectedVersion = checkMatch[1];\n  }\n  if (!webrtcDetectedVersion) {\n    try {\n      checkMatch = (checkMatch[2]) ? [checkMatch[1], checkMatch[2]] :\n        [navigator.appName, navigator.appVersion, '-?'];\n      if ((hasMatch = navigator.userAgent.match(/version\\/(\\d+)/i)) !== null) {\n        checkMatch.splice(1, 1, hasMatch[1]);\n      }\n      webrtcDetectedVersion = parseInt(checkMatch[1], 10);\n    } catch (error) { }\n  }\n};\n\n// To fix configuration as some browsers does not support\n// the 'urls' attribute.\nAdapterJS.maybeFixConfiguration = function (pcConfig) {\n  if (pcConfig === null) {\n    return;\n  }\n  for (var i = 0; i < pcConfig.iceServers.length; i++) {\n    if (pcConfig.iceServers[i].hasOwnProperty('urls')) {\n      pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;\n      delete pcConfig.iceServers[i].urls;\n    }\n  }\n};\n\nAdapterJS.addEvent = function(elem, evnt, func) {\n   if (elem.addEventListener)  // W3C DOM\n      elem.addEventListener(evnt, func, false);\n   else if (elem.attachEvent) // OLD IE DOM\n      elem.attachEvent(\"on\"+evnt, func);\n   else // No much to do\n      elem[evnt] = func;\n}\n\n// -----------------------------------------------------------\n// Detected webrtc implementation. Types are:\n// - 'moz': Mozilla implementation of webRTC.\n// - 'webkit': WebKit implementation of webRTC.\n// - 'plugin': Using the plugin implementation.\nwebrtcDetectedType = null;\n\n// Detected webrtc datachannel support. Types are:\n// - 'SCTP': SCTP datachannel support.\n// - 'RTP': RTP datachannel support.\nwebrtcDetectedDCSupport = null;\n\n// Set the settings for creating DataChannels, MediaStream for\n// Cross-browser compability.\n// - This is only for SCTP based support browsers.\n// the 'urls' attribute.\ncheckMediaDataChannelSettings =\n  function (peerBrowserAgent, peerBrowserVersion, callback, constraints) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  var beOfferer = true;\n  var isLocalFirefox = webrtcDetectedBrowser === 'firefox';\n  // Nightly version does not require MozDontOfferDataChannel for interop\n  var isLocalFirefoxInterop = webrtcDetectedType === 'moz' && webrtcDetectedVersion > 30;\n  var isPeerFirefox = peerBrowserAgent === 'firefox';\n  var isPeerFirefoxInterop = peerBrowserAgent === 'firefox' &&\n    ((peerBrowserVersion) ? (peerBrowserVersion > 30) : false);\n\n  // Resends an updated version of constraints for MozDataChannel to work\n  // If other userAgent is firefox and user is firefox, remove MozDataChannel\n  if ((isLocalFirefox && isPeerFirefox) || (isLocalFirefoxInterop)) {\n    try {\n      delete constraints.mandatory.MozDontOfferDataChannel;\n    } catch (error) {\n      console.error('Failed deleting MozDontOfferDataChannel');\n      console.error(error);\n    }\n  } else if ((isLocalFirefox && !isPeerFirefox)) {\n    constraints.mandatory.MozDontOfferDataChannel = true;\n  }\n  if (!isLocalFirefox) {\n    // temporary measure to remove Moz* constraints in non Firefox browsers\n    for (var prop in constraints.mandatory) {\n      if (constraints.mandatory.hasOwnProperty(prop)) {\n        if (prop.indexOf('Moz') !== -1) {\n          delete constraints.mandatory[prop];\n        }\n      }\n    }\n  }\n  // Firefox (not interopable) cannot offer DataChannel as it will cause problems to the\n  // interopability of the media stream\n  if (isLocalFirefox && !isPeerFirefox && !isLocalFirefoxInterop) {\n    beOfferer = false;\n  }\n  callback(beOfferer, constraints);\n};\n\n// Handles the differences for all browsers ice connection state output.\n// - Tested outcomes are:\n//   - Chrome (offerer)  : 'checking' > 'completed' > 'completed'\n//   - Chrome (answerer) : 'checking' > 'connected'\n//   - Firefox (offerer) : 'checking' > 'connected'\n//   - Firefox (answerer): 'checking' > 'connected'\ncheckIceConnectionState = function (peerId, iceConnectionState, callback) {\n  if (typeof callback !== 'function') {\n    console.warn('No callback specified in checkIceConnectionState. Aborted.');\n    return;\n  }\n  peerId = (peerId) ? peerId : 'peer';\n\n  if (!AdapterJS._iceConnectionFiredStates[peerId] ||\n    iceConnectionState === AdapterJS._iceConnectionStates.disconnected ||\n    iceConnectionState === AdapterJS._iceConnectionStates.failed ||\n    iceConnectionState === AdapterJS._iceConnectionStates.closed) {\n    AdapterJS._iceConnectionFiredStates[peerId] = [];\n  }\n  iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState];\n  if (AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) < 0) {\n    AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState);\n    if (iceConnectionState === AdapterJS._iceConnectionStates.connected) {\n      setTimeout(function () {\n        AdapterJS._iceConnectionFiredStates[peerId]\n          .push(AdapterJS._iceConnectionStates.done);\n        callback(AdapterJS._iceConnectionStates.done);\n      }, 1000);\n    }\n    callback(iceConnectionState);\n  }\n  return;\n};\n\n// Firefox:\n// - Creates iceServer from the url for Firefox.\n// - Create iceServer with stun url.\n// - Create iceServer with turn url.\n//   - Ignore the transport parameter from TURN url for FF version <=27.\n//   - Return null for createIceServer if transport=tcp.\n// - FF 27 and above supports transport parameters in TURN url,\n// - So passing in the full url to create iceServer.\n// Chrome:\n// - Creates iceServer from the url for Chrome M33 and earlier.\n//   - Create iceServer with stun url.\n//   - Chrome M28 & above uses below TURN format.\n// Plugin:\n// - Creates Ice Server for Plugin Browsers\n//   - If Stun - Create iceServer with stun url.\n//   - Else - Create iceServer with turn url\n//   - This is a WebRTC Function\ncreateIceServer = null;\n\n// Firefox:\n// - Creates IceServers for Firefox\n//   - Use .url for FireFox.\n//   - Multiple Urls support\n// Chrome:\n// - Creates iceServers from the urls for Chrome M34 and above.\n//   - .urls is supported since Chrome M34.\n//   - Multiple Urls support\n// Plugin:\n// - Creates Ice Servers for Plugin Browsers\n//   - Multiple Urls support\n//   - This is a WebRTC Function\ncreateIceServers = null;\n//------------------------------------------------------------\n\n//The RTCPeerConnection object.\nRTCPeerConnection = null;\n\n// Creates RTCSessionDescription object for Plugin Browsers\nRTCSessionDescription = (typeof RTCSessionDescription === 'function') ?\n  RTCSessionDescription : null;\n\n// Creates RTCIceCandidate object for Plugin Browsers\nRTCIceCandidate = (typeof RTCIceCandidate === 'function') ?\n  RTCIceCandidate : null;\n\n// Get UserMedia (only difference is the prefix).\n// Code from Adam Barth.\ngetUserMedia = null;\n\n// Attach a media stream to an element.\nattachMediaStream = null;\n\n// Re-attach a media stream to an element.\nreattachMediaStream = null;\n\n\n// Detected browser agent name. Types are:\n// - 'firefox': Firefox browser.\n// - 'chrome': Chrome browser.\n// - 'opera': Opera browser.\n// - 'safari': Safari browser.\n// - 'IE' - Internet Explorer browser.\nwebrtcDetectedBrowser = null;\n\n// Detected browser version.\nwebrtcDetectedVersion = null;\n\n// Check for browser types and react accordingly\nif (navigator.mozGetUserMedia) {\n  webrtcDetectedBrowser = 'firefox';\n  webrtcDetectedVersion = parseInt(navigator\n    .userAgent.match(/Firefox\\/([0-9]+)\\./)[1], 10);\n  webrtcDetectedType = 'moz';\n  webrtcDetectedDCSupport = 'SCTP';\n\n  RTCPeerConnection = function (pcConfig, pcConstraints) {\n    AdapterJS.maybeFixConfiguration(pcConfig);\n    return new mozRTCPeerConnection(pcConfig, pcConstraints);\n  };\n\n // The RTCSessionDescription object.\n  RTCSessionDescription = mozRTCSessionDescription;\n  window.RTCSessionDescription = RTCSessionDescription;\n\n  // The RTCIceCandidate object.\n  RTCIceCandidate = mozRTCIceCandidate;\n  window.RTCIceCandidate = RTCIceCandidate;\n\n  getUserMedia = navigator.mozGetUserMedia.bind(navigator);\n  navigator.getUserMedia = getUserMedia;\n\n  // Shim for MediaStreamTrack.getSources.\n  MediaStreamTrack.getSources = function(successCb) {\n    setTimeout(function() {\n      var infos = [\n        { kind: 'audio', id: 'default', label:'', facing:'' },\n        { kind: 'video', id: 'default', label:'', facing:'' }\n      ];\n      successCb(infos);\n    }, 0);\n  };\n\n  createIceServer = function (url, username, password) {\n    var iceServer = null;\n    var url_parts = url.split(':');\n    if (url_parts[0].indexOf('stun') === 0) {\n      iceServer = { url : url };\n    } else if (url_parts[0].indexOf('turn') === 0) {\n      if (webrtcDetectedVersion < 27) {\n        var turn_url_parts = url.split('?');\n        if (turn_url_parts.length === 1 ||\n          turn_url_parts[1].indexOf('transport=udp') === 0) {\n          iceServer = {\n            url : turn_url_parts[0],\n            credential : password,\n            username : username\n          };\n        }\n      } else {\n        iceServer = {\n          url : url,\n          credential : password,\n          username : username\n        };\n      }\n    }\n    return iceServer;\n  };\n\n  createIceServers = function (urls, username, password) {\n    var iceServers = [];\n    for (i = 0; i < urls.length; i++) {\n      var iceServer = createIceServer(urls[i], username, password);\n      if (iceServer !== null) {\n        iceServers.push(iceServer);\n      }\n    }\n    return iceServers;\n  };\n\n  attachMediaStream = function (element, stream) {\n    element.mozSrcObject = stream;\n    element.play();\n    return element;\n  };\n\n  reattachMediaStream = function (to, from) {\n    to.mozSrcObject = from.mozSrcObject;\n    to.play();\n    return to;\n  };\n\n  MediaStreamTrack.getSources = MediaStreamTrack.getSources || function (callback) {\n    if (!callback) {\n      throw new TypeError('Failed to execute \\'getSources\\' on \\'MediaStreamTrack\\'' +\n        ': 1 argument required, but only 0 present.');\n    }\n    return callback([]);\n  };\n\n  // Fake get{Video,Audio}Tracks\n  if (!MediaStream.prototype.getVideoTracks) {\n    MediaStream.prototype.getVideoTracks = function () {\n      return [];\n    };\n  }\n  if (!MediaStream.prototype.getAudioTracks) {\n    MediaStream.prototype.getAudioTracks = function () {\n      return [];\n    };\n  }\n} else if (navigator.webkitGetUserMedia) {\n  webrtcDetectedBrowser = 'chrome';\n  webrtcDetectedType = 'webkit';\n  webrtcDetectedVersion = parseInt(navigator\n    .userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./)[2], 10);\n  // check if browser is opera 20+\n  var checkIfOpera = navigator.userAgent.match(/\\bOPR\\/(\\d+)/);\n  if (checkIfOpera !== null) {\n    webrtcDetectedBrowser = 'opera';\n    webrtcDetectedVersion = parseInt(checkIfOpera[1], 10);\n  }\n  // check browser datachannel support\n  if ((webrtcDetectedBrowser === 'chrome' && webrtcDetectedVersion >= 31) ||\n    (webrtcDetectedBrowser === 'opera' && webrtcDetectedVersion >= 20)) {\n    webrtcDetectedDCSupport = 'SCTP';\n  } else if (webrtcDetectedBrowser === 'chrome' && webrtcDetectedVersion < 30 &&\n    webrtcDetectedVersion > 24) {\n    webrtcDetectedDCSupport = 'RTP';\n  } else {\n    webrtcDetectedDCSupport = '';\n  }\n\n  createIceServer = function (url, username, password) {\n    var iceServer = null;\n    var url_parts = url.split(':');\n    if (url_parts[0].indexOf('stun') === 0) {\n      iceServer = { 'url' : url };\n    } else if (url_parts[0].indexOf('turn') === 0) {\n      iceServer = {\n        'url' : url,\n        'credential' : password,\n        'username' : username\n      };\n    }\n    return iceServer;\n  };\n\n  createIceServers = function (urls, username, password) {\n    var iceServers = [];\n    if (webrtcDetectedVersion >= 34) {\n      iceServers = {\n        'urls' : urls,\n        'credential' : password,\n        'username' : username\n      };\n    } else {\n      for (i = 0; i < urls.length; i++) {\n        var iceServer = createIceServer(urls[i], username, password);\n        if (iceServer !== null) {\n          iceServers.push(iceServer);\n        }\n      }\n    }\n    return iceServers;\n  };\n\n  RTCPeerConnection = function (pcConfig, pcConstraints) {\n    if (webrtcDetectedVersion < 34) {\n      AdapterJS.maybeFixConfiguration(pcConfig);\n    }\n    return new webkitRTCPeerConnection(pcConfig, pcConstraints);\n  };\n\n  getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n  navigator.getUserMedia = getUserMedia;\n\n  attachMediaStream = function (element, stream) {\n    if (typeof element.srcObject !== 'undefined') {\n      element.srcObject = stream;\n    } else if (typeof element.mozSrcObject !== 'undefined') {\n      element.mozSrcObject = stream;\n    } else if (typeof element.src !== 'undefined') {\n      element.src = URL.createObjectURL(stream);\n    } else {\n      console.log('Error attaching stream to element.');\n    }\n    return element;\n  };\n\n  reattachMediaStream = function (to, from) {\n    to.src = from.src;\n    return to;\n  };\n} else { // TRY TO USE PLUGIN\n  // IE 9 is not offering an implementation of console.log until you open a console\n  if (typeof console !== 'object' || typeof console.log !== 'function') {\n    /* jshint -W020 */\n    console = {} || console;\n    // Implemented based on console specs from MDN\n    // You may override these functions\n    console.log = function (arg) {};\n    console.info = function (arg) {};\n    console.error = function (arg) {};\n    console.dir = function (arg) {};\n    console.exception = function (arg) {};\n    console.trace = function (arg) {};\n    console.warn = function (arg) {};\n    console.count = function (arg) {};\n    console.debug = function (arg) {};\n    console.count = function (arg) {};\n    console.time = function (arg) {};\n    console.timeEnd = function (arg) {};\n    console.group = function (arg) {};\n    console.groupCollapsed = function (arg) {};\n    console.groupEnd = function (arg) {};\n    /* jshint +W020 */\n  }\n  webrtcDetectedType = 'plugin';\n  webrtcDetectedDCSupport = 'plugin';\n  AdapterJS.parseWebrtcDetectedBrowser();\n  isIE = webrtcDetectedBrowser === 'IE';\n\n  /* jshint -W035 */\n  AdapterJS.WebRTCPlugin.WaitForPluginReady = function() {\n    while (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n      /* empty because it needs to prevent the function from running. */\n    }\n  };\n  /* jshint +W035 */\n\n  AdapterJS.WebRTCPlugin.callWhenPluginReady = function (callback) {\n    if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n      // Call immediately if possible\n      // Once the plugin is set, the code will always take this path\n      callback();\n    } else {\n      // otherwise start a 100ms interval\n      var checkPluginReadyState = setInterval(function () {\n        if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n          clearInterval(checkPluginReadyState);\n          callback();\n        }\n      }, 100);\n    }\n  };\n\n  AdapterJS.WebRTCPlugin.setLogLevel = function(logLevel) {\n    AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n      AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);\n    });\n  };\n\n  AdapterJS.WebRTCPlugin.injectPlugin = function () {\n    // only inject once the page is ready\n    if (document.readyState !== 'complete')\n      return;\n\n    // Prevent multiple injections\n    if (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING)\n      return;\n\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING;\n\n    if (webrtcDetectedBrowser === 'IE' && webrtcDetectedVersion <= 10) {\n      var frag = document.createDocumentFragment();\n      AdapterJS.WebRTCPlugin.plugin = document.createElement('div');\n      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" type=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.type + '\" ' + 'width=\"1\" height=\"1\">' +\n        '<param name=\"pluginId\" value=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" /> ' +\n        '<param name=\"windowless\" value=\"false\" /> ' +\n        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n        '<param name=\"onload\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.onload +\n        '\" />' +\n        // uncomment to be able to use virtual cams\n        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n\n        '</object>';\n      while (AdapterJS.WebRTCPlugin.plugin.firstChild) {\n        frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);\n      }\n      document.body.appendChild(frag);\n\n      // Need to re-fetch the plugin\n      AdapterJS.WebRTCPlugin.plugin =\n        document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);\n    } else {\n      // Load Plugin\n      AdapterJS.WebRTCPlugin.plugin = document.createElement('object');\n      AdapterJS.WebRTCPlugin.plugin.id =\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId;\n      // IE will only start the plugin if it's ACTUALLY visible\n      if (isIE) {\n        AdapterJS.WebRTCPlugin.plugin.width = '1px';\n        AdapterJS.WebRTCPlugin.plugin.height = '1px';\n      }\n      AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type;\n      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name=\"onload\" value=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.onload + '\">' +\n        '<param name=\"pluginId\" value=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\">' +\n        '<param name=\"windowless\" value=\"false\" /> ' +\n        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\">';\n      document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);\n    }\n\n\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;\n  };\n\n  AdapterJS.WebRTCPlugin.isPluginInstalled =\n    function (comName, plugName, installedCb, notInstalledCb) {\n    if (!isIE) {\n      var pluginArray = navigator.plugins;\n      for (var i = 0; i < pluginArray.length; i++) {\n        if (pluginArray[i].name.indexOf(plugName) >= 0) {\n          installedCb();\n          return;\n        }\n      }\n      notInstalledCb();\n    } else {\n      try {\n        var axo = new ActiveXObject(comName + '.' + plugName);\n      } catch (e) {\n        notInstalledCb();\n        return;\n      }\n      installedCb();\n    }\n  };\n\n  AdapterJS.WebRTCPlugin.defineWebRTCInterface = function () {\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING;\n\n    AdapterJS.isDefined = function (variable) {\n      return variable !== null && variable !== undefined;\n    };\n\n    createIceServer = function (url, username, password) {\n      var iceServer = null;\n      var url_parts = url.split(':');\n      if (url_parts[0].indexOf('stun') === 0) {\n        iceServer = {\n          'url' : url,\n          'hasCredentials' : false\n        };\n      } else if (url_parts[0].indexOf('turn') === 0) {\n        iceServer = {\n          'url' : url,\n          'hasCredentials' : true,\n          'credential' : password,\n          'username' : username\n        };\n      }\n      return iceServer;\n    };\n\n    createIceServers = function (urls, username, password) {\n      var iceServers = [];\n      for (var i = 0; i < urls.length; ++i) {\n        iceServers.push(createIceServer(urls[i], username, password));\n      }\n      return iceServers;\n    };\n\n    RTCSessionDescription = function (info) {\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n      return AdapterJS.WebRTCPlugin.plugin.\n        ConstructSessionDescription(info.type, info.sdp);\n    };\n\n    RTCPeerConnection = function (servers, constraints) {\n      var iceServers = null;\n      if (servers) {\n        iceServers = servers.iceServers;\n        for (var i = 0; i < iceServers.length; i++) {\n          if (iceServers[i].urls && !iceServers[i].url) {\n            iceServers[i].url = iceServers[i].urls;\n          }\n          iceServers[i].hasCredentials = AdapterJS.\n            isDefined(iceServers[i].username) &&\n            AdapterJS.isDefined(iceServers[i].credential);\n        }\n      }\n      var mandatory = (constraints && constraints.mandatory) ?\n        constraints.mandatory : null;\n      var optional = (constraints && constraints.optional) ?\n        constraints.optional : null;\n\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n      return AdapterJS.WebRTCPlugin.plugin.\n        PeerConnection(AdapterJS.WebRTCPlugin.pageId,\n        iceServers, mandatory, optional);\n    };\n\n    MediaStreamTrack = {};\n    MediaStreamTrack.getSources = function (callback) {\n      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n        AdapterJS.WebRTCPlugin.plugin.GetSources(callback);\n      });\n    };\n\n    getUserMedia = function (constraints, successCallback, failureCallback) {\n      if (!constraints.audio) {\n        constraints.audio = false;\n      }\n\n      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n        AdapterJS.WebRTCPlugin.plugin.\n          getUserMedia(constraints, successCallback, failureCallback);\n      });\n    };\n    navigator.getUserMedia = getUserMedia;\n\n    attachMediaStream = function (element, stream) {\n      stream.enableSoundTracks(true);\n      if (element.nodeName.toLowerCase() !== 'audio') {\n        var elementId = element.id.length === 0 ? Math.random().toString(36).slice(2) : element.id;\n        if (!element.isWebRTCPlugin || !element.isWebRTCPlugin()) {\n          var frag = document.createDocumentFragment();\n          var temp = document.createElement('div');\n          var classHTML = (element.className) ? 'class=\"' + element.className + '\" ' : '';\n          temp.innerHTML = '<object id=\"' + elementId + '\" ' + classHTML +\n            'type=\"' + AdapterJS.WebRTCPlugin.pluginInfo.type + '\">' +\n            '<param name=\"pluginId\" value=\"' + elementId + '\" /> ' +\n            '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n            '<param name=\"windowless\" value=\"true\" /> ' +\n            '<param name=\"streamId\" value=\"' + stream.id + '\" /> ' +\n            '</object>';\n          while (temp.firstChild) {\n            frag.appendChild(temp.firstChild);\n          }\n          var rectObject = element.getBoundingClientRect();\n          element.parentNode.insertBefore(frag, element);\n          frag = document.getElementById(elementId);\n          frag.width = rectObject.width + 'px';\n          frag.height = rectObject.height + 'px';\n          element.parentNode.removeChild(element);\n        } else {\n          var children = element.children;\n          for (var i = 0; i !== children.length; ++i) {\n            if (children[i].name === 'streamId') {\n              children[i].value = stream.id;\n              break;\n            }\n          }\n          element.setStreamId(stream.id);\n        }\n        var newElement = document.getElementById(elementId);\n        newElement.onplaying = (element.onplaying) ? element.onplaying : function (arg) {};\n        if (isIE) { // on IE the event needs to be plugged manually\n          newElement.attachEvent('onplaying', newElement.onplaying);\n          newElement.onclick = (element.onclick) ? element.onclick : function (arg) {};\n          newElement._TemOnClick = function (id) {\n            var arg = {\n              srcElement : document.getElementById(id)\n            };\n            newElement.onclick(arg);\n          };\n        }\n        return newElement;\n      } else {\n        return element;\n      }\n    };\n\n    reattachMediaStream = function (to, from) {\n      var stream = null;\n      var children = from.children;\n      for (var i = 0; i !== children.length; ++i) {\n        if (children[i].name === 'streamId') {\n          AdapterJS.WebRTCPlugin.WaitForPluginReady();\n          stream = AdapterJS.WebRTCPlugin.plugin\n            .getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);\n          break;\n        }\n      }\n      if (stream !== null) {\n        return attachMediaStream(to, stream);\n      } else {\n        console.log('Could not find the stream associated with this element');\n      }\n    };\n\n    RTCIceCandidate = function (candidate) {\n      if (!candidate.sdpMid) {\n        candidate.sdpMid = '';\n      }\n\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n      return AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(\n        candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate\n      );\n    };\n\n    // inject plugin\n    AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.injectPlugin);\n    AdapterJS.WebRTCPlugin.injectPlugin();\n  };\n\n  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = function() {\n    AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv);\n    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();\n  }\n\n  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function () {\n    if (AdapterJS.options.hidePluginInstallPrompt)\n      return;\n\n    var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;\n    if(downloadLink) { // if download link\n      var popupString;\n      if (AdapterJS.WebRTCPlugin.pluginInfo.portalLink) { // is portal link\n       popupString = 'This website requires you to install the ' +\n        ' <a href=\"' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink +\n        '\" target=\"_blank\">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName +\n        ' WebRTC Plugin</a>' +\n        ' to work on this browser.';\n      } else { // no portal link, just print a generic explanation\n       popupString = 'This website requires you to install a WebRTC-enabling plugin ' +\n        'to work on this browser.';\n      }\n\n      AdapterJS.WebRTCPlugin.renderNotificationBar(popupString, 'Install Now', downloadLink);\n    } else { // no download link, just print a generic explanation\n      AdapterJS.WebRTCPlugin.renderNotificationBar('Your browser does not support WebRTC.');\n    }\n  };\n\n  AdapterJS.WebRTCPlugin.renderNotificationBar = function (text, buttonText, buttonLink) {\n    // only inject once the page is ready\n    if (document.readyState !== 'complete')\n      return;\n\n    var w = window;\n    var i = document.createElement('iframe');\n    i.style.position = 'fixed';\n    i.style.top = '-41px';\n    i.style.left = 0;\n    i.style.right = 0;\n    i.style.width = '100%';\n    i.style.height = '40px';\n    i.style.backgroundColor = '#ffffe1';\n    i.style.border = 'none';\n    i.style.borderBottom = '1px solid #888888';\n    i.style.zIndex = '9999999';\n    if(typeof i.style.webkitTransition === 'string') {\n      i.style.webkitTransition = 'all .5s ease-out';\n    } else if(typeof i.style.transition === 'string') {\n      i.style.transition = 'all .5s ease-out';\n    }\n    document.body.appendChild(i);\n    c = (i.contentWindow) ? i.contentWindow :\n      (i.contentDocument.document) ? i.contentDocument.document : i.contentDocument;\n    c.document.open();\n    c.document.write('<span style=\"font-family: Helvetica, Arial,' +\n      'sans-serif; font-size: .9rem; padding: 7px; vertical-align: ' +\n      'middle; cursor: default;\">' + text + '</span>');\n    if(buttonText && buttonLink) {\n      c.document.write('<button id=\"okay\">' + buttonText + '</button><button>Cancel</button>');\n      c.document.close();\n      AdapterJS.addEvent(c.document.getElementById('okay'), 'click', function(e) {\n        window.open(buttonLink, '_top');\n        e.preventDefault();\n        try {\n          event.cancelBubble = true;\n        } catch(error) { }\n      });\n    }\n    else {\n      c.document.close();\n    }\n    AdapterJS.addEvent(c.document, 'click', function() {\n      w.document.body.removeChild(i);\n    });\n    setTimeout(function() {\n      if(typeof i.style.webkitTransform === 'string') {\n        i.style.webkitTransform = 'translateY(40px)';\n      } else if(typeof i.style.transform === 'string') {\n        i.style.transform = 'translateY(40px)';\n      } else {\n        i.style.top = '0px';\n      }\n    }, 300);\n  };\n  // Try to detect the plugin and act accordingly\n  AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName,\n    AdapterJS.WebRTCPlugin.defineWebRTCInterface,\n    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);\n}\n\n\nwindow.RTCPeerConnection = RTCPeerConnection;\nwindow.getUserMedia = getUserMedia;\nwindow.attachMediaStream = attachMediaStream;\nwindow.reattachMediaStream = reattachMediaStream;\nwindow.webrtcDetectedBrowser = webrtcDetectedBrowser;\nwindow.webrtcDetectedVersion = webrtcDetectedVersion;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/deps/adapter.js\n ** module id = 17\n ** module chunks = 0\n **/","/*\r\n * loglevel - https://github.com/pimterry/loglevel\r\n *\r\n * Copyright (c) 2013 Tim Perry\r\n * Licensed under the MIT license.\r\n */\r\n\r\n;(function (undefined) {\r\n    var undefinedType = \"undefined\";\r\n    \r\n    (function (name, definition) {\r\n        if (typeof module !== 'undefined') {\r\n            module.exports = definition();\r\n        } else if (typeof define === 'function' && typeof define.amd === 'object') {\r\n            define(definition);\r\n        } else {\r\n            this[name] = definition();\r\n        }\r\n    }('log', function () {\r\n        var self = {};\r\n        var noop = function() {};\r\n\r\n        function realMethod(methodName) {\r\n            if (typeof console === undefinedType) {\r\n                return noop;\r\n            } else if (console[methodName] === undefined) {\r\n                return boundToConsole(console, 'log') || noop;\r\n            } else {\r\n                return boundToConsole(console, methodName);\r\n            }\r\n        }\r\n\r\n        function boundToConsole(console, methodName) {\r\n            var method = console[methodName];\r\n            if (method.bind === undefined) {\r\n                if (Function.prototype.bind === undefined) {\r\n                    return function() {\r\n                        method.apply(console, arguments);\r\n                    };\r\n                } else {\r\n                    return Function.prototype.bind.call(console[methodName], console);\r\n                }\r\n            } else {\r\n                return console[methodName].bind(console);\r\n            }\r\n        }\r\n\r\n        var logMethods = [\r\n            \"trace\",\r\n            \"debug\",\r\n            \"info\",\r\n            \"warn\",\r\n            \"error\"\r\n        ];\r\n\r\n        function clearMethods() {\r\n            for (var ii = 0; ii < logMethods.length; ii++) {\r\n                self[logMethods[ii]] = noop;\r\n            }\r\n        }\r\n\r\n        function cookiesAvailable() {\r\n            return (typeof window !== undefinedType &&\r\n                    window.document !== undefined &&\r\n                    window.document.cookie !== undefined);\r\n        }\r\n\r\n        function setLevelInCookie(levelNum) {\r\n            if (!cookiesAvailable()) {\r\n                return;\r\n            }\r\n\r\n            var levelName;\r\n\r\n            for (var key in self.levels) {\r\n                if (self.levels.hasOwnProperty(key) && self.levels[key] === levelNum) {\r\n                    levelName = key;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (levelName !== undefined) {\r\n                window.document.cookie = \"loglevel=\" + levelName + \";\";\r\n            }\r\n        }\r\n\r\n        var cookieRegex = /loglevel=([^;]+)/;\r\n\r\n        function loadLevelFromCookie() {\r\n            var cookieLevel;\r\n\r\n            if (cookiesAvailable()) {\r\n                var cookieMatch = cookieRegex.exec(window.document.cookie) || [];\r\n                cookieLevel = cookieMatch[1];\r\n            }\r\n\r\n            self.setLevel(self.levels[cookieLevel] || self.levels.WARN);\r\n        }\r\n\r\n        /*\r\n         *\r\n         * Public API\r\n         *\r\n         */\r\n\r\n        self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n            \"ERROR\": 4, \"SILENT\": 5};\r\n\r\n        self.setLevel = function (level) {\r\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n                setLevelInCookie(level);\r\n\r\n                if (level === self.levels.SILENT) {\r\n                    clearMethods();\r\n                    return;\r\n                } else if (typeof console === undefinedType) {\r\n                    clearMethods();\r\n                    throw \"No console available for logging\";\r\n                } else {\r\n                    for (var ii = 0; ii < logMethods.length; ii++) {\r\n                        var methodName = logMethods[ii];\r\n\r\n                        if (level <= self.levels[methodName.toUpperCase()]) {\r\n                            self[methodName] = realMethod(methodName);\r\n                        } else {\r\n                            self[methodName] = noop;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (typeof level === \"string\") {\r\n                self.setLevel(self.levels[level.toUpperCase()]);\r\n            } else {\r\n                throw \"log.setLevel() called with invalid level: \" + level;\r\n            }\r\n        };\r\n\r\n        self.enableAll = function() {\r\n            self.setLevel(self.levels.TRACE);\r\n        };\r\n\r\n        self.disableAll = function() {\r\n            self.setLevel(self.levels.SILENT);\r\n        };\r\n\r\n        try {\r\n            loadLevelFromCookie();\r\n        } catch (e) {\r\n            self.setLevel(self.levels.SILENT);\r\n        }\r\n        return self;\r\n    }));\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/loglevel/lib/loglevel.js\n ** module id = 18\n ** module chunks = 0\n **/","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof self !== \"undefined\") {\n        self.Q = definition();\n\n    } else {\n        throw new Error(\"This environment was not anticiapted by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n\n    function flush() {\n        /* jshint loopfunc: true */\n\n        while (head.next) {\n            head = head.next;\n            var task = head.task;\n            head.task = void 0;\n            var domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n\n            try {\n                task();\n\n            } catch (e) {\n                if (isNodeJS) {\n                    // In node, uncaught exceptions are considered fatal errors.\n                    // Re-throw them synchronously to interrupt flushing!\n\n                    // Ensure continuation if the uncaught exception is suppressed\n                    // listening \"uncaughtException\" events (as domains does).\n                    // Continue in next event to avoid tick recursion.\n                    if (domain) {\n                        domain.exit();\n                    }\n                    setTimeout(flush, 0);\n                    if (domain) {\n                        domain.enter();\n                    }\n\n                    throw e;\n\n                } else {\n                    // In browsers, uncaught exceptions are not fatal.\n                    // Re-throw them asynchronously to avoid slow-downs.\n                    setTimeout(function() {\n                       throw e;\n                    }, 0);\n                }\n            }\n\n            if (domain) {\n                domain.exit();\n            }\n        }\n\n        flushing = false;\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process !== \"undefined\" && process.nextTick) {\n        // Node.js before 0.9. Note that some fake-Node environments, like the\n        // Mocha test runner, introduce a `process` global without a `nextTick`.\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function(resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function(answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var countDown = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++countDown;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--countDown === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (countDown === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/q/q.js\n ** module id = 19\n ** module chunks = 0\n **/","/*! Socket.IO.js build:0.9.17, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\n\nvar io = ('undefined' === typeof module ? {} : module.exports);\n(function() {\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * IO namespace.\n   *\n   * @namespace\n   */\n\n  var io = exports;\n\n  /**\n   * Socket.IO version\n   *\n   * @api public\n   */\n\n  io.version = '0.9.17';\n\n  /**\n   * Protocol implemented.\n   *\n   * @api public\n   */\n\n  io.protocol = 1;\n\n  /**\n   * Available transports, these will be populated with the available transports\n   *\n   * @api public\n   */\n\n  io.transports = [];\n\n  /**\n   * Keep track of jsonp callbacks.\n   *\n   * @api private\n   */\n\n  io.j = [];\n\n  /**\n   * Keep track of our io.Sockets\n   *\n   * @api private\n   */\n  io.sockets = {};\n\n\n  /**\n   * Manages connections to hosts.\n   *\n   * @param {String} uri\n   * @Param {Boolean} force creation of new socket (defaults to false)\n   * @api public\n   */\n\n  io.connect = function (host, details) {\n    var uri = io.util.parseUri(host)\n      , uuri\n      , socket;\n\n    if (global && global.location) {\n      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\n      uri.host = uri.host || (global.document\n        ? global.document.domain : global.location.hostname);\n      uri.port = uri.port || global.location.port;\n    }\n\n    uuri = io.util.uniqueUri(uri);\n\n    var options = {\n        host: uri.host\n      , secure: 'https' == uri.protocol\n      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\n      , query: uri.query || ''\n    };\n\n    io.util.merge(options, details);\n\n    if (options['force new connection'] || !io.sockets[uuri]) {\n      socket = new io.Socket(options);\n    }\n\n    if (!options['force new connection'] && socket) {\n      io.sockets[uuri] = socket;\n    }\n\n    socket = socket || io.sockets[uuri];\n\n    // if path is different from '' or /\n    return socket.of(uri.path.length > 1 ? uri.path : '');\n  };\n\n})('object' === typeof module ? module.exports : (this.io = {}), this);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * Utilities namespace.\n   *\n   * @namespace\n   */\n\n  var util = exports.util = {};\n\n  /**\n   * Parses an URI\n   *\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n   * @api public\n   */\n\n  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\n               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\n               'anchor'];\n\n  util.parseUri = function (str) {\n    var m = re.exec(str || '')\n      , uri = {}\n      , i = 14;\n\n    while (i--) {\n      uri[parts[i]] = m[i] || '';\n    }\n\n    return uri;\n  };\n\n  /**\n   * Produces a unique url that identifies a Socket.IO connection.\n   *\n   * @param {Object} uri\n   * @api public\n   */\n\n  util.uniqueUri = function (uri) {\n    var protocol = uri.protocol\n      , host = uri.host\n      , port = uri.port;\n\n    if ('document' in global) {\n      host = host || document.domain;\n      port = port || (protocol == 'https'\n        && document.location.protocol !== 'https:' ? 443 : document.location.port);\n    } else {\n      host = host || 'localhost';\n\n      if (!port && protocol == 'https') {\n        port = 443;\n      }\n    }\n\n    return (protocol || 'http') + '://' + host + ':' + (port || 80);\n  };\n\n  /**\n   * Mergest 2 query strings in to once unique query string\n   *\n   * @param {String} base\n   * @param {String} addition\n   * @api public\n   */\n\n  util.query = function (base, addition) {\n    var query = util.chunkQuery(base || '')\n      , components = [];\n\n    util.merge(query, util.chunkQuery(addition || ''));\n    for (var part in query) {\n      if (query.hasOwnProperty(part)) {\n        components.push(part + '=' + query[part]);\n      }\n    }\n\n    return components.length ? '?' + components.join('&') : '';\n  };\n\n  /**\n   * Transforms a querystring in to an object\n   *\n   * @param {String} qs\n   * @api public\n   */\n\n  util.chunkQuery = function (qs) {\n    var query = {}\n      , params = qs.split('&')\n      , i = 0\n      , l = params.length\n      , kv;\n\n    for (; i < l; ++i) {\n      kv = params[i].split('=');\n      if (kv[0]) {\n        query[kv[0]] = kv[1];\n      }\n    }\n\n    return query;\n  };\n\n  /**\n   * Executes the given function when the page is loaded.\n   *\n   *     io.util.load(function () { console.log('page loaded'); });\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  var pageLoaded = false;\n\n  util.load = function (fn) {\n    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\n      return fn();\n    }\n\n    util.on(global, 'load', fn, false);\n  };\n\n  /**\n   * Adds an event.\n   *\n   * @api private\n   */\n\n  util.on = function (element, event, fn, capture) {\n    if (element.attachEvent) {\n      element.attachEvent('on' + event, fn);\n    } else if (element.addEventListener) {\n      element.addEventListener(event, fn, capture);\n    }\n  };\n\n  /**\n   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\n   *\n   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\n   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\n   * @api private\n   */\n\n  util.request = function (xdomain) {\n\n    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {\n      return new XDomainRequest();\n    }\n\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\n      return new XMLHttpRequest();\n    }\n\n    if (!xdomain) {\n      try {\n        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');\n      } catch(e) { }\n    }\n\n    return null;\n  };\n\n  /**\n   * XHR based transport constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  /**\n   * Change the internal pageLoaded value.\n   */\n\n  if ('undefined' != typeof window) {\n    util.load(function () {\n      pageLoaded = true;\n    });\n  }\n\n  /**\n   * Defers a function to ensure a spinner is not displayed by the browser\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  util.defer = function (fn) {\n    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\n      return fn();\n    }\n\n    util.load(function () {\n      setTimeout(fn, 100);\n    });\n  };\n\n  /**\n   * Merges two objects.\n   *\n   * @api public\n   */\n\n  util.merge = function merge (target, additional, deep, lastseen) {\n    var seen = lastseen || []\n      , depth = typeof deep == 'undefined' ? 2 : deep\n      , prop;\n\n    for (prop in additional) {\n      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\n        if (typeof target[prop] !== 'object' || !depth) {\n          target[prop] = additional[prop];\n          seen.push(additional[prop]);\n        } else {\n          util.merge(target[prop], additional[prop], depth - 1, seen);\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\n   * Merges prototypes from objects\n   *\n   * @api public\n   */\n\n  util.mixin = function (ctor, ctor2) {\n    util.merge(ctor.prototype, ctor2.prototype);\n  };\n\n  /**\n   * Shortcut for prototypical and static inheritance.\n   *\n   * @api private\n   */\n\n  util.inherit = function (ctor, ctor2) {\n    function f() {};\n    f.prototype = ctor2.prototype;\n    ctor.prototype = new f;\n  };\n\n  /**\n   * Checks if the given object is an Array.\n   *\n   *     io.util.isArray([]); // true\n   *     io.util.isArray({}); // false\n   *\n   * @param Object obj\n   * @api public\n   */\n\n  util.isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  /**\n   * Intersects values of two arrays into a third\n   *\n   * @api public\n   */\n\n  util.intersect = function (arr, arr2) {\n    var ret = []\n      , longest = arr.length > arr2.length ? arr : arr2\n      , shortest = arr.length > arr2.length ? arr2 : arr;\n\n    for (var i = 0, l = shortest.length; i < l; i++) {\n      if (~util.indexOf(longest, shortest[i]))\n        ret.push(shortest[i]);\n    }\n\n    return ret;\n  };\n\n  /**\n   * Array indexOf compatibility.\n   *\n   * @see bit.ly/a5Dxa2\n   * @api public\n   */\n\n  util.indexOf = function (arr, o, i) {\n\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;\n         i < j && arr[i] !== o; i++) {}\n\n    return j <= i ? -1 : i;\n  };\n\n  /**\n   * Converts enumerables to array.\n   *\n   * @api public\n   */\n\n  util.toArray = function (enu) {\n    var arr = [];\n\n    for (var i = 0, l = enu.length; i < l; i++)\n      arr.push(enu[i]);\n\n    return arr;\n  };\n\n  /**\n   * UA / engines detection namespace.\n   *\n   * @namespace\n   */\n\n  util.ua = {};\n\n  /**\n   * Whether the UA supports CORS for XHR.\n   *\n   * @api public\n   */\n\n  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\n    try {\n      var a = new XMLHttpRequest();\n    } catch (e) {\n      return false;\n    }\n\n    return a.withCredentials != undefined;\n  })();\n\n  /**\n   * Detect webkit.\n   *\n   * @api public\n   */\n\n  util.ua.webkit = 'undefined' != typeof navigator\n    && /webkit/i.test(navigator.userAgent);\n\n   /**\n   * Detect iPad/iPhone/iPod.\n   *\n   * @api public\n   */\n\n  util.ua.iDevice = 'undefined' != typeof navigator\n      && /iPad|iPhone|iPod/i.test(navigator.userAgent);\n\n})('undefined' != typeof io ? io : module.exports, this);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.EventEmitter = EventEmitter;\n\n  /**\n   * Event emitter constructor.\n   *\n   * @api public.\n   */\n\n  function EventEmitter () {};\n\n  /**\n   * Adds a listener\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.on = function (name, fn) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = fn;\n    } else if (io.util.isArray(this.$events[name])) {\n      this.$events[name].push(fn);\n    } else {\n      this.$events[name] = [this.$events[name], fn];\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  /**\n   * Adds a volatile listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.once = function (name, fn) {\n    var self = this;\n\n    function on () {\n      self.removeListener(name, on);\n      fn.apply(this, arguments);\n    };\n\n    on.listener = fn;\n    this.on(name, on);\n\n    return this;\n  };\n\n  /**\n   * Removes a listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeListener = function (name, fn) {\n    if (this.$events && this.$events[name]) {\n      var list = this.$events[name];\n\n      if (io.util.isArray(list)) {\n        var pos = -1;\n\n        for (var i = 0, l = list.length; i < l; i++) {\n          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n            pos = i;\n            break;\n          }\n        }\n\n        if (pos < 0) {\n          return this;\n        }\n\n        list.splice(pos, 1);\n\n        if (!list.length) {\n          delete this.$events[name];\n        }\n      } else if (list === fn || (list.listener && list.listener === fn)) {\n        delete this.$events[name];\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Removes all listeners for an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeAllListeners = function (name) {\n    if (name === undefined) {\n      this.$events = {};\n      return this;\n    }\n\n    if (this.$events && this.$events[name]) {\n      this.$events[name] = null;\n    }\n\n    return this;\n  };\n\n  /**\n   * Gets all listeners for a certain event.\n   *\n   * @api publci\n   */\n\n  EventEmitter.prototype.listeners = function (name) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = [];\n    }\n\n    if (!io.util.isArray(this.$events[name])) {\n      this.$events[name] = [this.$events[name]];\n    }\n\n    return this.$events[name];\n  };\n\n  /**\n   * Emits an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.emit = function (name) {\n    if (!this.$events) {\n      return false;\n    }\n\n    var handler = this.$events[name];\n\n    if (!handler) {\n      return false;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if ('function' == typeof handler) {\n      handler.apply(this, args);\n    } else if (io.util.isArray(handler)) {\n      var listeners = handler.slice();\n\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].apply(this, args);\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Based on JSON2 (http://www.JSON.org/js.html).\n */\n\n(function (exports, nativeJSON) {\n  \"use strict\";\n\n  // use native JSON if it's available\n  if (nativeJSON && nativeJSON.parse){\n    return exports.JSON = {\n      parse: nativeJSON.parse\n    , stringify: nativeJSON.stringify\n    };\n  }\n\n  var JSON = exports.JSON = {};\n\n  function f(n) {\n      // Format integers to have at least two digits.\n      return n < 10 ? '0' + n : n;\n  }\n\n  function date(d, key) {\n    return isFinite(d.valueOf()) ?\n        d.getUTCFullYear()     + '-' +\n        f(d.getUTCMonth() + 1) + '-' +\n        f(d.getUTCDate())      + 'T' +\n        f(d.getUTCHours())     + ':' +\n        f(d.getUTCMinutes())   + ':' +\n        f(d.getUTCSeconds())   + 'Z' : null;\n  };\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      gap,\n      indent,\n      meta = {    // table of character substitutions\n          '\\b': '\\\\b',\n          '\\t': '\\\\t',\n          '\\n': '\\\\n',\n          '\\f': '\\\\f',\n          '\\r': '\\\\r',\n          '\"' : '\\\\\"',\n          '\\\\': '\\\\\\\\'\n      },\n      rep;\n\n\n  function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n      escapable.lastIndex = 0;\n      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n          var c = meta[a];\n          return typeof c === 'string' ? c :\n              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + string + '\"';\n  }\n\n\n  function str(key, holder) {\n\n// Produce a string from holder[key].\n\n      var i,          // The loop counter.\n          k,          // The member key.\n          v,          // The member value.\n          length,\n          mind = gap,\n          partial,\n          value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n      if (value instanceof Date) {\n          value = date(key);\n      }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n      if (typeof rep === 'function') {\n          value = rep.call(holder, key, value);\n      }\n\n// What happens next depends on the value's type.\n\n      switch (typeof value) {\n      case 'string':\n          return quote(value);\n\n      case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n          return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n      case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n          return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n      case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n          if (!value) {\n              return 'null';\n          }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n          gap += indent;\n          partial = [];\n\n// Is the value an array?\n\n          if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n              length = value.length;\n              for (i = 0; i < length; i += 1) {\n                  partial[i] = str(i, value) || 'null';\n              }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n              v = partial.length === 0 ? '[]' : gap ?\n                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                  '[' + partial.join(',') + ']';\n              gap = mind;\n              return v;\n          }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n          if (rep && typeof rep === 'object') {\n              length = rep.length;\n              for (i = 0; i < length; i += 1) {\n                  if (typeof rep[i] === 'string') {\n                      k = rep[i];\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n          v = partial.length === 0 ? '{}' : gap ?\n              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n              '{' + partial.join(',') + '}';\n          gap = mind;\n          return v;\n      }\n  }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n  JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n      var i;\n      gap = '';\n      indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n      if (typeof space === 'number') {\n          for (i = 0; i < space; i += 1) {\n              indent += ' ';\n          }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n      } else if (typeof space === 'string') {\n          indent = space;\n      }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n      rep = replacer;\n      if (replacer && typeof replacer !== 'function' &&\n              (typeof replacer !== 'object' ||\n              typeof replacer.length !== 'number')) {\n          throw new Error('JSON.stringify');\n      }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n      return str('', {'': value});\n  };\n\n// If the JSON object does not yet have a parse method, give it one.\n\n  JSON.parse = function (text, reviver) {\n  // The parse method takes a text and an optional reviver function, and returns\n  // a JavaScript value if the text is a valid JSON text.\n\n      var j;\n\n      function walk(holder, key) {\n\n  // The walk method is used to recursively walk the resulting structure so\n  // that modifications can be made.\n\n          var k, v, value = holder[key];\n          if (value && typeof value === 'object') {\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = walk(value, k);\n                      if (v !== undefined) {\n                          value[k] = v;\n                      } else {\n                          delete value[k];\n                      }\n                  }\n              }\n          }\n          return reviver.call(holder, key, value);\n      }\n\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n\n      text = String(text);\n      cx.lastIndex = 0;\n      if (cx.test(text)) {\n          text = text.replace(cx, function (a) {\n              return '\\\\u' +\n                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          });\n      }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n      if (/^[\\],:{}\\s]*$/\n              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n  // In the third stage we use the eval function to compile the text into a\n  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n  // in JavaScript: it can begin a block or an object literal. We wrap the text\n  // in parens to eliminate the ambiguity.\n\n          j = eval('(' + text + ')');\n\n  // In the optional fourth stage, we recursively walk the new structure, passing\n  // each name/value pair to a reviver function for possible transformation.\n\n          return typeof reviver === 'function' ?\n              walk({'': j}, '') : j;\n      }\n\n  // If the text is not JSON parseable, then a SyntaxError is thrown.\n\n      throw new SyntaxError('JSON.parse');\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , typeof JSON !== 'undefined' ? JSON : undefined\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Parser namespace.\n   *\n   * @namespace\n   */\n\n  var parser = exports.parser = {};\n\n  /**\n   * Packet types.\n   */\n\n  var packets = parser.packets = [\n      'disconnect'\n    , 'connect'\n    , 'heartbeat'\n    , 'message'\n    , 'json'\n    , 'event'\n    , 'ack'\n    , 'error'\n    , 'noop'\n  ];\n\n  /**\n   * Errors reasons.\n   */\n\n  var reasons = parser.reasons = [\n      'transport not supported'\n    , 'client not handshaken'\n    , 'unauthorized'\n  ];\n\n  /**\n   * Errors advice.\n   */\n\n  var advice = parser.advice = [\n      'reconnect'\n  ];\n\n  /**\n   * Shortcuts.\n   */\n\n  var JSON = io.JSON\n    , indexOf = io.util.indexOf;\n\n  /**\n   * Encodes a packet.\n   *\n   * @api private\n   */\n\n  parser.encodePacket = function (packet) {\n    var type = indexOf(packets, packet.type)\n      , id = packet.id || ''\n      , endpoint = packet.endpoint || ''\n      , ack = packet.ack\n      , data = null;\n\n    switch (packet.type) {\n      case 'error':\n        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\n          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\n\n        if (reason !== '' || adv !== '')\n          data = reason + (adv !== '' ? ('+' + adv) : '');\n\n        break;\n\n      case 'message':\n        if (packet.data !== '')\n          data = packet.data;\n        break;\n\n      case 'event':\n        var ev = { name: packet.name };\n\n        if (packet.args && packet.args.length) {\n          ev.args = packet.args;\n        }\n\n        data = JSON.stringify(ev);\n        break;\n\n      case 'json':\n        data = JSON.stringify(packet.data);\n        break;\n\n      case 'connect':\n        if (packet.qs)\n          data = packet.qs;\n        break;\n\n      case 'ack':\n        data = packet.ackId\n          + (packet.args && packet.args.length\n              ? '+' + JSON.stringify(packet.args) : '');\n        break;\n    }\n\n    // construct packet with required fragments\n    var encoded = [\n        type\n      , id + (ack == 'data' ? '+' : '')\n      , endpoint\n    ];\n\n    // data fragment is optional\n    if (data !== null && data !== undefined)\n      encoded.push(data);\n\n    return encoded.join(':');\n  };\n\n  /**\n   * Encodes multiple messages (payload).\n   *\n   * @param {Array} messages\n   * @api private\n   */\n\n  parser.encodePayload = function (packets) {\n    var decoded = '';\n\n    if (packets.length == 1)\n      return packets[0];\n\n    for (var i = 0, l = packets.length; i < l; i++) {\n      var packet = packets[i];\n      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\n    }\n\n    return decoded;\n  };\n\n  /**\n   * Decodes a packet\n   *\n   * @api private\n   */\n\n  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\n\n  parser.decodePacket = function (data) {\n    var pieces = data.match(regexp);\n\n    if (!pieces) return {};\n\n    var id = pieces[2] || ''\n      , data = pieces[5] || ''\n      , packet = {\n            type: packets[pieces[1]]\n          , endpoint: pieces[4] || ''\n        };\n\n    // whether we need to acknowledge the packet\n    if (id) {\n      packet.id = id;\n      if (pieces[3])\n        packet.ack = 'data';\n      else\n        packet.ack = true;\n    }\n\n    // handle different packet types\n    switch (packet.type) {\n      case 'error':\n        var pieces = data.split('+');\n        packet.reason = reasons[pieces[0]] || '';\n        packet.advice = advice[pieces[1]] || '';\n        break;\n\n      case 'message':\n        packet.data = data || '';\n        break;\n\n      case 'event':\n        try {\n          var opts = JSON.parse(data);\n          packet.name = opts.name;\n          packet.args = opts.args;\n        } catch (e) { }\n\n        packet.args = packet.args || [];\n        break;\n\n      case 'json':\n        try {\n          packet.data = JSON.parse(data);\n        } catch (e) { }\n        break;\n\n      case 'connect':\n        packet.qs = data || '';\n        break;\n\n      case 'ack':\n        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\n        if (pieces) {\n          packet.ackId = pieces[1];\n          packet.args = [];\n\n          if (pieces[3]) {\n            try {\n              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\n            } catch (e) { }\n          }\n        }\n        break;\n\n      case 'disconnect':\n      case 'heartbeat':\n        break;\n    };\n\n    return packet;\n  };\n\n  /**\n   * Decodes data payload. Detects multiple messages\n   *\n   * @return {Array} messages\n   * @api public\n   */\n\n  parser.decodePayload = function (data) {\n    // IE doesn't like data[i] for unicode chars, charAt works fine\n    if (data.charAt(0) == '\\ufffd') {\n      var ret = [];\n\n      for (var i = 1, length = ''; i < data.length; i++) {\n        if (data.charAt(i) == '\\ufffd') {\n          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\n          i += Number(length) + 1;\n          length = '';\n        } else {\n          length += data.charAt(i);\n        }\n      }\n\n      return ret;\n    } else {\n      return [parser.decodePacket(data)];\n    }\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Transport = Transport;\n\n  /**\n   * This is the transport template for all supported transport methods.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function Transport (socket, sessid) {\n    this.socket = socket;\n    this.sessid = sessid;\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Transport, io.EventEmitter);\n\n\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  Transport.prototype.heartbeats = function () {\n    return true;\n  };\n\n  /**\n   * Handles the response from the server. When a new response is received\n   * it will automatically update the timeout, decode the message and\n   * forwards the response to the onMessage function for further processing.\n   *\n   * @param {String} data Response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onData = function (data) {\n    this.clearCloseTimeout();\n\n    // If the connection in currently open (or in a reopening state) reset the close\n    // timeout since we have just received data. This check is necessary so\n    // that we don't reset the timeout on an explicitly disconnected connection.\n    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\n      this.setCloseTimeout();\n    }\n\n    if (data !== '') {\n      // todo: we should only do decodePayload for xhr transports\n      var msgs = io.parser.decodePayload(data);\n\n      if (msgs && msgs.length) {\n        for (var i = 0, l = msgs.length; i < l; i++) {\n          this.onPacket(msgs[i]);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles packets.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onPacket = function (packet) {\n    this.socket.setHeartbeatTimeout();\n\n    if (packet.type == 'heartbeat') {\n      return this.onHeartbeat();\n    }\n\n    if (packet.type == 'connect' && packet.endpoint == '') {\n      this.onConnect();\n    }\n\n    if (packet.type == 'error' && packet.advice == 'reconnect') {\n      this.isOpen = false;\n    }\n\n    this.socket.onPacket(packet);\n\n    return this;\n  };\n\n  /**\n   * Sets close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.setCloseTimeout = function () {\n    if (!this.closeTimeout) {\n      var self = this;\n\n      this.closeTimeout = setTimeout(function () {\n        self.onDisconnect();\n      }, this.socket.closeTimeout);\n    }\n  };\n\n  /**\n   * Called when transport disconnects.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onDisconnect = function () {\n    if (this.isOpen) this.close();\n    this.clearTimeouts();\n    this.socket.onDisconnect();\n    return this;\n  };\n\n  /**\n   * Called when transport connects\n   *\n   * @api private\n   */\n\n  Transport.prototype.onConnect = function () {\n    this.socket.onConnect();\n    return this;\n  };\n\n  /**\n   * Clears close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearCloseTimeout = function () {\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = null;\n    }\n  };\n\n  /**\n   * Clear timeouts\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearTimeouts = function () {\n    this.clearCloseTimeout();\n\n    if (this.reopenTimeout) {\n      clearTimeout(this.reopenTimeout);\n    }\n  };\n\n  /**\n   * Sends a packet\n   *\n   * @param {Object} packet object.\n   * @api private\n   */\n\n  Transport.prototype.packet = function (packet) {\n    this.send(io.parser.encodePacket(packet));\n  };\n\n  /**\n   * Send the received heartbeat message back to server. So the server\n   * knows we are still connected.\n   *\n   * @param {String} heartbeat Heartbeat response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onHeartbeat = function (heartbeat) {\n    this.packet({ type: 'heartbeat' });\n  };\n\n  /**\n   * Called when the transport opens.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onOpen = function () {\n    this.isOpen = true;\n    this.clearCloseTimeout();\n    this.socket.onOpen();\n  };\n\n  /**\n   * Notifies the base when the connection with the Socket.IO server\n   * has been disconnected.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onClose = function () {\n    var self = this;\n\n    /* FIXME: reopen delay causing a infinit loop\n    this.reopenTimeout = setTimeout(function () {\n      self.open();\n    }, this.socket.options['reopen delay']);*/\n\n    this.isOpen = false;\n    this.socket.onClose();\n    this.onDisconnect();\n  };\n\n  /**\n   * Generates a connection url based on the Socket.IO URL Protocol.\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\n   *\n   * @returns {String} Connection url\n   * @api private\n   */\n\n  Transport.prototype.prepareUrl = function () {\n    var options = this.socket.options;\n\n    return this.scheme() + '://'\n      + options.host + ':' + options.port + '/'\n      + options.resource + '/' + io.protocol\n      + '/' + this.name + '/' + this.sessid;\n  };\n\n  /**\n   * Checks if the transport is ready to start a connection.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Transport.prototype.ready = function (socket, fn) {\n    fn.call(this);\n  };\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Socket = Socket;\n\n  /**\n   * Create a new `Socket.IO client` which can establish a persistent\n   * connection with a Socket.IO enabled server.\n   *\n   * @api public\n   */\n\n  function Socket (options) {\n    this.options = {\n        port: 80\n      , secure: false\n      , document: 'document' in global ? document : false\n      , resource: 'socket.io'\n      , transports: io.transports\n      , 'connect timeout': 10000\n      , 'try multiple transports': true\n      , 'reconnect': true\n      , 'reconnection delay': 500\n      , 'reconnection limit': Infinity\n      , 'reopen delay': 3000\n      , 'max reconnection attempts': 10\n      , 'sync disconnect on unload': false\n      , 'auto connect': true\n      , 'flash policy port': 10843\n      , 'manualFlush': false\n    };\n\n    io.util.merge(this.options, options);\n\n    this.connected = false;\n    this.open = false;\n    this.connecting = false;\n    this.reconnecting = false;\n    this.namespaces = {};\n    this.buffer = [];\n    this.doBuffer = false;\n\n    if (this.options['sync disconnect on unload'] &&\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\n      var self = this;\n      io.util.on(global, 'beforeunload', function () {\n        self.disconnectSync();\n      }, false);\n    }\n\n    if (this.options['auto connect']) {\n      this.connect();\n    }\n};\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Socket, io.EventEmitter);\n\n  /**\n   * Returns a namespace listener/emitter for this socket\n   *\n   * @api public\n   */\n\n  Socket.prototype.of = function (name) {\n    if (!this.namespaces[name]) {\n      this.namespaces[name] = new io.SocketNamespace(this, name);\n\n      if (name !== '') {\n        this.namespaces[name].packet({ type: 'connect' });\n      }\n    }\n\n    return this.namespaces[name];\n  };\n\n  /**\n   * Emits the given event to the Socket and all namespaces\n   *\n   * @api private\n   */\n\n  Socket.prototype.publish = function () {\n    this.emit.apply(this, arguments);\n\n    var nsp;\n\n    for (var i in this.namespaces) {\n      if (this.namespaces.hasOwnProperty(i)) {\n        nsp = this.of(i);\n        nsp.$emit.apply(nsp, arguments);\n      }\n    }\n  };\n\n  /**\n   * Performs the handshake\n   *\n   * @api private\n   */\n\n  function empty () { };\n\n  Socket.prototype.handshake = function (fn) {\n    var self = this\n      , options = this.options;\n\n    function complete (data) {\n      if (data instanceof Error) {\n        self.connecting = false;\n        self.onError(data.message);\n      } else {\n        fn.apply(null, data.split(':'));\n      }\n    };\n\n    var url = [\n          'http' + (options.secure ? 's' : '') + ':/'\n        , options.host + ':' + options.port\n        , options.resource\n        , io.protocol\n        , io.util.query(this.options.query, 't=' + +new Date)\n      ].join('/');\n\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\n      var insertAt = document.getElementsByTagName('script')[0]\n        , script = document.createElement('script');\n\n      script.src = url + '&jsonp=' + io.j.length;\n      insertAt.parentNode.insertBefore(script, insertAt);\n\n      io.j.push(function (data) {\n        complete(data);\n        script.parentNode.removeChild(script);\n      });\n    } else {\n      var xhr = io.util.request();\n\n      xhr.open('GET', url, true);\n      if (this.isXDomain()) {\n        xhr.withCredentials = true;\n      }\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          xhr.onreadystatechange = empty;\n\n          if (xhr.status == 200) {\n            complete(xhr.responseText);\n          } else if (xhr.status == 403) {\n            self.onError(xhr.responseText);\n          } else {\n            self.connecting = false;            \n            !self.reconnecting && self.onError(xhr.responseText);\n          }\n        }\n      };\n      xhr.send(null);\n    }\n  };\n\n  /**\n   * Find an available transport based on the options supplied in the constructor.\n   *\n   * @api private\n   */\n\n  Socket.prototype.getTransport = function (override) {\n    var transports = override || this.transports, match;\n\n    for (var i = 0, transport; transport = transports[i]; i++) {\n      if (io.Transport[transport]\n        && io.Transport[transport].check(this)\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {\n        return new io.Transport[transport](this, this.sessionid);\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Connects to the server.\n   *\n   * @param {Function} [fn] Callback.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.connect = function (fn) {\n    if (this.connecting) {\n      return this;\n    }\n\n    var self = this;\n    self.connecting = true;\n    \n    this.handshake(function (sid, heartbeat, close, transports) {\n      self.sessionid = sid;\n      self.closeTimeout = close * 1000;\n      self.heartbeatTimeout = heartbeat * 1000;\n      if(!self.transports)\n          self.transports = self.origTransports = (transports ? io.util.intersect(\n              transports.split(',')\n            , self.options.transports\n          ) : self.options.transports);\n\n      self.setHeartbeatTimeout();\n\n      function connect (transports){\n        if (self.transport) self.transport.clearTimeouts();\n\n        self.transport = self.getTransport(transports);\n        if (!self.transport) return self.publish('connect_failed');\n\n        // once the transport is ready\n        self.transport.ready(self, function () {\n          self.connecting = true;\n          self.publish('connecting', self.transport.name);\n          self.transport.open();\n\n          if (self.options['connect timeout']) {\n            self.connectTimeoutTimer = setTimeout(function () {\n              if (!self.connected) {\n                self.connecting = false;\n\n                if (self.options['try multiple transports']) {\n                  var remaining = self.transports;\n\n                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\n                         self.transport.name) {}\n\n                    if (remaining.length){\n                      connect(remaining);\n                    } else {\n                      self.publish('connect_failed');\n                    }\n                }\n              }\n            }, self.options['connect timeout']);\n          }\n        });\n      }\n\n      connect(self.transports);\n\n      self.once('connect', function (){\n        clearTimeout(self.connectTimeoutTimer);\n\n        fn && typeof fn == 'function' && fn();\n      });\n    });\n\n    return this;\n  };\n\n  /**\n   * Clears and sets a new heartbeat timeout using the value given by the\n   * server during the handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.setHeartbeatTimeout = function () {\n    clearTimeout(this.heartbeatTimeoutTimer);\n    if(this.transport && !this.transport.heartbeats()) return;\n\n    var self = this;\n    this.heartbeatTimeoutTimer = setTimeout(function () {\n      self.transport.onClose();\n    }, this.heartbeatTimeout);\n  };\n\n  /**\n   * Sends a message.\n   *\n   * @param {Object} data packet.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.packet = function (data) {\n    if (this.connected && !this.doBuffer) {\n      this.transport.packet(data);\n    } else {\n      this.buffer.push(data);\n    }\n\n    return this;\n  };\n\n  /**\n   * Sets buffer state\n   *\n   * @api private\n   */\n\n  Socket.prototype.setBuffer = function (v) {\n    this.doBuffer = v;\n\n    if (!v && this.connected && this.buffer.length) {\n      if (!this.options['manualFlush']) {\n        this.flushBuffer();\n      }\n    }\n  };\n\n  /**\n   * Flushes the buffer data over the wire.\n   * To be invoked manually when 'manualFlush' is set to true.\n   *\n   * @api public\n   */\n\n  Socket.prototype.flushBuffer = function() {\n    this.transport.payload(this.buffer);\n    this.buffer = [];\n  };\n  \n\n  /**\n   * Disconnect the established connect.\n   *\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.disconnect = function () {\n    if (this.connected || this.connecting) {\n      if (this.open) {\n        this.of('').packet({ type: 'disconnect' });\n      }\n\n      // handle disconnection immediately\n      this.onDisconnect('booted');\n    }\n\n    return this;\n  };\n\n  /**\n   * Disconnects the socket with a sync XHR.\n   *\n   * @api private\n   */\n\n  Socket.prototype.disconnectSync = function () {\n    // ensure disconnection\n    var xhr = io.util.request();\n    var uri = [\n        'http' + (this.options.secure ? 's' : '') + ':/'\n      , this.options.host + ':' + this.options.port\n      , this.options.resource\n      , io.protocol\n      , ''\n      , this.sessionid\n    ].join('/') + '/?disconnect=1';\n\n    xhr.open('GET', uri, false);\n    xhr.send(null);\n\n    // handle disconnection immediately\n    this.onDisconnect('booted');\n  };\n\n  /**\n   * Check if we need to use cross domain enabled transports. Cross domain would\n   * be a different port or different domain name.\n   *\n   * @returns {Boolean}\n   * @api private\n   */\n\n  Socket.prototype.isXDomain = function () {\n\n    var port = global.location.port ||\n      ('https:' == global.location.protocol ? 443 : 80);\n\n    return this.options.host !== global.location.hostname \n      || this.options.port != port;\n  };\n\n  /**\n   * Called upon handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onConnect = function () {\n    if (!this.connected) {\n      this.connected = true;\n      this.connecting = false;\n      if (!this.doBuffer) {\n        // make sure to flush the buffer\n        this.setBuffer(false);\n      }\n      this.emit('connect');\n    }\n  };\n\n  /**\n   * Called when the transport opens\n   *\n   * @api private\n   */\n\n  Socket.prototype.onOpen = function () {\n    this.open = true;\n  };\n\n  /**\n   * Called when the transport closes.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onClose = function () {\n    this.open = false;\n    clearTimeout(this.heartbeatTimeoutTimer);\n  };\n\n  /**\n   * Called when the transport first opens a connection\n   *\n   * @param text\n   */\n\n  Socket.prototype.onPacket = function (packet) {\n    this.of(packet.endpoint).onPacket(packet);\n  };\n\n  /**\n   * Handles an error.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onError = function (err) {\n    if (err && err.advice) {\n      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\n        this.disconnect();\n        if (this.options.reconnect) {\n          this.reconnect();\n        }\n      }\n    }\n\n    this.publish('error', err && err.reason ? err.reason : err);\n  };\n\n  /**\n   * Called when the transport disconnects.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onDisconnect = function (reason) {\n    var wasConnected = this.connected\n      , wasConnecting = this.connecting;\n\n    this.connected = false;\n    this.connecting = false;\n    this.open = false;\n\n    if (wasConnected || wasConnecting) {\n      this.transport.close();\n      this.transport.clearTimeouts();\n      if (wasConnected) {\n        this.publish('disconnect', reason);\n\n        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n          this.reconnect();\n        }\n      }\n    }\n  };\n\n  /**\n   * Called upon reconnection.\n   *\n   * @api private\n   */\n\n  Socket.prototype.reconnect = function () {\n    this.reconnecting = true;\n    this.reconnectionAttempts = 0;\n    this.reconnectionDelay = this.options['reconnection delay'];\n\n    var self = this\n      , maxAttempts = this.options['max reconnection attempts']\n      , tryMultiple = this.options['try multiple transports']\n      , limit = this.options['reconnection limit'];\n\n    function reset () {\n      if (self.connected) {\n        for (var i in self.namespaces) {\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n              self.namespaces[i].packet({ type: 'connect' });\n          }\n        }\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n      }\n\n      clearTimeout(self.reconnectionTimer);\n\n      self.removeListener('connect_failed', maybeReconnect);\n      self.removeListener('connect', maybeReconnect);\n\n      self.reconnecting = false;\n\n      delete self.reconnectionAttempts;\n      delete self.reconnectionDelay;\n      delete self.reconnectionTimer;\n      delete self.redoTransports;\n\n      self.options['try multiple transports'] = tryMultiple;\n    };\n\n    function maybeReconnect () {\n      if (!self.reconnecting) {\n        return;\n      }\n\n      if (self.connected) {\n        return reset();\n      };\n\n      if (self.connecting && self.reconnecting) {\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n      }\n\n      if (self.reconnectionAttempts++ >= maxAttempts) {\n        if (!self.redoTransports) {\n          self.on('connect_failed', maybeReconnect);\n          self.options['try multiple transports'] = true;\n          self.transports = self.origTransports;\n          self.transport = self.getTransport();\n          self.redoTransports = true;\n          self.connect();\n        } else {\n          self.publish('reconnect_failed');\n          reset();\n        }\n      } else {\n        if (self.reconnectionDelay < limit) {\n          self.reconnectionDelay *= 2; // exponential back off\n        }\n\n        self.connect();\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n      }\n    };\n\n    this.options['try multiple transports'] = false;\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n\n    this.on('connect', maybeReconnect);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.SocketNamespace = SocketNamespace;\n\n  /**\n   * Socket namespace constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function SocketNamespace (socket, name) {\n    this.socket = socket;\n    this.name = name || '';\n    this.flags = {};\n    this.json = new Flag(this, 'json');\n    this.ackPackets = 0;\n    this.acks = {};\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(SocketNamespace, io.EventEmitter);\n\n  /**\n   * Copies emit since we override it\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\n\n  /**\n   * Creates a new namespace, by proxying the request to the socket. This\n   * allows us to use the synax as we do on the server.\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.of = function () {\n    return this.socket.of.apply(this.socket, arguments);\n  };\n\n  /**\n   * Sends a packet.\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.packet = function (packet) {\n    packet.endpoint = this.name;\n    this.socket.packet(packet);\n    this.flags = {};\n    return this;\n  };\n\n  /**\n   * Sends a message\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.send = function (data, fn) {\n    var packet = {\n        type: this.flags.json ? 'json' : 'message'\n      , data: data\n    };\n\n    if ('function' == typeof fn) {\n      packet.id = ++this.ackPackets;\n      packet.ack = true;\n      this.acks[packet.id] = fn;\n    }\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Emits an event\n   *\n   * @api public\n   */\n  \n  SocketNamespace.prototype.emit = function (name) {\n    var args = Array.prototype.slice.call(arguments, 1)\n      , lastArg = args[args.length - 1]\n      , packet = {\n            type: 'event'\n          , name: name\n        };\n\n    if ('function' == typeof lastArg) {\n      packet.id = ++this.ackPackets;\n      packet.ack = 'data';\n      this.acks[packet.id] = lastArg;\n      args = args.slice(0, args.length - 1);\n    }\n\n    packet.args = args;\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Disconnects the namespace\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.disconnect = function () {\n    if (this.name === '') {\n      this.socket.disconnect();\n    } else {\n      this.packet({ type: 'disconnect' });\n      this.$emit('disconnect');\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles a packet\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.onPacket = function (packet) {\n    var self = this;\n\n    function ack () {\n      self.packet({\n          type: 'ack'\n        , args: io.util.toArray(arguments)\n        , ackId: packet.id\n      });\n    };\n\n    switch (packet.type) {\n      case 'connect':\n        this.$emit('connect');\n        break;\n\n      case 'disconnect':\n        if (this.name === '') {\n          this.socket.onDisconnect(packet.reason || 'booted');\n        } else {\n          this.$emit('disconnect', packet.reason);\n        }\n        break;\n\n      case 'message':\n      case 'json':\n        var params = ['message', packet.data];\n\n        if (packet.ack == 'data') {\n          params.push(ack);\n        } else if (packet.ack) {\n          this.packet({ type: 'ack', ackId: packet.id });\n        }\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'event':\n        var params = [packet.name].concat(packet.args);\n\n        if (packet.ack == 'data')\n          params.push(ack);\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'ack':\n        if (this.acks[packet.ackId]) {\n          this.acks[packet.ackId].apply(this, packet.args);\n          delete this.acks[packet.ackId];\n        }\n        break;\n\n      case 'error':\n        if (packet.advice){\n          this.socket.onError(packet);\n        } else {\n          if (packet.reason == 'unauthorized') {\n            this.$emit('connect_failed', packet.reason);\n          } else {\n            this.$emit('error', packet.reason);\n          }\n        }\n        break;\n    }\n  };\n\n  /**\n   * Flag interface.\n   *\n   * @api private\n   */\n\n  function Flag (nsp, name) {\n    this.namespace = nsp;\n    this.name = name;\n  };\n\n  /**\n   * Send a message\n   *\n   * @api public\n   */\n\n  Flag.prototype.send = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.send.apply(this.namespace, arguments);\n  };\n\n  /**\n   * Emit an event\n   *\n   * @api public\n   */\n\n  Flag.prototype.emit = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.emit.apply(this.namespace, arguments);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.websocket = WS;\n\n  /**\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n   * persistent connection with the Socket.IO server. This transport will also\n   * be inherited by the FlashSocket fallback as it provides a API compatible\n   * polyfill for the WebSockets.\n   *\n   * @constructor\n   * @extends {io.Transport}\n   * @api public\n   */\n\n  function WS (socket) {\n    io.Transport.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(WS, io.Transport);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  WS.prototype.name = 'websocket';\n\n  /**\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n   * all the appropriate listeners to handle the responses from the server.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.open = function () {\n    var query = io.util.query(this.socket.options.query)\n      , self = this\n      , Socket\n\n\n    if (!Socket) {\n      Socket = global.MozWebSocket || global.WebSocket;\n    }\n\n    this.websocket = new Socket(this.prepareUrl() + query);\n\n    this.websocket.onopen = function () {\n      self.onOpen();\n      self.socket.setBuffer(false);\n    };\n    this.websocket.onmessage = function (ev) {\n      self.onData(ev.data);\n    };\n    this.websocket.onclose = function () {\n      self.onClose();\n      self.socket.setBuffer(true);\n    };\n    this.websocket.onerror = function (e) {\n      self.onError(e);\n    };\n\n    return this;\n  };\n\n  /**\n   * Send a message to the Socket.IO server. The message will automatically be\n   * encoded in the correct message format.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  // Do to a bug in the current IDevices browser, we need to wrap the send in a \n  // setTimeout, when they resume from sleeping the browser will crash if \n  // we don't allow the browser time to detect the socket has been closed\n  if (io.util.ua.iDevice) {\n    WS.prototype.send = function (data) {\n      var self = this;\n      setTimeout(function() {\n         self.websocket.send(data);\n      },0);\n      return this;\n    };\n  } else {\n    WS.prototype.send = function (data) {\n      this.websocket.send(data);\n      return this;\n    };\n  }\n\n  /**\n   * Payload\n   *\n   * @api private\n   */\n\n  WS.prototype.payload = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      this.packet(arr[i]);\n    }\n    return this;\n  };\n\n  /**\n   * Disconnect the established `WebSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.close = function () {\n    this.websocket.close();\n    return this;\n  };\n\n  /**\n   * Handle the errors that `WebSocket` might be giving when we\n   * are attempting to connect or send messages.\n   *\n   * @param {Error} e The error.\n   * @api private\n   */\n\n  WS.prototype.onError = function (e) {\n    this.socket.onError(e);\n  };\n\n  /**\n   * Returns the appropriate scheme for the URI generation.\n   *\n   * @api private\n   */\n  WS.prototype.scheme = function () {\n    return this.socket.options.secure ? 'wss' : 'ws';\n  };\n\n  /**\n   * Checks if the browser has support for native `WebSockets` and that\n   * it's not the polyfill created for the FlashSocket transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  WS.check = function () {\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\n          || 'MozWebSocket' in global;\n  };\n\n  /**\n   * Check if the `WebSocket` transport support cross domain communications.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  WS.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('websocket');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.flashsocket = Flashsocket;\n\n  /**\n   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n   * specification. It uses a .swf file to communicate with the server. If you want\n   * to serve the .swf file from a other server than where the Socket.IO script is\n   * coming from you need to use the insecure version of the .swf. More information\n   * about this can be found on the github page.\n   *\n   * @constructor\n   * @extends {io.Transport.websocket}\n   * @api public\n   */\n\n  function Flashsocket () {\n    io.Transport.websocket.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(Flashsocket, io.Transport.websocket);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  Flashsocket.prototype.name = 'flashsocket';\n\n  /**\n   * Disconnect the established `FlashSocket` connection. This is done by adding a \n   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.open = function () {\n    var self = this\n      , args = arguments;\n\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.open.apply(self, args);\n    });\n    return this;\n  };\n  \n  /**\n   * Sends a message to the Socket.IO server. This is done by adding a new\n   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.send = function () {\n    var self = this, args = arguments;\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.send.apply(self, args);\n    });\n    return this;\n  };\n\n  /**\n   * Disconnects the established `FlashSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.close = function () {\n    WebSocket.__tasks.length = 0;\n    io.Transport.websocket.prototype.close.call(this);\n    return this;\n  };\n\n  /**\n   * The WebSocket fall back needs to append the flash container to the body\n   * element, so we need to make sure we have access to it. Or defer the call\n   * until we are sure there is a body element.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Flashsocket.prototype.ready = function (socket, fn) {\n    function init () {\n      var options = socket.options\n        , port = options['flash policy port']\n        , path = [\n              'http' + (options.secure ? 's' : '') + ':/'\n            , options.host + ':' + options.port\n            , options.resource\n            , 'static/flashsocket'\n            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\n          ];\n\n      // Only start downloading the swf file when the checked that this browser\n      // actually supports it\n      if (!Flashsocket.loaded) {\n        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n          // Set the correct file based on the XDomain settings\n          WEB_SOCKET_SWF_LOCATION = path.join('/');\n        }\n\n        if (port !== 843) {\n          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n        }\n\n        WebSocket.__initialize();\n        Flashsocket.loaded = true;\n      }\n\n      fn.call(self);\n    }\n\n    var self = this;\n    if (document.body) return init();\n\n    io.util.load(init);\n  };\n\n  /**\n   * Check if the FlashSocket transport is supported as it requires that the Adobe\n   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n   * the polyfill is correctly loaded.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.check = function () {\n    if (\n        typeof WebSocket == 'undefined'\n      || !('__initialize' in WebSocket) || !swfobject\n    ) return false;\n\n    return swfobject.getFlashPlayerVersion().major >= 10;\n  };\n\n  /**\n   * Check if the FlashSocket transport can be used as cross domain / cross origin \n   * transport. Because we can't see which type (secure or insecure) of .swf is used\n   * we will just return true.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Disable AUTO_INITIALIZATION\n   */\n\n  if (typeof window != 'undefined') {\n    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n  }\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('flashsocket');\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/*\tSWFObject v2.2 <http://code.google.com/p/swfobject/> \n\tis released under the MIT License <http://www.opensource.org/licenses/mit-license.php> \n*/\nif ('undefined' != typeof window) {\nvar swfobject=function(){var D=\"undefined\",r=\"object\",S=\"Shockwave Flash\",W=\"ShockwaveFlash.ShockwaveFlash\",q=\"application/x-shockwave-flash\",R=\"SWFObjectExprInst\",x=\"onreadystatechange\",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):false,X=!+\"\\v1\",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\");ag[0]=parseInt(ab.replace(/^(.*)\\..*$/,\"$1\"),10);ag[1]=parseInt(ab.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable(\"$version\");if(ab){X=true;ab=ab.split(\" \")[1].split(\",\");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState==\"complete\")||(typeof j.readyState==D&&(j.getElementsByTagName(\"body\")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(\"DOMContentLoaded\",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState==\"complete\"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(\"left\")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(\"body\")[0].appendChild(C(\"span\"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(\"load\",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(\"load\",Y,false)}else{if(typeof O.attachEvent!=D){i(O,\"onload\",Y)}else{if(typeof O.onload==\"function\"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(\"body\")[0];var aa=C(r);aa.setAttribute(\"type\",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(\"$version\");if(ab){ab=ab.split(\" \")[1].split(\",\");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(\"width\")||\"0\";ai.height=ae.getAttribute(\"height\")||\"0\";if(ae.getAttribute(\"class\")){ai.styleclass=ae.getAttribute(\"class\")}if(ae.getAttribute(\"align\")){ai.align=ae.getAttribute(\"align\")}var ah={};var X=ae.getElementsByTagName(\"param\");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute(\"name\").toLowerCase()!=\"movie\"){ah[X[ad].getAttribute(\"name\")]=X[ad].getAttribute(\"value\")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName==\"OBJECT\"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F(\"6.0.65\")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==\"OBJECT\"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width=\"310\"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height=\"137\"}j.title=j.title.slice(0,47)+\" - Flash Player Installation\";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):\"PlugIn\",ac=\"MMredirectURL=\"+O.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+ad+\"&MMdoctitle=\"+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=\"&\"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C(\"div\");X+=\"SWFObjectNew\";Y.setAttribute(\"id\",X);ae.parentNode.insertBefore(Y,ae);ae.style.display=\"none\";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C(\"div\");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=\"none\";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(\"div\");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName==\"PARAM\")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah=\"\";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==\"data\"){ag.movie=ai[ae]}else{if(ae.toLowerCase()==\"styleclass\"){ah+=' class=\"'+ai[ae]+'\"'}else{if(ae.toLowerCase()!=\"classid\"){ah+=\" \"+ae+'=\"'+ai[ae]+'\"'}}}}}var af=\"\";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name=\"'+ad+'\" value=\"'+ag[ad]+'\" />'}}aa.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+ah+\">\"+af+\"</object>\";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(\"type\",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==\"styleclass\"){Z.setAttribute(\"class\",ai[ac])}else{if(ac.toLowerCase()!=\"classid\"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!=\"movie\"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(\"param\");aa.setAttribute(\"name\",X);aa.setAttribute(\"value\",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName==\"OBJECT\"){if(M.ie&&M.win){X.style.display=\"none\";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==\"function\"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(\".\");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName(\"head\")[0];if(!aa){return}var X=(ad&&typeof ad==\"string\")?ad:\"screen\";if(ab){n=null;G=null}if(!n||G!=X){var Z=C(\"style\");Z.setAttribute(\"type\",\"text/css\");Z.setAttribute(\"media\",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+\" {\"+Y+\"}\"))}}}function w(Z,X){if(!m){return}var Y=X?\"visible\":\"hidden\";if(J&&c(Z)){c(Z).style.visibility=Y}else{v(\"#\"+Z,\"visibility:\"+Y)}}function L(Y){var Z=/[\\\\\\\"<>\\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent(\"onunload\",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+=\"\";ag+=\"\";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=\"&\"+ai+\"=\"+Z[ai]}else{am.flashvars=ai+\"=\"+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\\?/.test(Z)){Z=Z.split(\"?\")[1]}if(aa==null){return L(Z)}var Y=Z.split(\"&\");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(\"=\"))==aa){return L(Y[X].substring((Y[X].indexOf(\"=\")+1)))}}}return\"\"},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display=\"block\"}}if(E){E(B)}}a=false}}}}();\n}\n// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>\n// License: New BSD License\n// Reference: http://dev.w3.org/html5/websockets/\n// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\n\n(function() {\n  \n  if ('undefined' == typeof window || window.WebSocket) return;\n\n  var console = window.console;\n  if (!console || !console.log || !console.error) {\n    console = {log: function(){ }, error: function(){ }};\n  }\n  \n  if (!swfobject.hasFlashPlayerVersion(\"10.0.0\")) {\n    console.error(\"Flash Player >= 10.0.0 is required.\");\n    return;\n  }\n  if (location.protocol == \"file:\") {\n    console.error(\n      \"WARNING: web-socket-js doesn't work in file:///... URL \" +\n      \"unless you set Flash Security Settings properly. \" +\n      \"Open the page via Web server i.e. http://...\");\n  }\n\n  /**\n   * This class represents a faux web socket.\n   * @param {string} url\n   * @param {array or string} protocols\n   * @param {string} proxyHost\n   * @param {int} proxyPort\n   * @param {string} headers\n   */\n  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {\n    var self = this;\n    self.__id = WebSocket.__nextId++;\n    WebSocket.__instances[self.__id] = self;\n    self.readyState = WebSocket.CONNECTING;\n    self.bufferedAmount = 0;\n    self.__events = {};\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols == \"string\") {\n      protocols = [protocols];\n    }\n    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.\n    // Otherwise, when onopen fires immediately, onopen is called before it is set.\n    setTimeout(function() {\n      WebSocket.__addTask(function() {\n        WebSocket.__flash.create(\n            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);\n      });\n    }, 0);\n  };\n\n  /**\n   * Send data to the web socket.\n   * @param {string} data  The data to send to the socket.\n   * @return {boolean}  True for success, false for failure.\n   */\n  WebSocket.prototype.send = function(data) {\n    if (this.readyState == WebSocket.CONNECTING) {\n      throw \"INVALID_STATE_ERR: Web Socket connection has not been established\";\n    }\n    // We use encodeURIComponent() here, because FABridge doesn't work if\n    // the argument includes some characters. We don't use escape() here\n    // because of this:\n    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions\n    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't\n    // preserve all Unicode characters either e.g. \"\\uffff\" in Firefox.\n    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require\n    // additional testing.\n    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));\n    if (result < 0) { // success\n      return true;\n    } else {\n      this.bufferedAmount += result;\n      return false;\n    }\n  };\n\n  /**\n   * Close this web socket gracefully.\n   */\n  WebSocket.prototype.close = function() {\n    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {\n      return;\n    }\n    this.readyState = WebSocket.CLOSING;\n    WebSocket.__flash.close(this.__id);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) {\n      this.__events[type] = [];\n    }\n    this.__events[type].push(listener);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) return;\n    var events = this.__events[type];\n    for (var i = events.length - 1; i >= 0; --i) {\n      if (events[i] === listener) {\n        events.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {Event} event\n   * @return void\n   */\n  WebSocket.prototype.dispatchEvent = function(event) {\n    var events = this.__events[event.type] || [];\n    for (var i = 0; i < events.length; ++i) {\n      events[i](event);\n    }\n    var handler = this[\"on\" + event.type];\n    if (handler) handler(event);\n  };\n\n  /**\n   * Handles an event from Flash.\n   * @param {Object} flashEvent\n   */\n  WebSocket.prototype.__handleEvent = function(flashEvent) {\n    if (\"readyState\" in flashEvent) {\n      this.readyState = flashEvent.readyState;\n    }\n    if (\"protocol\" in flashEvent) {\n      this.protocol = flashEvent.protocol;\n    }\n    \n    var jsEvent;\n    if (flashEvent.type == \"open\" || flashEvent.type == \"error\") {\n      jsEvent = this.__createSimpleEvent(flashEvent.type);\n    } else if (flashEvent.type == \"close\") {\n      // TODO implement jsEvent.wasClean\n      jsEvent = this.__createSimpleEvent(\"close\");\n    } else if (flashEvent.type == \"message\") {\n      var data = decodeURIComponent(flashEvent.message);\n      jsEvent = this.__createMessageEvent(\"message\", data);\n    } else {\n      throw \"unknown event type: \" + flashEvent.type;\n    }\n    \n    this.dispatchEvent(jsEvent);\n  };\n  \n  WebSocket.prototype.__createSimpleEvent = function(type) {\n    if (document.createEvent && window.Event) {\n      var event = document.createEvent(\"Event\");\n      event.initEvent(type, false, false);\n      return event;\n    } else {\n      return {type: type, bubbles: false, cancelable: false};\n    }\n  };\n  \n  WebSocket.prototype.__createMessageEvent = function(type, data) {\n    if (document.createEvent && window.MessageEvent && !window.opera) {\n      var event = document.createEvent(\"MessageEvent\");\n      event.initMessageEvent(\"message\", false, false, data, null, null, window, null);\n      return event;\n    } else {\n      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.\n      return {type: type, data: data, bubbles: false, cancelable: false};\n    }\n  };\n  \n  /**\n   * Define the WebSocket readyState enumeration.\n   */\n  WebSocket.CONNECTING = 0;\n  WebSocket.OPEN = 1;\n  WebSocket.CLOSING = 2;\n  WebSocket.CLOSED = 3;\n\n  WebSocket.__flash = null;\n  WebSocket.__instances = {};\n  WebSocket.__tasks = [];\n  WebSocket.__nextId = 0;\n  \n  /**\n   * Load a new flash security policy file.\n   * @param {string} url\n   */\n  WebSocket.loadFlashPolicyFile = function(url){\n    WebSocket.__addTask(function() {\n      WebSocket.__flash.loadManualPolicyFile(url);\n    });\n  };\n\n  /**\n   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.\n   */\n  WebSocket.__initialize = function() {\n    if (WebSocket.__flash) return;\n    \n    if (WebSocket.__swfLocation) {\n      // For backword compatibility.\n      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;\n    }\n    if (!window.WEB_SOCKET_SWF_LOCATION) {\n      console.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");\n      return;\n    }\n    var container = document.createElement(\"div\");\n    container.id = \"webSocketContainer\";\n    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents\n    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).\n    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash\n    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is\n    // the best we can do as far as we know now.\n    container.style.position = \"absolute\";\n    if (WebSocket.__isFlashLite()) {\n      container.style.left = \"0px\";\n      container.style.top = \"0px\";\n    } else {\n      container.style.left = \"-100px\";\n      container.style.top = \"-100px\";\n    }\n    var holder = document.createElement(\"div\");\n    holder.id = \"webSocketFlash\";\n    container.appendChild(holder);\n    document.body.appendChild(container);\n    // See this article for hasPriority:\n    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\n    swfobject.embedSWF(\n      WEB_SOCKET_SWF_LOCATION,\n      \"webSocketFlash\",\n      \"1\" /* width */,\n      \"1\" /* height */,\n      \"10.0.0\" /* SWF version */,\n      null,\n      null,\n      {hasPriority: true, swliveconnect : true, allowScriptAccess: \"always\"},\n      null,\n      function(e) {\n        if (!e.success) {\n          console.error(\"[WebSocket] swfobject.embedSWF failed\");\n        }\n      });\n  };\n  \n  /**\n   * Called by Flash to notify JS that it's fully loaded and ready\n   * for communication.\n   */\n  WebSocket.__onFlashInitialized = function() {\n    // We need to set a timeout here to avoid round-trip calls\n    // to flash during the initialization process.\n    setTimeout(function() {\n      WebSocket.__flash = document.getElementById(\"webSocketFlash\");\n      WebSocket.__flash.setCallerUrl(location.href);\n      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);\n      for (var i = 0; i < WebSocket.__tasks.length; ++i) {\n        WebSocket.__tasks[i]();\n      }\n      WebSocket.__tasks = [];\n    }, 0);\n  };\n  \n  /**\n   * Called by Flash to notify WebSockets events are fired.\n   */\n  WebSocket.__onFlashEvent = function() {\n    setTimeout(function() {\n      try {\n        // Gets events using receiveEvents() instead of getting it from event object\n        // of Flash event. This is to make sure to keep message order.\n        // It seems sometimes Flash events don't arrive in the same order as they are sent.\n        var events = WebSocket.__flash.receiveEvents();\n        for (var i = 0; i < events.length; ++i) {\n          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }, 0);\n    return true;\n  };\n  \n  // Called by Flash.\n  WebSocket.__log = function(message) {\n    console.log(decodeURIComponent(message));\n  };\n  \n  // Called by Flash.\n  WebSocket.__error = function(message) {\n    console.error(decodeURIComponent(message));\n  };\n  \n  WebSocket.__addTask = function(task) {\n    if (WebSocket.__flash) {\n      task();\n    } else {\n      WebSocket.__tasks.push(task);\n    }\n  };\n  \n  /**\n   * Test if the browser is running flash lite.\n   * @return {boolean} True if flash lite is running, false otherwise.\n   */\n  WebSocket.__isFlashLite = function() {\n    if (!window.navigator || !window.navigator.mimeTypes) {\n      return false;\n    }\n    var mimeType = window.navigator.mimeTypes[\"application/x-shockwave-flash\"];\n    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {\n      return false;\n    }\n    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;\n  };\n  \n  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", function(){\n        WebSocket.__initialize();\n      }, false);\n    } else {\n      window.attachEvent(\"onload\", function(){\n        WebSocket.__initialize();\n      });\n    }\n  }\n  \n})();\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   *\n   * @api public\n   */\n\n  exports.XHR = XHR;\n\n  /**\n   * XHR constructor\n   *\n   * @costructor\n   * @api public\n   */\n\n  function XHR (socket) {\n    if (!socket) return;\n\n    io.Transport.apply(this, arguments);\n    this.sendBuffer = [];\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(XHR, io.Transport);\n\n  /**\n   * Establish a connection\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.open = function () {\n    this.socket.setBuffer(false);\n    this.onOpen();\n    this.get();\n\n    // we need to make sure the request succeeds since we have no indication\n    // whether the request opened or not until it succeeded.\n    this.setCloseTimeout();\n\n    return this;\n  };\n\n  /**\n   * Check if we need to send data to the Socket.IO server, if we have data in our\n   * buffer we encode it and forward it to the `post` method.\n   *\n   * @api private\n   */\n\n  XHR.prototype.payload = function (payload) {\n    var msgs = [];\n\n    for (var i = 0, l = payload.length; i < l; i++) {\n      msgs.push(io.parser.encodePacket(payload[i]));\n    }\n\n    this.send(io.parser.encodePayload(msgs));\n  };\n\n  /**\n   * Send data to the Socket.IO server.\n   *\n   * @param data The message\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.send = function (data) {\n    this.post(data);\n    return this;\n  };\n\n  /**\n   * Posts a encoded message to the Socket.IO server.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  function empty () { };\n\n  XHR.prototype.post = function (data) {\n    var self = this;\n    this.socket.setBuffer(true);\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n        self.posting = false;\n\n        if (this.status == 200){\n          self.socket.setBuffer(false);\n        } else {\n          self.onClose();\n        }\n      }\n    }\n\n    function onload () {\n      this.onload = empty;\n      self.socket.setBuffer(false);\n    };\n\n    this.sendXHR = this.request('POST');\n\n    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\n      this.sendXHR.onload = this.sendXHR.onerror = onload;\n    } else {\n      this.sendXHR.onreadystatechange = stateChange;\n    }\n\n    this.sendXHR.send(data);\n  };\n\n  /**\n   * Disconnects the established `XHR` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.close = function () {\n    this.onClose();\n    return this;\n  };\n\n  /**\n   * Generates a configured XHR request\n   *\n   * @param {String} url The url that needs to be requested.\n   * @param {String} method The method the request should use.\n   * @returns {XMLHttpRequest}\n   * @api private\n   */\n\n  XHR.prototype.request = function (method) {\n    var req = io.util.request(this.socket.isXDomain())\n      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\n\n    req.open(method || 'GET', this.prepareUrl() + query, true);\n\n    if (method == 'POST') {\n      try {\n        if (req.setRequestHeader) {\n          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        } else {\n          // XDomainRequest\n          req.contentType = 'text/plain';\n        }\n      } catch (e) {}\n    }\n\n    return req;\n  };\n\n  /**\n   * Returns the scheme to use for the transport URLs.\n   *\n   * @api private\n   */\n\n  XHR.prototype.scheme = function () {\n    return this.socket.options.secure ? 'https' : 'http';\n  };\n\n  /**\n   * Check if the XHR transports are supported\n   *\n   * @param {Boolean} xdomain Check if we support cross domain requests.\n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.check = function (socket, xdomain) {\n    try {\n      var request = io.util.request(xdomain),\n          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),\n          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),\n          isXProtocol = (global.location && socketProtocol != global.location.protocol);\n      if (request && !(usesXDomReq && isXProtocol)) {\n        return true;\n      }\n    } catch(e) {}\n\n    return false;\n  };\n\n  /**\n   * Check if the XHR transport supports cross domain requests.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.xdomainCheck = function (socket) {\n    return XHR.check(socket, true);\n  };\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.htmlfile = HTMLFile;\n\n  /**\n   * The HTMLFile transport creates a `forever iframe` based transport\n   * for Internet Explorer. Regular forever iframe implementations will \n   * continuously trigger the browsers buzy indicators. If the forever iframe\n   * is created inside a `htmlfile` these indicators will not be trigged.\n   *\n   * @constructor\n   * @extends {io.Transport.XHR}\n   * @api public\n   */\n\n  function HTMLFile (socket) {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(HTMLFile, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  HTMLFile.prototype.name = 'htmlfile';\n\n  /**\n   * Creates a new Ac...eX `htmlfile` with a forever loading iframe\n   * that can be used to listen to messages. Inside the generated\n   * `htmlfile` a reference will be made to the HTMLFile transport.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.get = function () {\n    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n    this.doc.open();\n    this.doc.write('<html></html>');\n    this.doc.close();\n    this.doc.parentWindow.s = this;\n\n    var iframeC = this.doc.createElement('div');\n    iframeC.className = 'socketio';\n\n    this.doc.body.appendChild(iframeC);\n    this.iframe = this.doc.createElement('iframe');\n\n    iframeC.appendChild(this.iframe);\n\n    var self = this\n      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\n\n    this.iframe.src = this.prepareUrl() + query;\n\n    io.util.on(window, 'unload', function () {\n      self.destroy();\n    });\n  };\n\n  /**\n   * The Socket.IO server will write script tags inside the forever\n   * iframe, this function will be used as callback for the incoming\n   * information.\n   *\n   * @param {String} data The message\n   * @param {document} doc Reference to the context\n   * @api private\n   */\n\n  HTMLFile.prototype._ = function (data, doc) {\n    // unescape all forward slashes. see GH-1251\n    data = data.replace(/\\\\\\//g, '/');\n    this.onData(data);\n    try {\n      var script = doc.getElementsByTagName('script')[0];\n      script.parentNode.removeChild(script);\n    } catch (e) { }\n  };\n\n  /**\n   * Destroy the established connection, iframe and `htmlfile`.\n   * And calls the `CollectGarbage` function of Internet Explorer\n   * to release the memory.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.destroy = function () {\n    if (this.iframe){\n      try {\n        this.iframe.src = 'about:blank';\n      } catch(e){}\n\n      this.doc = null;\n      this.iframe.parentNode.removeChild(this.iframe);\n      this.iframe = null;\n\n      CollectGarbage();\n    }\n  };\n\n  /**\n   * Disconnects the established connection.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  HTMLFile.prototype.close = function () {\n    this.destroy();\n    return io.Transport.XHR.prototype.close.call(this);\n  };\n\n  /**\n   * Checks if the browser supports this transport. The browser\n   * must have an `Ac...eXObject` implementation.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  HTMLFile.check = function (socket) {\n    if (typeof window != \"undefined\" && (['Active'].concat('Object').join('X')) in window){\n      try {\n        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n        return a && io.Transport.XHR.check(socket);\n      } catch(e){}\n    }\n    return false;\n  };\n\n  /**\n   * Check if cross domain requests are supported.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  HTMLFile.xdomainCheck = function () {\n    // we can probably do handling for sub-domains, we should\n    // test that it's cross domain but a subdomain here\n    return false;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('htmlfile');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['xhr-polling'] = XHRPolling;\n\n  /**\n   * The XHR-polling transport uses long polling XHR requests to create a\n   * \"persistent\" connection with the server.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function XHRPolling () {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Merge the properties from XHR transport\n   */\n\n  io.util.merge(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  XHRPolling.prototype.name = 'xhr-polling';\n\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.heartbeats = function () {\n    return false;\n  };\n\n  /** \n   * Establish a connection, for iPhone and Android this will be done once the page\n   * is loaded.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  XHRPolling.prototype.open = function () {\n    var self = this;\n\n    io.Transport.XHR.prototype.open.call(self);\n    return false;\n  };\n\n  /**\n   * Starts a XHR request to wait for incoming messages.\n   *\n   * @api private\n   */\n\n  function empty () {};\n\n  XHRPolling.prototype.get = function () {\n    if (!this.isOpen) return;\n\n    var self = this;\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n\n        if (this.status == 200) {\n          self.onData(this.responseText);\n          self.get();\n        } else {\n          self.onClose();\n        }\n      }\n    };\n\n    function onload () {\n      this.onload = empty;\n      this.onerror = empty;\n      self.retryCounter = 1;\n      self.onData(this.responseText);\n      self.get();\n    };\n\n    function onerror () {\n      self.retryCounter ++;\n      if(!self.retryCounter || self.retryCounter > 3) {\n        self.onClose();  \n      } else {\n        self.get();\n      }\n    };\n\n    this.xhr = this.request();\n\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n      this.xhr.onload = onload;\n      this.xhr.onerror = onerror;\n    } else {\n      this.xhr.onreadystatechange = stateChange;\n    }\n\n    this.xhr.send(null);\n  };\n\n  /**\n   * Handle the unclean close behavior.\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.onClose = function () {\n    io.Transport.XHR.prototype.onClose.call(this);\n\n    if (this.xhr) {\n      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\n      try {\n        this.xhr.abort();\n      } catch(e){}\n      this.xhr = null;\n    }\n  };\n\n  /**\n   * Webkit based browsers show a infinit spinner when you start a XHR request\n   * before the browsers onload event is called so we need to defer opening of\n   * the transport until the onload event is called. Wrapping the cb in our\n   * defer method solve this.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  XHRPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n\n    io.util.defer(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('xhr-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n  /**\n   * There is a way to hide the loading indicator in Firefox. If you create and\n   * remove a iframe it will stop showing the current loading indicator.\n   * Unfortunately we can't feature detect that and UA sniffing is evil.\n   *\n   * @api private\n   */\n\n  var indicator = global.document && \"MozAppearance\" in\n    global.document.documentElement.style;\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['jsonp-polling'] = JSONPPolling;\n\n  /**\n   * The JSONP transport creates an persistent connection by dynamically\n   * inserting a script tag in the page. This script tag will receive the\n   * information of the Socket.IO server. When new information is received\n   * it creates a new script tag for the new data stream.\n   *\n   * @constructor\n   * @extends {io.Transport.xhr-polling}\n   * @api public\n   */\n\n  function JSONPPolling (socket) {\n    io.Transport['xhr-polling'].apply(this, arguments);\n\n    this.index = io.j.length;\n\n    var self = this;\n\n    io.j.push(function (msg) {\n      self._(msg);\n    });\n  };\n\n  /**\n   * Inherits from XHR polling transport.\n   */\n\n  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  JSONPPolling.prototype.name = 'jsonp-polling';\n\n  /**\n   * Posts a encoded message to the Socket.IO server using an iframe.\n   * The iframe is used because script tags can create POST based requests.\n   * The iframe is positioned outside of the view so the user does not\n   * notice it's existence.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  JSONPPolling.prototype.post = function (data) {\n    var self = this\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (!this.form) {\n      var form = document.createElement('form')\n        , area = document.createElement('textarea')\n        , id = this.iframeId = 'socketio_iframe_' + this.index\n        , iframe;\n\n      form.className = 'socketio';\n      form.style.position = 'absolute';\n      form.style.top = '0px';\n      form.style.left = '0px';\n      form.style.display = 'none';\n      form.target = id;\n      form.method = 'POST';\n      form.setAttribute('accept-charset', 'utf-8');\n      area.name = 'd';\n      form.appendChild(area);\n      document.body.appendChild(form);\n\n      this.form = form;\n      this.area = area;\n    }\n\n    this.form.action = this.prepareUrl() + query;\n\n    function complete () {\n      initIframe();\n      self.socket.setBuffer(false);\n    };\n\n    function initIframe () {\n      if (self.iframe) {\n        self.form.removeChild(self.iframe);\n      }\n\n      try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = document.createElement('<iframe name=\"'+ self.iframeId +'\">');\n      } catch (e) {\n        iframe = document.createElement('iframe');\n        iframe.name = self.iframeId;\n      }\n\n      iframe.id = self.iframeId;\n\n      self.form.appendChild(iframe);\n      self.iframe = iframe;\n    };\n\n    initIframe();\n\n    // we temporarily stringify until we figure out how to prevent\n    // browsers from turning `\\n` into `\\r\\n` in form inputs\n    this.area.value = io.JSON.stringify(data);\n\n    try {\n      this.form.submit();\n    } catch(e) {}\n\n    if (this.iframe.attachEvent) {\n      iframe.onreadystatechange = function () {\n        if (self.iframe.readyState == 'complete') {\n          complete();\n        }\n      };\n    } else {\n      this.iframe.onload = complete;\n    }\n\n    this.socket.setBuffer(true);\n  };\n\n  /**\n   * Creates a new JSONP poll that can be used to listen\n   * for messages from the Socket.IO server.\n   *\n   * @api private\n   */\n\n  JSONPPolling.prototype.get = function () {\n    var self = this\n      , script = document.createElement('script')\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (this.script) {\n      this.script.parentNode.removeChild(this.script);\n      this.script = null;\n    }\n\n    script.async = true;\n    script.src = this.prepareUrl() + query;\n    script.onerror = function () {\n      self.onClose();\n    };\n\n    var insertAt = document.getElementsByTagName('script')[0];\n    insertAt.parentNode.insertBefore(script, insertAt);\n    this.script = script;\n\n    if (indicator) {\n      setTimeout(function () {\n        var iframe = document.createElement('iframe');\n        document.body.appendChild(iframe);\n        document.body.removeChild(iframe);\n      }, 100);\n    }\n  };\n\n  /**\n   * Callback function for the incoming message stream from the Socket.IO server.\n   *\n   * @param {String} data The message\n   * @api private\n   */\n\n  JSONPPolling.prototype._ = function (msg) {\n    this.onData(msg);\n    if (this.isOpen) {\n      this.get();\n    }\n    return this;\n  };\n\n  /**\n   * The indicator hack only works after onload\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  JSONPPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n    if (!indicator) return fn.call(this);\n\n    io.util.load(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Checks if browser supports this transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.check = function () {\n    return 'document' in global;\n  };\n\n  /**\n   * Check if cross domain requests are supported\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('jsonp-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\nif (typeof define === \"function\" && define.amd) {\n  define([], function () { return io; });\n}\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/dist/socket.io.js\n ** module id = 20\n ** module chunks = 0\n **/","// Copyright (c) 2010 David Durman\n//\n// The contents of this file are subject to the MIT License (the \"License\");\n// you may not use this file except in compliance with the License. You may obtain a copy of the License at\n// http://opensource.org/licenses/MIT.\n//\n// This hierarchical state machine implementation has been inspired\n// by the QP active object framework, see http://www.state-machine.com/\n\n\n(function(root, factory){\n    \"use strict\";\n\n    if (typeof exports === 'object') {\n\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like enviroments that support module.exports,\n        // like Node.\n        module.exports = factory();\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        // AMD. Register as an anonymous module.\n        define(factory);\n\n    } else {\n\n        // Browser globals (root is window)\n        root.Statechart = factory();\n    }\n\n}(this, function(){\n\n    \"use strict\";\n\n    var assert = function(assertion){\n        if (!assertion) {\n            throw new Error(\"Assertion failed.\");\n        }\n    };\n\n\n    // Statechart.\n    // -----------\n\n    // `myState` - the current state\n    // `mySource` - the source of the current transition\n\n    var Statechart = {\n\n        run: function(opt){\n            opt = opt || {};\n            this.debug = opt.debug ? opt.debug : function(){};\n            this.construct(this.initialState);\n            this.init(null);\n        },\n\n        construct: function(initialState){\n            this.myState = this.top();\n            this.mySource = this.state(\"Initial\");\n\n            // Initial pseudo-state\n            this.states.Initial = {\n                empty: function(){\n                    this.newInitialState(initialState);\n                }\n            };\n            var handled = function(){ return null; };\n\n            // TOP state\n            this.states.TOP = {\n                entry: handled,\n                exit:  handled,\n                init:  handled,\n                empty: handled\n            };\n            this.flatten();\n        },\n\n        // Trigger the initial transition and recursively enter the submachine of the top state.\n        // Must be called only once for a given Statechart before dispatching any events to it.\n        init: function(anEventOrNull){\n            assert(this.myState === this.top() && this.mySource !== null);\n            var s = this.myState;    // save top in temp\n            this.mySource.trigger(anEventOrNull);    // topmost initial transition\n            assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n            s = this.myState;\n            s.enter();\n            while (s.init() === null) {    // while init is handled (i.e. till we reach a leaf node)\n                assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n                s = this.myState;\n                s.enter();\n            }\n        },\n\n        state: function(stateOrName){\n            return (stateOrName && stateOrName instanceof QState) ? stateOrName : new QState(this, stateOrName);\n        },\n\n        top: function(stateOrName){\n            // create the top state only once and store it to an auxiliary property\n            return (this._topState || (this._topState = new QState(this, \"TOP\")));\n        },\n\n        currentState: function(){\n            return this.myState;\n        },\n\n        flatten: function(){\n            this.statesTable = this.statesTable || {};\n            this._flatten(this.states, this.top().name);\n        },\n\n        _flatten: function(states, parent){\n            if (!states) {\n                return;\n            }\n\n            for (var state in states) {\n                if (states.hasOwnProperty(state)) {\n                    this.statesTable[state] = states[state];\n                    this.statesTable[state].parent = parent;\n                    this._flatten(states[state].states, state);\n                }\n            }\n        },\n\n        selectState: function(stateName){\n            return this.statesTable[stateName];\n        },\n\n        dispatchEvent: function(anEvent, state, act){\n            act = act || state[anEvent.type];\n\n            // Action might also be an array in which case it is assumed that evaluating guards decides\n            // which target to enter.\n            if (act instanceof Array) {\n                for (var i = 0; i < act.length; i++) {\n                    this.dispatchEvent(anEvent, state, act[i]);\n                }\n            }\n\n            // @todo This is terrible edge case used just for more fancy Statechart representation\n            // It allows using \"MyState\": { init: \"MySubState\", ... } intead of\n            // \"MyState\": { init: function(){ this.newInitialState(\"MySubState\"); }, ... }\n            // In some cases the latter form can be useful for better control of the Statechart\n            if (anEvent.type === \"init\" && typeof act === \"string\") {\n                this.newInitialState(act);\n                return null; // handled\n            }\n\n            if (act instanceof Function){\n                act.call(this, anEvent.args);\n                return null;  // handled\n            } else if (act) {\n                // no guard at all or the guard condition is met\n                if (!act.guard || (act.guard && act.guard.call(this, anEvent.args))){\n                    if (act.action) {\n                        act.action.call(this, anEvent.args);\n                    }\n                    if (act.target) {\n                        this.newState(act.target);\n                    }\n                    return null;  // handled\n                }\n            } else {        // act is undefined (no handler in state for anEvent)\n                if (state === this.selectState(\"TOP\")) {\n                    this.handleUnhandledEvent(anEvent); // not-handled\n                    return null;    // handled (TOP state handles all events)\n                }\n            }\n            return this.state(state.parent); // not-handled\n        },\n\n        // Override this when needed.\n        handleUnhandledEvent: function(anEvent){\n            this.debug(\"Unhandled event: \" + anEvent.type);\n            return null;\n        },\n\n        // Traverse the state hierarchy starting from the currently active state myState.\n        // Advance up the state hierarchy (i.e., from substates to superstates), invoking all\n        // the state handlers in succession. At each level of state nesting, it intercepts the value\n        // returned from a state handler to obtain the superstate needed to advance to the next level.\n        dispatch: function(anEvent, args){\n            if (!anEvent || !(anEvent instanceof QEvent)) {\n                anEvent = new QEvent(anEvent, args);\n            }\n            this.mySource = this.myState;\n            while (this.mySource) {\n                this.mySource = this.mySource.trigger(anEvent);\n            }\n        },\n\n        // Performs dynamic transition. (macro Q_TRAN_DYN())\n        newState: function(aStateName){\n            this.transition(this.state(aStateName));\n        },\n\n        // Used by handlers only in response to the #init event. (macro Q_INIT())\n        // USAGE: return this.newInitialState(\"whatever\");\n        // @return null for convenience\n\n        newInitialState: function(aStateOrName){\n            this.myState = this.state(aStateOrName);\n            return null;\n        },\n\n        // Dynamic transition. (Q_TRAN_DYN())\n        transition: function(target){\n            assert(!target.equals(this.top()));\n\n            var entry = [];\n            var mySource = this.mySource;\n            var s = this.myState;\n\n            // exit all the nested states between myState and mySource\n            assert(s !== null);\n            assert(mySource !== null);\n            while (!s.equals(mySource)) {\n                s = s.exit() || s.superstate();\n            }\n\n            // check all seven possible source/target state combinations\n\n\t    entry.push(target);\n\n            // (a) mySource == target (self transition)\n            if (mySource.equals(target)) {\n                mySource.exit();\n                return this.enterVia(target, entry);\n            }\n\n            // (b) mySource == target.superstate (one level deep)\n            var p = target.superstate();\n            if (mySource.equals(p)) {\n                return this.enterVia(target, entry);\n            }\n\n            assert(mySource !== null);\n\n            // (c) mySource.superstate == target.superstate (most common - fsa)\n            var q = mySource.superstate();\n            if (q.equals(p)) {\n                mySource.exit();\n                return this.enterVia(target, entry);\n            }\n\n            // (d) mySource.superstate == target (one level up)\n            if (q.equals(target)) {\n                mySource.exit();\n                entry.pop();    // do not enter the LCA\n                return this.enterVia(target, entry);\n            }\n\n            // (e) mySource == target.superstate.superstate... hierarchy (many levels deep)\n\t    entry.push(p);\n            s = p.superstate();\n            while (s !== null) {\n                if (mySource.equals(s)) {\n                    return this.enterVia(target, entry);\n                }\n\n\t\tentry.push(s);\n                s = s.superstate();\n            }\n\n            // otherwise we're definitely exiting mySource\n            mySource.exit();\n\n            // entry array is complete, save its length to avoid computing it repeatedly\n            var entryLength = entry.length;\n\n            // (f) mySource.superstate == target.superstate.superstate... hierarchy\n            var lca;\n            for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n                if (q.equals(entry[lca])) {\n                    return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n                }\n            }\n\n            // (g) each mySource.superstate.superstate... for each target.superstate.superstate...\n            s = q;\n            while (s !== null) {\n                for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n                    if (s.equals(entry[lca])) {\n                        return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n                    }\n                }\n                s.exit();\n                s = s.superstate();\n            }\n        },\n\n        // tail of transition()\n        // We are in the LCA of mySource and target.\n        enterVia: function(target, entry){\n\n            // retrace the entry path in reverse order\n            var idx = entry.length;\n            while (idx > 0) {\n                idx--;\n                entry[idx].enter();\n            }\n\n            this.myState = target;\n            while (target.init() === null) {\n                // initial transition must go one level deep\n                assert(target.equals(this.myState.superstate()));\n                target = this.myState;\n                target.enter();\n            }\n        }\n    };\n\n    // QState.\n    // -------\n\n    function QState(fsm, name){\n        this.fsm = fsm;\n        this.name = name;\n    }\n\n    QState.prototype = {\n        equals: function(state){\n            return (this.name === state.name && this.fsm === state.fsm);\n        },\n\n        dispatchEvent: function(anEvent, state){\n            return this.fsm.dispatchEvent(anEvent, state);\n        },\n\n        trigger: function(anEvent){\n            var evt = anEvent || QEventEmpty;\n            var state = this.fsm.selectState(this.name);\n            return this.dispatchEvent(evt, state);\n        },\n\n        enter: function(){\n            this.fsm.debug(\"[\" + this.name + \"] enter\");\n            return this.trigger(QEventEntry);\n        },\n\n        exit: function(){\n            this.fsm.debug(\"[\" + this.name + \"] exit\");\n            return this.trigger(QEventExit);\n        },\n\n        init: function(){\n            this.fsm.debug(\"[\" + this.name + \"] init\");\n            return this.trigger(QEventInit);\n        },\n\n        // Answer my superstate. Default is to return fsm top state.\n        superstate: function(){\n            var superstate = this.trigger(QEventEmpty);\n            if (superstate && superstate instanceof QState) {\n                return superstate;\n            }\n            superstate = this.fsm.top();\n            if (this.name === superstate.name) {\n                return null;\n            }\n            return superstate;\n        }\n    };\n\n    // QEvent\n    // ------\n\n    function QEvent(type, args){\n        this.type = type;\n        this.args = args;\n    }\n\n    // these events are static, they do not carry any arguments\n    // -> create them only once\n    // moreover, they don't have to be exposed to the outer world\n    var QEventEntry = new QEvent(\"entry\");\n    var QEventExit = new QEvent(\"exit\");\n    var QEventInit = new QEvent(\"init\");\n    var QEventEmpty = new QEvent(\"empty\");\n\n\n    return Statechart;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/statechart/lib/statechart.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 22\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"respoke.min.js"}